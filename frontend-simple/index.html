<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aditor Studio</title>
  
  
  <style type="text/css">@font-face {font-family:Inter;font-style:normal;font-weight:400;src:url(/cf-fonts/v/inter/5.0.16/vietnamese/wght/normal.woff2);unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:400;src:url(/cf-fonts/v/inter/5.0.16/latin/wght/normal.woff2);unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:400;src:url(/cf-fonts/v/inter/5.0.16/greek-ext/wght/normal.woff2);unicode-range:U+1F00-1FFF;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:400;src:url(/cf-fonts/v/inter/5.0.16/cyrillic/wght/normal.woff2);unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:400;src:url(/cf-fonts/v/inter/5.0.16/latin-ext/wght/normal.woff2);unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:400;src:url(/cf-fonts/v/inter/5.0.16/cyrillic-ext/wght/normal.woff2);unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:400;src:url(/cf-fonts/v/inter/5.0.16/greek/wght/normal.woff2);unicode-range:U+0370-03FF;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:500;src:url(/cf-fonts/v/inter/5.0.16/latin-ext/wght/normal.woff2);unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:500;src:url(/cf-fonts/v/inter/5.0.16/cyrillic-ext/wght/normal.woff2);unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:500;src:url(/cf-fonts/v/inter/5.0.16/greek-ext/wght/normal.woff2);unicode-range:U+1F00-1FFF;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:500;src:url(/cf-fonts/v/inter/5.0.16/vietnamese/wght/normal.woff2);unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:500;src:url(/cf-fonts/v/inter/5.0.16/cyrillic/wght/normal.woff2);unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:500;src:url(/cf-fonts/v/inter/5.0.16/greek/wght/normal.woff2);unicode-range:U+0370-03FF;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:500;src:url(/cf-fonts/v/inter/5.0.16/latin/wght/normal.woff2);unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:600;src:url(/cf-fonts/v/inter/5.0.16/greek-ext/wght/normal.woff2);unicode-range:U+1F00-1FFF;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:600;src:url(/cf-fonts/v/inter/5.0.16/greek/wght/normal.woff2);unicode-range:U+0370-03FF;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:600;src:url(/cf-fonts/v/inter/5.0.16/cyrillic/wght/normal.woff2);unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:600;src:url(/cf-fonts/v/inter/5.0.16/cyrillic-ext/wght/normal.woff2);unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:600;src:url(/cf-fonts/v/inter/5.0.16/latin/wght/normal.woff2);unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:600;src:url(/cf-fonts/v/inter/5.0.16/latin-ext/wght/normal.woff2);unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:600;src:url(/cf-fonts/v/inter/5.0.16/vietnamese/wght/normal.woff2);unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:700;src:url(/cf-fonts/v/inter/5.0.16/latin/wght/normal.woff2);unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:700;src:url(/cf-fonts/v/inter/5.0.16/vietnamese/wght/normal.woff2);unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:700;src:url(/cf-fonts/v/inter/5.0.16/cyrillic-ext/wght/normal.woff2);unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:700;src:url(/cf-fonts/v/inter/5.0.16/cyrillic/wght/normal.woff2);unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:700;src:url(/cf-fonts/v/inter/5.0.16/greek-ext/wght/normal.woff2);unicode-range:U+1F00-1FFF;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:700;src:url(/cf-fonts/v/inter/5.0.16/latin-ext/wght/normal.woff2);unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;font-display:swap;}@font-face {font-family:Inter;font-style:normal;font-weight:700;src:url(/cf-fonts/v/inter/5.0.16/greek/wght/normal.woff2);unicode-range:U+0370-03FF;font-display:swap;}</style>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #08080c;
      --bg-secondary: #0f0f14;
      --bg-tertiary: #16161d;
      --bg-hover: #1c1c26;
      --border: #232330;
      --text-primary: #ffffff;
      --text-secondary: #8b8b9e;
      --text-tertiary: #5c5c6f;
      --accent: #f97316;
      --accent-hover: #ea580c;
      --accent-glow: rgba(249, 115, 22, 0.15);
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* ===== TOP NAV ===== */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      padding: 16px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(8, 8, 12, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border);
    }

    .nav-logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      font-size: 18px;
    }

    .nav-logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--accent) 0%, #c2410c 100%);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 16px;
    }

    .nav-logo-img {
      height: 28px;
      width: auto;
    }

    .nav-tabs {
      display: flex;
      gap: 4px;
      background: var(--bg-tertiary);
      padding: 4px;
      border-radius: 12px;
    }

    .nav-tab {
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .nav-tab:hover {
      color: var(--text-primary);
      background: var(--bg-hover);
    }

    .nav-tab.active {
      color: var(--text-primary);
      background: var(--bg-primary);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .nav-profile {
      width: 36px;
      height: 36px;
      background: var(--bg-tertiary);
      border-radius: 50%;
      border: 2px solid var(--border);
      cursor: pointer;
      transition: border-color 0.2s ease;
    }

    .nav-profile:hover {
      border-color: var(--accent);
    }

    /* ===== MAIN CONTENT ===== */
    .main {
      padding-top: 80px;
      padding-bottom: 140px;
      min-height: 100vh;
    }

    /* ===== IMAGE GRID ===== */
    .grid-container {
      padding: 24px;
    }

    .grid-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    .grid-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .grid-count {
      font-size: 13px;
      color: var(--text-tertiary);
    }

    .masonry-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 12px;
    }

    @media (max-width: 1600px) {
      .masonry-grid { grid-template-columns: repeat(5, 1fr); }
    }
    @media (max-width: 1400px) {
      .masonry-grid { grid-template-columns: repeat(4, 1fr); }
    }
    @media (max-width: 1100px) {
      .masonry-grid { grid-template-columns: repeat(3, 1fr); }
    }
    @media (max-width: 800px) {
      .masonry-grid { grid-template-columns: repeat(2, 1fr); }
    }

    .grid-item {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      cursor: pointer;
      background: var(--bg-secondary);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      aspect-ratio: 9 / 16;
    }

    .grid-item:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
    }

    .grid-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      -webkit-user-drag: none;
      user-select: none;
    }

    .grid-item-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 50%);
      opacity: 0;
      transition: opacity 0.2s ease;
      display: flex;
      align-items: flex-end;
      padding: 12px;
    }

    .grid-item:hover .grid-item-overlay {
      opacity: 1;
    }

    .grid-item-actions {
      display: flex;
      gap: 8px;
      width: 100%;
    }

    .grid-item-btn {
      flex: 1;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .grid-item-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .grid-item-btn.primary {
      background: var(--accent);
    }

    .grid-item-btn.primary:hover {
      background: var(--accent-hover);
    }

    /* Drag indicator */
    .grid-item.dragging {
      opacity: 0.5;
    }

    .grid-item-drag-hint {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border-radius: 6px;
      font-size: 11px;
      color: var(--text-secondary);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .grid-item:hover .grid-item-drag-hint {
      opacity: 1;
    }

    /* Save to video button */
    .grid-item-save {
      position: absolute;
      bottom: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border: none;
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.2s ease;
    }

    .grid-item:hover .grid-item-save {
      opacity: 1;
    }

    .grid-item-save:hover {
      background: var(--accent);
      color: white;
      transform: scale(1.1);
    }

    .grid-item-save.saved {
      opacity: 1;
      background: var(--accent);
      color: white;
    }

    /* Delete button */
    .grid-item-delete {
      position: absolute;
      bottom: 8px;
      left: 8px;
      width: 32px;
      height: 32px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border: none;
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.2s ease;
    }

    .grid-item:hover .grid-item-delete {
      opacity: 1;
    }

    .grid-item-delete:hover {
      background: #dc2626;
      color: white;
      transform: scale(1.1);
    }

    .grid-item-delete svg {
      width: 16px;
      height: 16px;
    }

    /* Loading placeholder */
    .grid-item-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-tertiary);
      border: 2px dashed var(--border);
    }

    .grid-item-loading-inner {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 16px;
    }

    .grid-item-cancel {
      background: rgba(255, 60, 60, 0.2);
      border: 1px solid rgba(255, 60, 60, 0.4);
      color: #ff6b6b;
      padding: 6px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s;
    }
    .grid-item-cancel:hover {
      background: rgba(255, 60, 60, 0.4);
      color: #fff;
    }

    .grid-item-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .grid-item-loading-text {
      font-size: 12px;
      color: var(--text-secondary);
      text-align: center;
      max-width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .grid-item-save svg {
      width: 16px;
      height: 16px;
    }

    /* ===== PROMPT BAR ===== */
    .prompt-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 16px 24px 24px;
      background: linear-gradient(to top, var(--bg-primary) 70%, transparent);
      pointer-events: none;
    }

    .prompt-bar {
      max-width: 800px;
      margin: 0 auto;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 12px;
      pointer-events: auto;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .prompt-bar:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px var(--accent-glow);
    }

    .prompt-bar.drag-over {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px var(--accent-glow);
      background: var(--bg-tertiary);
    }

    .prompt-references {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      min-height: 0;
    }

    .prompt-references:empty {
      display: none;
    }

    .prompt-ref {
      position: relative;
      width: 48px;
      height: 48px;
      border-radius: 8px;
      overflow: hidden;
      background: var(--bg-tertiary);
    }

    .prompt-ref img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .prompt-ref-remove {
      position: absolute;
      top: -4px;
      right: -4px;
      width: 18px;
      height: 18px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 50%;
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
    }

    .prompt-ref-remove:hover {
      background: #dc2626;
      color: white;
      border-color: #dc2626;
    }

    .prompt-input-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .prompt-input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      font-size: 15px;
      color: var(--text-primary);
      padding: 8px 12px;
    }

    .prompt-input::placeholder {
      color: var(--text-tertiary);
    }

    .prompt-btn {
      width: 44px;
      height: 44px;
      background: var(--accent);
      border: none;
      border-radius: 12px;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease, transform 0.1s ease;
    }

    .prompt-btn:hover {
      background: var(--accent-hover);
    }

    .prompt-btn:active {
      transform: scale(0.95);
    }

    .prompt-btn svg {
      width: 20px;
      height: 20px;
    }

    .prompt-options {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
      align-items: center;
    }

    .prompt-option {
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s ease;
    }

    .prompt-option:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .prompt-option.active {
      background: var(--accent-glow);
      border-color: var(--accent);
      color: var(--accent);
    }

    .prompt-option svg {
      width: 14px;
      height: 14px;
    }

    .prompt-select {
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%238b8b9e' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      padding-right: 28px;
      transition: all 0.2s ease;
    }

    .prompt-select:hover {
      background-color: var(--bg-hover);
      color: var(--text-primary);
    }

    .prompt-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .prompt-spacer {
      flex: 1;
    }

    /* ===== FULLSCREEN MODAL ===== */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(20px);
      z-index: 200;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 40px;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-content {
      max-width: 90vw;
      max-height: 90vh;
      position: relative;
    }

    .modal-image {
      max-width: 100%;
      max-height: 80vh;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 20px;
    }

    .modal-btn {
      padding: 12px 24px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s ease;
    }

    .modal-btn:hover {
      background: var(--bg-hover);
    }

    .modal-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
    }

    .modal-btn.primary:hover {
      background: var(--accent-hover);
    }

    .modal-close {
      position: fixed;
      top: 80px;
      right: 40px;
      width: 44px;
      height: 44px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 50%;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.2s ease;
      z-index: 1001;
    }

    .modal-close:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .modal-meta {
      margin-top: 16px;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border-radius: 12px;
      font-size: 13px;
      color: var(--text-secondary);
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .modal-meta:empty {
      display: none;
    }

    .modal-meta-prompt {
      margin-bottom: 8px;
      color: var(--text-primary);
      line-height: 1.5;
    }

    .modal-meta-settings {
      display: flex;
      gap: 16px;
      font-size: 12px;
    }

    .modal-meta-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .modal-meta-label {
      color: var(--text-tertiary);
    }

    .modal-meta-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .modal-meta-btn {
      padding: 6px 12px;
      background: var(--bg-hover);
      border: none;
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .modal-meta-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    /* ===== EMPTY STATE ===== */
    .empty-state {
      text-align: center;
      padding: 80px 20px;
    }

    .empty-icon {
      width: 80px;
      height: 80px;
      background: var(--bg-secondary);
      border-radius: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 24px;
    }

    .empty-icon svg {
      width: 40px;
      height: 40px;
      color: var(--text-tertiary);
    }

    .empty-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .empty-desc {
      color: var(--text-secondary);
      font-size: 14px;
      max-width: 400px;
      margin: 0 auto;
    }

    /* ===== LOADING ===== */
    .generating {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px 32px;
      display: none;
      align-items: center;
      gap: 16px;
      z-index: 150;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .generating.active {
      display: flex;
    }

    .generating-spinner {
      width: 24px;
      height: 24px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .generating-text {
      font-size: 14px;
      font-weight: 500;
    }

    /* ===== DRAG GHOST ===== */
    .drag-ghost {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      width: 80px;
      height: 120px;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      opacity: 0.9;
    }

    .drag-ghost img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* ===== WORKFLOW STUDIO (Shortcuts Tab) ===== */
    .workflow-studio {
      display: grid;
      grid-template-columns: 220px 1fr 320px;
      height: calc(100vh - 65px);
      gap: 0;
    }

    /* Left sidebar - workflow list */
    .workflow-sidebar {
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      padding: 16px 0;
      overflow-y: auto;
    }

    .workflow-sidebar-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-tertiary);
      padding: 0 16px;
      margin-bottom: 12px;
    }

    .workflow-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      cursor: pointer;
      transition: all 0.15s ease;
      border-left: 3px solid transparent;
    }

    .workflow-item:hover {
      background: var(--bg-hover);
    }

    .workflow-item.active {
      background: var(--accent-glow);
      border-left-color: var(--accent);
    }

    .workflow-item-icon {
      width: 36px;
      height: 36px;
      background: var(--bg-tertiary);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .workflow-item.active .workflow-item-icon {
      background: var(--accent);
    }

    .workflow-item-icon svg {
      width: 18px;
      height: 18px;
      color: var(--text-secondary);
    }

    .workflow-item.active .workflow-item-icon svg {
      color: white;
    }

    .workflow-item-text {
      flex: 1;
      min-width: 0;
    }

    .workflow-item-name {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .workflow-item.coming-soon {
      opacity: 0.45;
      cursor: default;
      pointer-events: none;
    }

    .workflow-item.coming-soon:hover {
      background: transparent;
    }

    .workflow-item.coming-soon .workflow-item-name {
      color: var(--text-secondary);
    }

    .workflow-divider {
      padding: 16px 16px 8px;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-tertiary);
      text-transform: uppercase;
      letter-spacing: 0.8px;
      border-top: 1px solid var(--border);
      margin-top: 8px;
    }

    .workflow-item-desc {
      font-size: 11px;
      color: var(--text-tertiary);
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Center - workflow input area */
    .workflow-main {
      padding: 32px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .workflow-header {
      margin-bottom: 24px;
    }

    .workflow-header h2 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .workflow-header p {
      font-size: 14px;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    /* ===== MOTION TRANSFER WORKFLOW LAYOUT ===== */
    .motion-transfer-layout {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      height: 100%;
    }

    .webcam-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .webcam-container {
      flex: 1;
      background: var(--bg-tertiary);
      border-radius: 16px;
      overflow: hidden;
      position: relative;
      min-height: 360px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .webcam-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* Mirror for natural feel */
    }

    .webcam-preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .webcam-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      color: var(--text-secondary);
    }

    .webcam-placeholder svg {
      width: 48px;
      height: 48px;
    }

    .webcam-controls {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .webcam-btn {
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .webcam-btn-start {
      background: var(--accent);
      color: white;
      border: none;
    }

    .webcam-btn-start:hover {
      background: var(--accent-hover);
    }

    .webcam-btn-stop {
      background: #ef4444;
      color: white;
      border: none;
    }

    .webcam-btn-stop:hover {
      background: #dc2626;
    }

    .webcam-btn-retry {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    .webcam-btn-retry:hover {
      background: var(--bg-hover);
    }

    .webcam-timer {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(239, 68, 68, 0.9);
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      display: none;
    }

    .webcam-timer.recording {
      display: block;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .character-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .character-upload {
      flex: 1;
      border: 2px dashed var(--border);
      border-radius: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 360px;
      position: relative;
      overflow: hidden;
    }

    .character-upload:hover {
      border-color: var(--accent);
      background: var(--accent-glow);
    }

    .character-upload.has-image {
      border-style: solid;
    }

    .character-upload .character-preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
    }

    .character-upload .character-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      color: var(--text-secondary);
    }

    .character-upload.has-image .character-placeholder {
      display: none;
    }

    .character-placeholder svg {
      width: 48px;
      height: 48px;
    }

    .motion-generate-row {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 16px;
    }

    .motion-generate-btn {
      padding: 14px 48px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .motion-generate-btn:hover {
      background: var(--accent-hover);
    }

    .motion-generate-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* ===== UGC VIDEO WORKFLOW LAYOUT ===== */
    .ugc-video-layout {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 24px;
      height: 100%;
    }

    .ugc-avatar-section {
      display: flex;
      flex-direction: column;
    }

    .ugc-avatar-upload {
      flex: 1;
      border: 2px dashed var(--border);
      border-radius: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 300px;
      position: relative;
      overflow: hidden;
    }

    .ugc-avatar-upload:hover,
    .ugc-avatar-upload.has-image:hover {
      border-color: var(--accent);
      background: var(--accent-glow);
    }

    .ugc-avatar-upload.has-image {
      border-style: solid;
      padding: 0;
    }

    .ugc-avatar-upload .avatar-preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
    }

    .ugc-avatar-upload .avatar-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      color: var(--text-secondary);
    }

    .ugc-avatar-upload.has-image .avatar-placeholder {
      display: none;
    }

    .ugc-avatar-upload .avatar-placeholder svg {
      width: 48px;
      height: 48px;
    }

    .ugc-script-section {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .ugc-script-textarea {
      flex: 1;
      min-height: 240px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 14px;
      line-height: 1.6;
      resize: none;
    }

    .ugc-script-textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .ugc-script-textarea::placeholder {
      color: var(--text-tertiary);
    }

    .ugc-voice-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .ugc-voice-row label {
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .ugc-voice-search-container {
      flex: 1;
      max-width: 400px;
      position: relative;
    }

    .ugc-voice-search {
      width: 100%;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      color: var(--text-primary);
      font-size: 14px;
    }

    .ugc-voice-search:focus {
      outline: none;
      border-color: var(--accent);
    }

    .ugc-voice-search::placeholder {
      color: var(--text-tertiary);
    }

    .ugc-voice-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 8px 8px;
      z-index: 100;
      display: none;
    }

    .ugc-voice-dropdown.open {
      display: block;
    }

    .ugc-voice-option {
      padding: 10px 14px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
    }

    .ugc-voice-option:last-child {
      border-bottom: none;
    }

    .ugc-voice-option:hover {
      background: var(--bg-hover);
    }

    .ugc-voice-option.selected {
      background: var(--accent-glow);
    }

    .ugc-voice-name {
      font-size: 14px;
      color: var(--text-primary);
    }

    .ugc-voice-category {
      font-size: 11px;
      color: var(--text-tertiary);
      text-transform: uppercase;
    }

    .ugc-voice-preview-btn {
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
    }

    .ugc-voice-preview-btn:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .ugc-voice-select {
      flex: 1;
      max-width: 300px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
    }

    .ugc-voice-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .ugc-generate-btn {
      padding: 12px 32px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .ugc-generate-btn:hover {
      background: var(--accent-hover);
    }

    .ugc-generate-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .workflow-upload-zone {
      border: 2px dashed var(--border);
      border-radius: 16px;
      padding: 48px 32px;
      text-align: center;
      transition: all 0.2s ease;
      cursor: pointer;
      margin-bottom: 24px;
    }

    .workflow-upload-zone:hover,
    .workflow-upload-zone.dragover {
      border-color: var(--accent);
      background: var(--accent-glow);
    }

    .workflow-upload-icon {
      width: 64px;
      height: 64px;
      background: var(--bg-tertiary);
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px;
    }

    .workflow-upload-icon svg {
      width: 32px;
      height: 32px;
      color: var(--text-secondary);
    }

    .workflow-upload-zone:hover .workflow-upload-icon,
    .workflow-upload-zone.dragover .workflow-upload-icon {
      background: var(--accent);
    }

    .workflow-upload-zone:hover .workflow-upload-icon svg,
    .workflow-upload-zone.dragover .workflow-upload-icon svg {
      color: white;
    }

    .workflow-upload-text {
      font-size: 15px;
      color: var(--text-primary);
      margin-bottom: 8px;
    }

    .workflow-upload-hint {
      font-size: 13px;
      color: var(--text-tertiary);
    }

    .workflow-upload-preview {
      display: none;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 16px;
    }

    .workflow-upload-preview.has-files {
      display: flex;
    }

    .workflow-preview-item {
      position: relative;
      width: 80px;
      height: 80px;
      border-radius: 8px;
      overflow: hidden;
      background: var(--bg-tertiary);
    }

    .workflow-preview-item img,
    .workflow-preview-item video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .workflow-preview-remove {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 20px;
      height: 20px;
      background: rgba(0,0,0,0.7);
      border: none;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .workflow-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
      flex: 1;
    }

    .workflow-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .workflow-field label {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .workflow-field input,
    .workflow-field textarea {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 14px;
      font-size: 14px;
      color: var(--text-primary);
      transition: border-color 0.2s ease;
    }

    .workflow-field input:focus,
    .workflow-field textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .workflow-field textarea {
      resize: vertical;
      min-height: 100px;
    }

    .workflow-submit-btn {
      background: var(--accent);
      border: none;
      border-radius: 12px;
      padding: 14px 24px;
      font-size: 15px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: background 0.2s ease;
      margin-top: auto;
    }

    .workflow-submit-btn:hover {
      background: var(--accent-hover);
    }

    .workflow-submit-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Right - results panel */
    .workflow-results {
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      padding: 16px;
      overflow-y: auto;
    }

    .workflow-results-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .workflow-results-count {
      background: var(--bg-tertiary);
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 12px;
    }

    .workflow-results-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    .workflow-result-item {
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      aspect-ratio: 9 / 16;
      background: var(--bg-tertiary);
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .workflow-result-item:hover {
      transform: scale(1.02);
    }

    .workflow-result-item img,
    .workflow-result-item video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .workflow-result-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .workflow-result-loading .grid-item-spinner {
      width: 24px;
      height: 24px;
    }

    .workflow-result-video {
      aspect-ratio: 9 / 16;
      display: flex;
      flex-direction: column;
    }

    .workflow-result-video video {
      flex: 1;
      min-height: 0;
    }

    .workflow-download-link {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px;
      background: var(--accent);
      color: white;
      text-decoration: none;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.2s ease;
    }

    .workflow-download-link:hover {
      background: var(--accent-hover);
    }

    .workflow-results-empty {
      text-align: center;
      padding: 40px 16px;
      color: var(--text-tertiary);
      font-size: 13px;
    }

    .workflow-results-empty svg {
      width: 48px;
      height: 48px;
      color: var(--border);
      margin-bottom: 12px;
    }

    /* Legacy shortcut styles (hidden, kept for compatibility) */
    .shortcuts-grid {
      display: none;
    }

    .shortcut-card {
      display: none;
    }

    .shortcut-icon {
      width: 48px;
      height: 48px;
      background: var(--accent-glow);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
    }

    .shortcut-icon svg {
      width: 24px;
      height: 24px;
      color: var(--accent);
    }

    .shortcut-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .shortcut-desc {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    /* ===== VIDEO QUEUE ===== */
    .video-queue-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 12px;
    }

    @media (max-width: 1600px) {
      .video-queue-grid { grid-template-columns: repeat(5, 1fr); }
    }
    @media (max-width: 1400px) {
      .video-queue-grid { grid-template-columns: repeat(4, 1fr); }
    }
    @media (max-width: 1100px) {
      .video-queue-grid { grid-template-columns: repeat(3, 1fr); }
    }
    @media (max-width: 800px) {
      .video-queue-grid { grid-template-columns: repeat(2, 1fr); }
    }

    .video-queue-item {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      transition: all 0.2s ease;
    }

    .video-queue-item.generating {
      border-color: var(--accent);
    }

    .video-queue-item:hover {
      border-color: var(--accent);
    }

    .video-queue-preview {
      position: relative;
      aspect-ratio: 9 / 16;
    }

    .video-queue-thumb {
      width: 100%;
      aspect-ratio: 9 / 16;
      border-radius: 8px;
      object-fit: cover;
    }

    .video-queue-thumb.generating-blur {
      filter: blur(8px);
      opacity: 0.6;
    }

    .video-generating-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      color: white;
      font-size: 14px;
      font-weight: 500;
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .video-queue-preview {
      position: relative;
    }

    .video-queue-meta {
      padding: 12px;
      border-top: 1px solid var(--border);
    }

    .video-queue-status-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .video-queue-remove {
      margin-left: auto;
      background: none;
      border: none;
      color: var(--text-tertiary);
      font-size: 18px;
      cursor: pointer;
      padding: 0 4px;
    }

    .video-queue-remove:hover {
      color: #dc2626;
    }

    .video-queue-info {
      flex: 1;
      min-width: 0;
    }

    .video-queue-prompt {
      font-size: 13px;
      color: var(--text-primary);
      line-height: 1.5;
      margin-bottom: 8px;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .video-queue-prompt-input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 13px;
      color: var(--text-primary);
      resize: none;
      font-family: inherit;
    }

    .video-queue-prompt-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .video-queue-status {
      font-size: 12px;
      color: var(--text-tertiary);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .video-queue-status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-tertiary);
    }

    .video-queue-status-dot.pending { background: #f59e0b; }
    .video-queue-status-dot.generating { background: var(--accent); animation: pulse 1s infinite; }
    .video-queue-status-dot.complete { background: #22c55e; }
    .video-queue-status-dot.error { background: #ef4444; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .video-queue-actions {
      display: flex;
      gap: 8px;
      padding: 12px;
      border-top: 1px solid var(--border);
    }

    .video-queue-btn {
      flex: 1;
      padding: 10px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .video-queue-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .video-queue-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .video-queue-btn.primary:hover {
      background: var(--accent-hover);
    }

    .video-queue-btn svg {
      width: 14px;
      height: 14px;
    }

    /* ===== SECTIONS ===== */
    .section {
      display: none;
    }

    .section.active {
      display: block;
    }

    /* ===== VIDEO PROMPT POPUP ===== */
    .video-prompt-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(4px);
    }

    .video-prompt-popup {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 440px;
    }

    .video-prompt-popup h3 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .video-prompt-hint {
      color: var(--text-secondary);
      font-size: 14px;
      margin-bottom: 16px;
    }

    .video-prompt-input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      color: var(--text-primary);
      font-size: 14px;
      margin-bottom: 16px;
    }

    .video-prompt-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .video-prompt-input::placeholder {
      color: var(--text-tertiary);
    }

    .video-prompt-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .video-prompt-cancel {
      padding: 10px 20px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .video-prompt-cancel:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .video-prompt-confirm {
      padding: 10px 20px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .video-prompt-confirm:hover {
      background: var(--accent-hover);
    }

    /* ===== CONTEXT PROFILE MODAL ===== */
    .context-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
    }

    .context-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 500px;
    }

    .context-modal h2 {
      margin: 0 0 8px 0;
      font-size: 20px;
    }

    .context-name-input {
      width: 100%;
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: white;
      font-size: 14px;
      margin-bottom: 12px;
    }

    .context-vision-input {
      width: 100%;
      height: 160px;
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: white;
      font-size: 14px;
      resize: vertical;
      font-family: inherit;
    }

    .context-vision-input::placeholder {
      color: var(--text-tertiary);
    }

    .context-modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    .context-cancel-btn {
      padding: 10px 20px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .context-cancel-btn:hover {
      background: var(--bg-tertiary);
    }

    .context-generate-btn {
      padding: 10px 20px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-weight: 500;
    }

    .context-generate-btn:hover {
      background: var(--accent-hover);
    }

    .context-generate-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* ===== WORKFLOW MODALS ===== */
    .workflow-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
    }

    .workflow-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 28px;
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
    }

    .workflow-modal-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
    }

    .workflow-modal h2 {
      margin: 0 0 8px 0;
      font-size: 22px;
    }

    .workflow-desc {
      color: var(--text-secondary);
      font-size: 14px;
      margin-bottom: 20px;
    }

    .workflow-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .workflow-input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .workflow-input-group label {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .workflow-input-group input,
    .workflow-input-group textarea {
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: white;
      font-size: 14px;
    }

    .workflow-input-group textarea {
      min-height: 120px;
      resize: vertical;
      font-family: inherit;
    }

    .workflow-input-group input[type="file"] {
      padding: 10px;
    }

    .workflow-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 8px;
    }

    .workflow-cancel {
      padding: 10px 20px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .workflow-submit {
      padding: 10px 24px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-weight: 500;
    }

    .workflow-submit:hover {
      background: var(--accent-hover);
    }

    .workflow-status {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      color: var(--text-secondary);
    }

    .workflow-results {
      margin-top: 16px;
    }

    .workflow-output-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
    }

    /* ===== BULK I2V TERMINAL MODE ===== */
    .prompt-bar.bulk-mode {
      max-width: 900px;
      border-color: var(--accent);
      box-shadow: 0 0 0 4px var(--accent-glow), 0 0 40px rgba(249, 115, 22, 0.1);
    }

    .bulk-terminal {
      display: none;
      flex-direction: column;
      gap: 0;
      background: #0a0a0f;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 8px;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
      position: relative;
    }

    .bulk-terminal::before {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.03) 2px,
        rgba(0, 0, 0, 0.03) 4px
      );
      pointer-events: none;
      z-index: 1;
    }

    .prompt-bar.bulk-mode .bulk-terminal {
      display: flex;
    }

    .prompt-bar.bulk-mode .prompt-input-row,
    .prompt-bar.bulk-mode .prompt-options {
      display: none;
    }

    .bulk-terminal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: #111116;
      border-bottom: 1px solid #1a1a22;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .bulk-terminal-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      color: #22c55e;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .bulk-terminal-title::before {
      content: '';
      color: #22c55e;
      animation: blink-dot 1.5s infinite;
    }

    @keyframes blink-dot {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    .bulk-terminal-close {
      background: none;
      border: none;
      color: var(--text-tertiary);
      font-size: 18px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.15s;
    }

    .bulk-terminal-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #ef4444;
    }

    .bulk-terminal-body {
      max-height: 320px;
      overflow-y: auto;
      padding: 8px 0;
    }

    .bulk-terminal-body::-webkit-scrollbar {
      width: 6px;
    }

    .bulk-terminal-body::-webkit-scrollbar-track {
      background: transparent;
    }

    .bulk-terminal-body::-webkit-scrollbar-thumb {
      background: #2a2a35;
      border-radius: 3px;
    }

    .bulk-line {
      display: grid;
      grid-template-columns: 48px 1fr auto;
      gap: 12px;
      align-items: center;
      padding: 8px 14px;
      border-bottom: 1px solid #15151c;
      transition: background 0.15s;
      position: relative;
      z-index: 2;
    }

    .bulk-line:last-child {
      border-bottom: none;
    }

    .bulk-line:hover {
      background: rgba(255, 255, 255, 0.02);
    }

    .bulk-line-thumb {
      width: 48px;
      height: 48px;
      border-radius: 6px;
      overflow: hidden;
      background: #1a1a22;
      flex-shrink: 0;
    }

    .bulk-line-thumb img,
    .bulk-line-thumb video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .bulk-line-content {
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .bulk-line-filename {
      font-size: 11px;
      color: #6b6b7a;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .bulk-line-filename span {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .bulk-line-arrow {
      color: #f97316;
      flex-shrink: 0;
    }

    .bulk-line-prompt {
      font-size: 13px;
      line-height: 1.4;
      color: #22c55e;
      min-height: 18px;
      position: relative;
      word-break: break-word;
    }

    .bulk-line-prompt.typing::after {
      content: '';
      color: var(--accent);
      animation: cursor-blink 0.8s infinite;
      margin-left: 2px;
    }

    .bulk-line-prompt.analyzing {
      color: #eab308;
    }

    .bulk-line-prompt.error {
      color: #ef4444;
    }

    @keyframes cursor-blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .bulk-line-status {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .bulk-line-badge {
      font-size: 10px;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .bulk-line-badge.analyzing {
      background: rgba(234, 179, 8, 0.15);
      color: #eab308;
    }

    .bulk-line-badge.ready {
      background: rgba(34, 197, 94, 0.15);
      color: #22c55e;
    }

    .bulk-line-badge.generating {
      background: rgba(249, 115, 22, 0.15);
      color: #f97316;
      animation: pulse-badge 1.5s infinite;
    }

    .bulk-line-badge.done {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .bulk-line-badge.error {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
    }

    @keyframes pulse-badge {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .bulk-line-action {
      background: none;
      border: 1px solid #2a2a35;
      color: var(--text-secondary);
      width: 28px;
      height: 28px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .bulk-line-action:hover {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .bulk-line-action.play {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .bulk-line-action svg {
      width: 14px;
      height: 14px;
    }

    .bulk-terminal-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      background: #111116;
      border-top: 1px solid #1a1a22;
      gap: 12px;
    }

    .bulk-footer-stats {
      font-size: 11px;
      color: var(--text-tertiary);
      display: flex;
      gap: 16px;
    }

    .bulk-footer-stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .bulk-footer-stat .count {
      color: var(--text-primary);
      font-weight: 600;
    }

    .bulk-footer-actions {
      display: flex;
      gap: 8px;
    }

    .bulk-footer-btn {
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
    }

    .bulk-footer-btn.secondary {
      background: #1a1a22;
      border: 1px solid #2a2a35;
      color: var(--text-secondary);
    }

    .bulk-footer-btn.secondary:hover {
      background: #22222c;
      color: var(--text-primary);
    }

    .bulk-footer-btn.primary {
      background: var(--accent);
      border: none;
      color: white;
    }

    .bulk-footer-btn.primary:hover {
      background: var(--accent-hover);
    }

    .bulk-footer-btn.primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .bulk-footer-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Progress bar for overall generation */
    .bulk-progress {
      height: 3px;
      background: #1a1a22;
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
    }

    .bulk-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #22c55e);
      width: 0%;
      transition: width 0.3s ease;
    }

    /* Video modal for preview */
    .bulk-video-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(8px);
    }

    .bulk-video-modal video {
      max-width: 90vw;
      max-height: 80vh;
      border-radius: 12px;
    }

    .bulk-video-modal-close {
      position: absolute;
      top: 20px;
      right: 20px;
      background: var(--bg-tertiary);
      border: none;
      color: white;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
    }

    .bulk-video-modal-download {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--accent);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }
  </style>
</head>
<body>

  <!-- Navigation -->
  <nav class="nav">
    <div class="nav-logo">
      <img src="/aditor-logo.png" alt="Aditor" class="nav-logo-img">
      <span>Aditor Studio</span>
    </div>
    
    <div class="nav-tabs">
      <button class="nav-tab active" data-tab="images">Images</button>
      <button class="nav-tab" data-tab="videos">Videos</button>
      <button class="nav-tab" data-tab="shortcuts">Shortcuts</button>
    </div>
    
    <div class="nav-profile"></div>
  </nav>

  <!-- Main Content -->
  <main class="main">
    
    <!-- Images Section -->
    <section id="images-section" class="section active">
      <div class="grid-container">
        <div class="grid-header">
          <span class="grid-title">Your Images</span>
          <span class="grid-count" id="image-count">0 images</span>
        </div>
        
        <div class="masonry-grid" id="image-grid">
          <!-- Images will be loaded here -->
        </div>

        <div class="empty-state" id="empty-state">
          <div class="empty-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
            </svg>
          </div>
          <h3 class="empty-title">No images yet</h3>
          <p class="empty-desc">Start creating! Describe what you want in the prompt bar below, or drag reference images to guide the generation.</p>
          <button onclick="if (!window.__cfRLUnblockHandlers) return false; recoverFromServer()" style="margin-top: 16px; padding: 10px 20px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-secondary); cursor: pointer;" data-cf-modified-0aa74984300c6238b39e36b1-="">Recover images from server</button>
        </div>
      </div>
    </section>

    <!-- Videos Section -->
    <section id="videos-section" class="section">
      <div class="grid-container">
        <div class="grid-header">
          <span class="grid-title">Video Queue</span>
          <span class="grid-count" id="video-count">0 videos</span>
        </div>
        
        <div id="video-queue-container">
          <!-- Video queue items will be rendered here -->
        </div>

        <div class="empty-state" id="video-empty-state">
          <div class="empty-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
            </svg>
          </div>
          <h3 class="empty-title">No videos queued</h3>
          <p class="empty-desc">Click the  on any image to add it to the video queue. We'll auto-generate a motion prompt and start rendering with Kling 3.</p>
        </div>
      </div>
    </section>

    <!-- Workflow Studio (Shortcuts Section) -->
    <section id="shortcuts-section" class="section">
      <div class="workflow-studio">
        <!-- Left Sidebar - Workflow List -->
        <div class="workflow-sidebar">
          <div class="workflow-sidebar-title">Workflows</div>
          
          <div class="workflow-item active" data-workflow="script-to-video">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Script  UGC Video</div>
              <div class="workflow-item-desc">Script + avatar  full video</div>
            </div>
          </div>

          <div class="workflow-divider">Coming Soon</div>

          <div class="workflow-item coming-soon" data-workflow="kickstarter">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Kickstarter</div>
              <div class="workflow-item-desc">URL  B-roll images</div>
            </div>
          </div>

          <div class="workflow-item coming-soon" data-workflow="image-ads">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Image Ads</div>
              <div class="workflow-item-desc">Product + inspo  ads</div>
            </div>
          </div>

          <div class="workflow-item coming-soon" data-workflow="screenshot-broll">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Screenshot  B-roll</div>
              <div class="workflow-item-desc">Recreate creator frames</div>
            </div>
          </div>

          <div class="workflow-item coming-soon" data-workflow="motion-transfer">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Motion Transfer</div>
              <div class="workflow-item-desc">Image + video  animate</div>
            </div>
          </div>
        </div>

        <!-- Center - Active Workflow Input -->
        <div class="workflow-main" id="workflow-main">
          <div class="workflow-header">
            <h2 id="workflow-title">Script  UGC Video</h2>
            <p id="workflow-description">Upload avatar, paste script, select voice  get UGC video</p>
          </div>

          <!-- UGC Video Layout (default for script-to-video) -->
          <div class="ugc-video-layout" id="ugc-video-layout">
            <div class="ugc-avatar-section">
              <div class="ugc-avatar-upload" id="ugc-avatar-upload">
                <div class="avatar-placeholder">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                  </svg>
                  <span>Drop avatar image</span>
                </div>
                <input type="file" id="ugc-avatar-input" accept="image/*" hidden>
              </div>
            </div>
            
            <div class="ugc-script-section">
              <textarea class="ugc-script-textarea" id="ugc-script" placeholder="Paste your script here..."></textarea>
              
              <div class="ugc-voice-row">
                <label>Voice</label>
                <div class="ugc-voice-search-container">
                  <input type="text" class="ugc-voice-search" id="ugc-voice-search" placeholder="Search voices..." autocomplete="off">
                  <input type="hidden" id="ugc-voice" value="">
                  <div class="ugc-voice-dropdown" id="ugc-voice-dropdown"></div>
                </div>
                <button type="button" class="ugc-generate-btn" id="ugc-generate-btn">Generate</button>
              </div>
            </div>
          </div>

          <!-- Motion Transfer Layout (webcam + character) -->
          <div class="motion-transfer-layout" id="motion-transfer-layout" style="display: none;">
            <div class="webcam-section">
              <div class="webcam-container" id="webcam-container">
                <video class="webcam-video" id="webcam-video" autoplay muted playsinline style="display: none;"></video>
                <video class="webcam-preview" id="webcam-playback" controls style="display: none;"></video>
                <div class="webcam-placeholder" id="webcam-placeholder">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                  </svg>
                  <span>Click Start to enable webcam</span>
                </div>
                <div class="webcam-timer" id="webcam-timer"> REC 0:00</div>
              </div>
              <div class="webcam-controls">
                <button type="button" class="webcam-btn webcam-btn-start" id="webcam-start-btn">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="18" height="18">
                    <circle cx="12" cy="12" r="10" stroke-width="2"/>
                    <circle cx="12" cy="12" r="4" fill="currentColor"/>
                  </svg>
                  Start Recording
                </button>
                <button type="button" class="webcam-btn webcam-btn-stop" id="webcam-stop-btn" style="display: none;">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="18" height="18">
                    <rect x="6" y="6" width="12" height="12" fill="currentColor"/>
                  </svg>
                  Stop
                </button>
                <button type="button" class="webcam-btn webcam-btn-retry" id="webcam-retry-btn" style="display: none;">
                   Re-record
                </button>
              </div>
            </div>
            
            <div class="character-section">
              <div class="character-upload" id="character-upload">
                <div class="character-placeholder">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                  </svg>
                  <span>Drop character image</span>
                </div>
                <input type="file" id="character-input" accept="image/*" hidden>
              </div>
              <div class="motion-generate-row">
                <button type="button" class="motion-generate-btn" id="motion-generate-btn">Generate Motion Transfer</button>
              </div>
            </div>
          </div>

          <!-- Generic workflow upload zone (for other workflows) -->
          <div class="workflow-upload-zone" id="workflow-upload-zone" style="display: none;">
            <div class="workflow-upload-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
              </svg>
            </div>
            <div class="workflow-upload-text">Drop files here or click to upload</div>
            <div class="workflow-upload-hint" id="workflow-upload-hint">Accepts images and videos</div>
            <input type="file" id="workflow-file-input" multiple hidden>
            <div class="workflow-upload-preview" id="workflow-upload-preview"></div>
          </div>

          <!-- Generic workflow form (for other workflows) -->
          <form class="workflow-form" id="workflow-form" style="display: none;">
            <div class="workflow-field" id="url-field" style="display: none;">
              <label for="workflow-url">Product URL</label>
              <input type="url" id="workflow-url" placeholder="https://example.com/product">
            </div>

            <div class="workflow-field" id="script-field" style="display: none;">
              <label for="workflow-script">Script</label>
              <textarea id="workflow-script" placeholder="Paste your script here..."></textarea>
            </div>

            <button type="submit" class="workflow-submit-btn" id="workflow-submit">Generate</button>
          </form>
        </div>

        <!-- Right - Results Panel -->
        <div class="workflow-results">
          <div class="workflow-results-title">
            Results
            <span class="workflow-results-count" id="workflow-results-count">0</span>
          </div>
          
          <div class="workflow-results-empty" id="workflow-results-empty">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
            </svg>
            <div>Results will appear here</div>
          </div>

          <div class="workflow-results-grid" id="workflow-results-grid"></div>
        </div>
      </div>
    </section>

  </main>

  <!-- Prompt Bar -->
  <div class="prompt-container">
    <div class="prompt-bar" id="prompt-bar">
      <!-- Bulk I2V Terminal (hidden by default) -->
      <div class="bulk-terminal" id="bulk-terminal">
        <div class="bulk-terminal-header">
          <div class="bulk-terminal-title">
            <span>BULK I2V</span>
          </div>
          <button class="bulk-terminal-close" id="bulk-close" title="Exit bulk mode"></button>
        </div>
        <div class="bulk-terminal-body" id="bulk-terminal-body">
          <!-- Lines will be rendered here -->
        </div>
        <div class="bulk-terminal-footer">
          <div class="bulk-footer-stats" id="bulk-stats">
            <div class="bulk-footer-stat"><span class="count" id="bulk-count-total">0</span> images</div>
            <div class="bulk-footer-stat"><span class="count" id="bulk-count-ready">0</span> ready</div>
            <div class="bulk-footer-stat"><span class="count" id="bulk-count-done">0</span> done</div>
          </div>
          <div class="bulk-footer-actions">
            <select class="prompt-select" id="bulk-duration" style="font-size: 11px; padding: 6px 10px;">
              <option value="5">5s</option>
              <option value="10">10s</option>
            </select>
            <button class="bulk-footer-btn secondary" id="bulk-analyze-btn">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg>
              Analyze
            </button>
            <button class="bulk-footer-btn primary" id="bulk-generate-btn" disabled>
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
              Generate All
            </button>
          </div>
        </div>
        <div class="bulk-progress">
          <div class="bulk-progress-bar" id="bulk-progress-bar"></div>
        </div>
      </div>

      <div class="prompt-references" id="prompt-references">
        <!-- Reference images appear here -->
      </div>
      
      <div class="prompt-input-row">
        <input type="text" class="prompt-input" id="prompt-input" placeholder="Describe your image... or drop images here for bulk video">
        <button class="prompt-btn" id="generate-btn">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3l14 9-14 9V3z"/>
          </svg>
        </button>
      </div>
      
      <div class="prompt-options">
        <button class="prompt-option active" id="gen-mode-btn" title="Click to switch mode"> B-roll</button>
        <select class="prompt-select" id="aspect-ratio">
          <option value="9:16" selected>9:16 vertical</option>
          <option value="1:1">1:1 square</option>
          <option value="16:9">16:9 horizontal</option>
          <option value="4:5">4:5 portrait</option>
        </select>
        <select class="prompt-select" id="model-select">
          <option value="nano-banana-pro" selected>Nano Banana Pro</option>
          <option value="seedream">Seedream 4</option>
          <option value="z-image">Z Image</option>
        </select>
        <select class="prompt-select" id="gen-count" title="Number of images to generate">
          <option value="1">1</option>
          <option value="2" selected>2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="6">6</option>
          <option value="8">8</option>
        </select>
        <span style="color: var(--text-tertiary); font-size: 12px; margin-left: 8px;"></span>
        <select class="prompt-select" id="video-model-select" title="Default video model for starred images">
          <option value="kling3" selected>Kling 3</option>
          <option value="seedance2">Seedance 2</option>
        </select>
      </div>
    </div>
  </div>

  <!-- Hidden file input for bulk upload -->
  <input type="file" id="bulk-file-input" multiple accept="image/*" style="display:none">

  <!-- Fullscreen Modal -->
  <div class="modal-overlay" id="modal">
    <div class="modal-content">
      <button class="modal-close" id="modal-close"></button>
      <img class="modal-image" id="modal-image" src="">
      <div class="modal-actions">
        <button class="modal-btn" id="modal-variations">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM14 5a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1V5zM4 15a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1v-4zM14 15a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/>
          </svg>
          4 Variations
        </button>
        <button class="modal-btn" id="modal-reference">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"/>
          </svg>
          Reference
        </button>
        <button class="modal-btn" id="modal-reuse">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
          </svg>
          Reuse Prompt
        </button>
        <button class="modal-btn" id="modal-video">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
          </svg>
           Video
        </button>
        <button class="modal-btn primary" id="modal-download">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
          </svg>
          Download
        </button>
      </div>
      <div class="modal-meta" id="modal-meta">
        <!-- Prompt and settings will appear here -->
      </div>
    </div>
  </div>

  <!-- Generating indicator -->
  <div class="generating" id="generating">
    <div class="generating-spinner"></div>
    <span class="generating-text">Generating...</span>
  </div>

  <script type="0aa74984300c6238b39e36b1-text/javascript">
    // ===== STATE =====
    let images = [];
    let references = [];
    let currentImage = null;
    let selectedRatio = '9:16';
    let selectedModel = 'nano-banana-pro';
    let genMode = 'broll'; // 'broll' | 'talking' | 'raw'
    let videoQueue = []; // {id, image, prompt, status: 'pending'|'generating'|'complete'|'error', videoUrl}

    // ===== PERSISTENCE =====
    const STORAGE_KEY = 'aditor_studio_images';
    
    function loadSavedImages() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          images = JSON.parse(saved);
          // Clean up any stuck loading placeholders from previous sessions
          const beforeCount = images.length;
          images = images.filter(img => !img.loading);
          if (images.length < beforeCount) {
            console.log(`Cleaned ${beforeCount - images.length} stuck loading items`);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(images));
          }
          console.log(`Loaded ${images.length} images from storage`);
        }
      } catch (e) {
        console.error('Failed to load images:', e);
      }
      
      // If no images in localStorage, try to load from server
      if (images.length === 0) {
        loadRecentFromServer();
      }
    }
    
    async function loadRecentFromServer() {
      try {
        const response = await fetch('/api/outputs/recent');
        if (response.ok) {
          const data = await response.json();
          if (data.images && data.images.length > 0) {
            images = data.images;
            saveImages();
            renderGrid();
            console.log(`Loaded ${images.length} recent images from server`);
          }
        }
      } catch (e) {
        console.log('No recent images from server');
      }
    }
    
    function saveImages() {
      try {
        // Keep last 100 images max
        const toSave = images.slice(0, 100);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
      } catch (e) {
        console.error('Failed to save images:', e);
      }
    }

    // Recovery function - loads all images from server
    window.recoverFromServer = async function() {
      try {
        const response = await fetch('/api/outputs/recent?limit=100');
        if (response.ok) {
          const data = await response.json();
          if (data.images && data.images.length > 0) {
            images = data.images;
            saveImages();
            renderGrid();
            console.log(` Recovered ${images.length} images from server`);
            alert(`Recovered ${images.length} images!`);
          } else {
            alert('No images found on server');
          }
        }
      } catch (e) {
        console.error('Recovery failed:', e);
        alert('Failed to recover images: ' + e.message);
      }
    };
    
    // Load on startup
    loadSavedImages();

    // ===== DOM =====
    const imageGrid = document.getElementById('image-grid');
    const imageCount = document.getElementById('image-count');
    const emptyState = document.getElementById('empty-state');
    const promptBar = document.getElementById('prompt-bar');
    const promptInput = document.getElementById('prompt-input');
    const promptReferences = document.getElementById('prompt-references');
    const generateBtn = document.getElementById('generate-btn');
    const modal = document.getElementById('modal');
    const modalImage = document.getElementById('modal-image');
    const generating = document.getElementById('generating');

    // ===== TAB SWITCHING =====
    document.querySelectorAll('.nav-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tab.dataset.tab}-section`).classList.add('active');
        
        // Handle prompt bar visibility based on tab and workflow
        const promptBar = document.querySelector('.prompt-container');
        if (promptBar) {
          if (tab.dataset.tab === 'bulk-i2v') {
            promptBar.style.display = 'none';
          } else if (tab.dataset.tab === 'shortcuts') {
            const config = workflowConfigs[currentWorkflow];
            promptBar.style.display = config?.customLayout ? 'none' : 'block';
          } else {
            promptBar.style.display = 'block';
          }
        }
        
        // Render bulk i2v jobs when switching to Videos tab
        if (tab.dataset.tab === 'videos' && typeof renderBulkJobsInVideoTab === 'function') {
          setTimeout(renderBulkJobsInVideoTab, 100);
        }
      });
    });

    // ===== PROMPT OPTIONS =====
    const aspectRatioSelect = document.getElementById('aspect-ratio');
    const modelSelect = document.getElementById('model-select');
    
    aspectRatioSelect.addEventListener('change', (e) => {
      selectedRatio = e.target.value;
    });
    
    modelSelect.addEventListener('change', (e) => {
      selectedModel = e.target.value;
    });

    // Generation mode toggle (click to cycle)
    const genModeBtn = document.getElementById('gen-mode-btn');
    const genModes = ['broll', 'talking', 'raw'];
    const genModeLabels = {
      'broll': ' B-roll',
      'talking': ' Talking Head', 
      'raw': ' Raw'
    };
    
    genModeBtn.addEventListener('click', () => {
      const currentIndex = genModes.indexOf(genMode);
      const nextIndex = (currentIndex + 1) % genModes.length;
      genMode = genModes[nextIndex];
      genModeBtn.textContent = genModeLabels[genMode];
      genModeBtn.classList.toggle('active', genMode !== 'raw');
    });

    // Default video model for starred images
    const videoModelSelect = document.getElementById('video-model-select');
    let defaultVideoModel = 'kling3';
    videoModelSelect.addEventListener('change', (e) => {
      defaultVideoModel = e.target.value;
    });

    // ===== UGC PROMPT ENHANCER =====
    // Automatically makes prompts more realistic/authentic for UGC-style content
    
    const UGC_ENHANCEMENTS = {
      // Add these for realism
      add: [
        'shot on iPhone',
        'natural lighting',
        'candid moment',
        'authentic',
        'unposed',
        'real environment',
        'slight motion blur',
        'natural skin texture',
        'casual setting'
      ],
      // Avoid these (make it look AI-generated)
      avoid: [
        'hyper realistic', 'ultra realistic', '8k', 'octane render', 
        'unreal engine', 'studio lighting', 'perfect', 'flawless',
        'symmetrical', 'centered composition', 'professional photo',
        'stock photo', 'advertising', 'commercial'
      ],
      // Replace these terms
      replace: {
        'beautiful': 'natural-looking',
        'perfect skin': 'real skin texture',
        'studio': 'home',
        'professional': 'casual',
        'model': 'person',
        'posing': 'candid'
      },
      // Negative prompt additions (if model supports)
      negative: [
        'artificial', 'plastic skin', 'airbrushed', 'oversaturated',
        'HDR', 'oversharpened', 'stock photo', 'advertisement',
        'symmetrical face', 'perfect teeth', 'glamour lighting'
      ]
    };

    // ===== B-ROLL MODE EXPANSION =====
    // Camera roll realism - like actual photos from someone's phone
    function expandBrollPrompt(prompt) {
      if (!prompt) return prompt;
      
      // Candid photo moments (NO screenshot/UI references)
      const cameraRollVibes = [
        'accidental burst photo, slightly between poses',
        'candid moment caught naturally',
        'photo taken mid-laugh, candid moment',
        'blurry background person walking through',
        'taken while walking, slight motion',
        'quick snap, casual timing',
        'spontaneous photo, unplanned moment',
        'casual photo shared between friends'
      ];
      
      // Lo-fi imperfections
      const lofiElements = [
        'slight grain, not sharp, compressed jpeg quality',
        'soft focus, not everything crisp',
        'small lens flare from window',
        'slight overexposure from bright window',
        'shadow falling across part of frame',
        'warm color cast from indoor lighting',
        'slightly tilted horizon, not perfectly level',
        'harsh flash illuminating foreground only'
      ];
      
      // Framing mistakes real people make
      const framingQuirks = [
        'subject slightly off-center, too much headroom',
        'something random cut off at edge of frame',
        'thumb slightly visible in corner',
        'awkward crop, didnt frame it properly',
        'too close, face fills frame',
        'too far, lots of empty space around subject',
        'reflection visible in glass or mirror behind'
      ];
      
      // Real messy environments (NO branded packaging)
      const realMess = [
        'water bottle and charger on nightstand',
        'pile of clothes on chair in background',
        'shoes kicked off by door visible',
        'cardboard box in corner of room',
        'half-eaten snack on desk',
        'tangled earbuds somewhere in frame',
        'random hand cream or chapstick visible',
        'phone charger cable dangling'
      ];
      
      // Time of day feeling
      const timeVibes = [
        'lazy sunday morning light',
        'late night scrolling lighting, just lamp on',
        'harsh midday light through window',
        'getting ready to go out lighting',
        'just got home energy',
        'waiting for food to arrive vibes'
      ];
      
      const vibe = cameraRollVibes[Math.floor(Math.random() * cameraRollVibes.length)];
      const lofi = lofiElements[Math.floor(Math.random() * lofiElements.length)];
      const framing = framingQuirks[Math.floor(Math.random() * framingQuirks.length)];
      const mess = realMess[Math.floor(Math.random() * realMess.length)];
      const time = timeVibes[Math.floor(Math.random() * timeVibes.length)];
      
      return `${vibe} of ${prompt}, ${lofi}, ${framing}, ${mess}, ${time}, shot on iphone, vertical 9:16 portrait, raw photo file, not aesthetic not curated, casual authentic photograph, candid snapshot, fullscreen image with no UI no timestamps no dates no text overlays`;
    }
    
    // ===== TALKING HEAD MODE EXPANSION =====
    // For creating stills that will be animated to talk
    function expandTalkingHeadPrompt(prompt) {
      if (!prompt) return prompt;
      
      // Camera setups (NO phone visible ever)
      const cameraSetups = [
        'selfie camera at natural arms length, slightly below eye level',
        'phone propped on window ledge, soft natural light',
        'tripod setup at desk height, eye-level framing',
        'camera resting against books on shelf, casual angle',
        'ring light setup visible in catch lights, phone mounted'
      ];
      
      // Mid-sentence expressions (for lip sync)
      const expressions = [
        'mouth slightly open mid-word, engaged expression',
        'about to say something, slight eyebrow raise',
        'paused mid-thought, relaxed face',
        'casual talking expression, not too animated',
        'natural speaking moment, eyes engaged with camera'
      ];
      
      // Backgrounds (sharp focus, not blurred)
      const backgrounds = [
        'living room bookshelf and couch in sharp focus behind',
        'bedroom with bed and nightstand visible, everything in focus',
        'home office with monitor and plants visible',
        'kitchen with cabinets and fridge magnets in background',
        'plain wall with one piece of art, simple background'
      ];
      
      // Lighting (flat, not cinematic)
      const lighting = [
        'flat even indoor lighting, soft and natural',
        'soft daylight from window, no harsh shadows',
        'ring light creating even illumination',
        'overhead room light plus window, balanced',
        'natural afternoon light, not golden hour'
      ];
      
      // Clothing (not generic)
      const clothingNotes = [
        'wearing lived-in comfortable clothes',
        'casual hoodie or sweater',
        'simple t-shirt, slightly wrinkled naturally',
        'cozy cardigan or flannel'
      ];
      
      const setup = cameraSetups[Math.floor(Math.random() * cameraSetups.length)];
      const expression = expressions[Math.floor(Math.random() * expressions.length)];
      const bg = backgrounds[Math.floor(Math.random() * backgrounds.length)];
      const light = lighting[Math.floor(Math.random() * lighting.length)];
      const clothes = clothingNotes[Math.floor(Math.random() * clothingNotes.length)];
      
      return `Vertical 9:16 iPhone video frame of ${prompt}, ${expression}, ${setup}, ${light}, ${bg}, ${clothes}, NO phone visible in frame, no text no UI no overlays no REC indicator no timestamps no dates, casual home video feel, authentic not performative, relaxed genuine expression`;
    }

    function enhancePromptForUGC(prompt) {
      if (!prompt) return prompt;
      
      let enhanced = prompt.toLowerCase();
      
      // Remove terms that make images look AI-generated
      UGC_ENHANCEMENTS.avoid.forEach(term => {
        enhanced = enhanced.replace(new RegExp(term, 'gi'), '');
      });
      
      // Replace problematic terms
      Object.entries(UGC_ENHANCEMENTS.replace).forEach(([from, to]) => {
        enhanced = enhanced.replace(new RegExp(from, 'gi'), to);
      });
      
      // Clean up extra spaces
      enhanced = enhanced.replace(/\s+/g, ' ').trim();
      
      // Add UGC modifiers (pick 3-4 relevant ones)
      const addons = [];
      
      // Always add these core ones
      addons.push('shot on iPhone 15 Pro');
      addons.push('natural lighting');
      
      // Add context-specific ones
      if (enhanced.includes('person') || enhanced.includes('woman') || enhanced.includes('man') || enhanced.includes('creator')) {
        addons.push('candid moment');
        addons.push('authentic expression');
        addons.push('natural skin texture with pores');
      }
      
      if (enhanced.includes('product') || enhanced.includes('holding')) {
        addons.push('casual home environment');
        addons.push('slightly messy background');
      }
      
      // Combine
      const finalPrompt = `${enhanced}, ${addons.join(', ')}`;
      
      return finalPrompt;
    }

    function getUGCNegativePrompt() {
      return UGC_ENHANCEMENTS.negative.join(', ');
    }

    // ===== LLM PROMPT EXPANSION =====
    // Converts simple prompts to detailed JSON for Nano Banana Pro
    
    const PROMPT_EXPANSION_TEMPLATE = `You are a prompt engineer for Nano Banana Pro image generation. Convert the user's simple request into a detailed JSON prompt optimized for ultra-realistic UGC (user-generated content) style images.

The output must be authentic-looking content suitable for social media ads - NOT polished studio shots.

USER REQUEST: {{INPUT}}

Output a JSON object with these exact keys:
{
  "label": "short-kebab-case-name",
  "tags": ["3-5 style tags"],
  "Style": ["documentary-candid-style", "social-media-native"],
  "Subject": ["detailed subject description", "physical traits if person", "expression"],
  "MadeOutOf": ["materials", "textures", "fabric types"],
  "Arrangement": "pose and placement description",
  "Background": "realistic home/casual environment",
  "ColorRestriction": ["natural tones only", "no oversaturation"],
  "Lighting": "describe natural/phone lighting",
  "Camera": {
    "type": "iPhone 15 Pro or similar phone",
    "lens": "24-35mm equivalent",
    "aperture": "f/1.8",
    "style": "selfie or handheld"
  },
  "OutputStyle": "authentic social media photo",
  "Mood": "casual, relatable, real"
}

CRITICAL RULES FOR UGC REALISM:
- ALWAYS use phone camera specs (iPhone 15 Pro, Pixel 8)
- NEVER use studio lighting terms
- ALWAYS include "natural skin texture with pores" for people
- ALWAYS use messy/real backgrounds (bathroom counter, bedroom, kitchen)
- Include slight imperfections (motion blur ok, not perfectly centered)
- Expression should be natural, not posed/model-like

Return ONLY the JSON, no explanation.`;

    async function expandPromptWithLLM(simplePrompt) {
      try {
        // Get selected context profile
        const contextSelect = document.getElementById('context-profile');
        const contextId = contextSelect?.value || null;
        
        const response = await fetch('/api/prompt/expand', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: simplePrompt,
            mode: 'ugc',
            contextId: contextId
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('LLM expanded JSON:', data.json);
          if (contextId) console.log('Using context profile:', contextId);
          return data.json;
        }
      } catch (err) {
        console.error('LLM expansion failed:', err);
      }
      
      // Fallback: return null (will use simple enhancement)
      return null;
    }

    function jsonPromptToString(jsonPrompt) {
      // Convert JSON prompt to string format for Nano Banana Pro
      if (!jsonPrompt) return null;
      
      const parts = [];
      
      if (jsonPrompt.Style) parts.push(`Style: ${jsonPrompt.Style.join(', ')}`);
      if (jsonPrompt.Subject) parts.push(`Subject: ${jsonPrompt.Subject.join(', ')}`);
      if (jsonPrompt.MadeOutOf) parts.push(`Materials: ${jsonPrompt.MadeOutOf.join(', ')}`);
      if (jsonPrompt.Arrangement) parts.push(`Pose: ${jsonPrompt.Arrangement}`);
      if (jsonPrompt.Background) parts.push(`Background: ${jsonPrompt.Background}`);
      if (jsonPrompt.Lighting) parts.push(`Lighting: ${jsonPrompt.Lighting}`);
      if (jsonPrompt.Camera) {
        parts.push(`Camera: ${jsonPrompt.Camera.type}, ${jsonPrompt.Camera.lens}, ${jsonPrompt.Camera.aperture}, ${jsonPrompt.Camera.style}`);
      }
      if (jsonPrompt.OutputStyle) parts.push(`Output: ${jsonPrompt.OutputStyle}`);
      if (jsonPrompt.Mood) parts.push(`Mood: ${jsonPrompt.Mood}`);
      if (jsonPrompt.ColorRestriction) parts.push(`Colors: ${jsonPrompt.ColorRestriction.join(', ')}`);
      
      return parts.join('. ');
    }

    // ===== DRAG & DROP =====
    
    // Grid items are draggable - direct attachment
    function makeGridItemDraggable(item, imgSrc) {
      item.setAttribute('draggable', 'true');
      item.dataset.src = imgSrc;
      
      item.ondragstart = function(e) {
        e.dataTransfer.setData('text/plain', imgSrc);
        e.dataTransfer.effectAllowed = 'copy';
        item.classList.add('dragging');
        console.log('[Drag] Started:', imgSrc);
      };
      
      item.ondragend = function() {
        item.classList.remove('dragging');
      };
    }

    // Prompt bar accepts drops
    promptBar.addEventListener('dragover', (e) => {
      e.preventDefault();
      promptBar.classList.add('drag-over');
    });

    promptBar.addEventListener('dragleave', () => {
      promptBar.classList.remove('drag-over');
    });

    promptBar.addEventListener('drop', (e) => {
      e.preventDefault();
      promptBar.classList.remove('drag-over');
      
      // Handle image from grid (http URLs or local /outputs/ paths)
      const imgSrc = e.dataTransfer.getData('text/plain');
      console.log('[Drop] Received:', imgSrc);
      
      if (imgSrc && imgSrc.length > 0) {
        addReference(imgSrc);
        return;
      }
      
      // Handle file drop
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        Array.from(files).forEach(file => {
          if (file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (e) => addReference(e.target.result);
            reader.readAsDataURL(file);
          }
        });
      }
    });

    // ===== REFERENCES =====
    function addReference(src) {
      if (references.length >= 4) return; // Max 4 references
      references.push(src);
      renderReferences();
    }

    function removeReference(index) {
      references.splice(index, 1);
      renderReferences();
    }

    function renderReferences() {
      promptReferences.innerHTML = references.map((src, i) => `
        <div class="prompt-ref">
          <img src="${src}" alt="Reference ${i + 1}">
          <button class="prompt-ref-remove" onclick="removeReference(${i})"></button>
        </div>
      `).join('');
    }

    // ===== IMAGE GRID =====
    function renderGrid() {
      if (images.length === 0) {
        imageGrid.innerHTML = '';
        emptyState.style.display = 'block';
        imageCount.textContent = '0 images';
        return;
      }

      emptyState.style.display = 'none';
      imageCount.textContent = `${images.length} image${images.length === 1 ? '' : 's'}`;
      
      imageGrid.innerHTML = images.map((img, i) => {
        // Loading placeholder
        if (img.loading) {
          return `
            <div class="grid-item grid-item-loading" data-index="${i}">
              <div class="grid-item-loading-inner">
                <div class="grid-item-spinner"></div>
                <span class="grid-item-loading-text">${img.prompt ? img.prompt.slice(0, 30) + '...' : 'Generating...'}</span>
                <button class="grid-item-cancel" onclick="event.stopPropagation(); cancelGeneration(${i})" title="Cancel generation"> Cancel</button>
              </div>
            </div>
          `;
        }
        
        const isQueued = videoQueue.some(v => v.image.url === img.url);
        return `
          <div class="grid-item" data-index="${i}">
            <img src="${img.url}" alt="${img.prompt || 'Generated image'}" loading="lazy">
            <span class="grid-item-drag-hint">Drag to reference</span>
            <button class="grid-item-delete" onclick="event.stopPropagation(); deleteImage(${i})" title="Delete image">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
              </svg>
            </button>
            <button class="grid-item-save ${isQueued ? 'saved' : ''}" onclick="event.stopPropagation(); toggleVideoQueue(${i})" title="${isQueued ? 'Remove from video queue' : 'Add to video queue'}">
              <svg fill="${isQueued ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"/>
              </svg>
            </button>
          </div>
        `;
      }).join('');

      // Make items draggable
      document.querySelectorAll('.grid-item').forEach((item, i) => {
        makeGridItemDraggable(item, images[i].url);
        item.addEventListener('click', (e) => {
          if (e.target.tagName !== 'BUTTON' && !e.target.closest('.grid-item-save')) {
            openModal(i);
          }
        });
      });
    }

    // ===== MODAL =====
    const modalMeta = document.getElementById('modal-meta');

    function openModal(index) {
      currentImage = images[index];
      modalImage.src = currentImage.url;
      
      // Show metadata
      if (currentImage.prompt) {
        modalMeta.innerHTML = `
          <div class="modal-meta-prompt">"${currentImage.prompt}"</div>
          <div class="modal-meta-settings">
            <div class="modal-meta-item">
              <span class="modal-meta-label">Ratio:</span>
              <span>${currentImage.ratio || '9:16'}</span>
            </div>
            <div class="modal-meta-item">
              <span class="modal-meta-label">Model:</span>
              <span>${currentImage.model || 'Flux'}</span>
            </div>
          </div>
          <div class="modal-meta-actions">
            <button class="modal-meta-btn" onclick="copyPrompt()">Copy prompt</button>
            <button class="modal-meta-btn" onclick="rerunPrompt()">Re-run</button>
          </div>
        `;
      } else {
        modalMeta.innerHTML = '';
      }
      
      modal.classList.add('active');
    }

    function closeModal() {
      modal.classList.remove('active');
      currentImage = null;
    }

    function copyPrompt() {
      if (currentImage?.prompt) {
        navigator.clipboard.writeText(currentImage.prompt);
      }
    }

    function rerunPrompt() {
      if (currentImage?.prompt) {
        promptInput.value = currentImage.prompt;
        if (currentImage.ratio) {
          aspectRatioSelect.value = currentImage.ratio;
          selectedRatio = currentImage.ratio;
        }
        closeModal();
        promptInput.focus();
      }
    }

    document.getElementById('modal-close').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });

    document.getElementById('modal-reference').addEventListener('click', () => {
      if (currentImage) {
        addReference(currentImage.url);
        closeModal();
      }
    });

    document.getElementById('modal-variations').addEventListener('click', () => {
      if (currentImage) {
        // Generate 4 variations
        generateVariations(currentImage);
        closeModal();
      }
    });

    document.getElementById('modal-download').addEventListener('click', () => {
      if (currentImage) {
        const a = document.createElement('a');
        a.href = currentImage.url;
        a.download = `aditor-${Date.now()}.png`;
        a.click();
      }
    });

    document.getElementById('modal-video').addEventListener('click', () => {
      if (currentImage) {
        addToVideoQueue(images.indexOf(currentImage));
        closeModal();
      }
    });

    document.getElementById('modal-reuse').addEventListener('click', () => {
      if (currentImage && currentImage.prompt) {
        promptInput.value = currentImage.prompt;
        closeModal();
        promptInput.focus();
      }
    });

    async function generateVariations(img) {
      generating.classList.add('active');
      document.querySelector('.generating-text').textContent = 'Generating 4 variations...';
      
      try {
        // TODO: Replace with actual API call
        const response = await fetch('/api/variations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sourceImage: img.url,
            prompt: img.prompt,
            count: 4
          })
        });

        if (response.ok) {
          const data = await response.json();
          data.images.forEach(url => {
            images.unshift({
              url,
              prompt: img.prompt + ' (variation)',
              ratio: img.ratio,
              model: img.model,
              createdAt: new Date().toISOString()
            });
          });
          renderGrid();
        }
      } catch (err) {
        // Demo mode: add placeholder variations
        for (let i = 0; i < 4; i++) {
          images.unshift({
            url: `https://picsum.photos/seed/${Date.now() + i}/400/700`,
            prompt: img.prompt + ' (variation)',
            ratio: img.ratio,
            model: img.model,
            createdAt: new Date().toISOString()
          });
        }
        renderGrid();
      } finally {
        generating.classList.remove('active');
        document.querySelector('.generating-text').textContent = 'Generating...';
      }
    }

    // ===== VIDEO QUEUE =====
    const videoQueueContainer = document.getElementById('video-queue-container');
    const videoEmptyState = document.getElementById('video-empty-state');
    const videoCount = document.getElementById('video-count');

    function deleteImage(index) {
      const img = images[index];
      // Remove from video queue if present
      const queueIndex = videoQueue.findIndex(v => v.image.url === img.url);
      if (queueIndex >= 0) {
        videoQueue.splice(queueIndex, 1);
      }
      // Remove from images array
      images.splice(index, 1);
      saveImages();
      renderGrid();
      renderVideoQueue();
      updateVideoTabBadge();
    }

    function toggleVideoQueue(index) {
      const img = images[index];
      const existingIndex = videoQueue.findIndex(v => v.image.url === img.url);
      
      if (existingIndex >= 0) {
        // Remove from queue
        videoQueue.splice(existingIndex, 1);
        renderGrid();
        renderVideoQueue();
        updateVideoTabBadge();
      } else {
        // Show popup for video prompt
        showVideoPromptPopup(img);
      }
    }
    
    function showVideoPromptPopup(img) {
      // Create popup overlay
      const overlay = document.createElement('div');
      overlay.className = 'video-prompt-overlay';
      overlay.innerHTML = `
        <div class="video-prompt-popup">
          <h3>Add to Video Queue</h3>
          <p class="video-prompt-hint">Optional: describe the motion you want</p>
          <input type="text" class="video-prompt-input" placeholder="e.g., slow zoom in, she looks up and smiles..." autofocus>
          <div class="video-prompt-actions">
            <button class="video-prompt-cancel">Cancel</button>
            <button class="video-prompt-confirm">Add to Queue</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      const input = overlay.querySelector('.video-prompt-input');
      const cancelBtn = overlay.querySelector('.video-prompt-cancel');
      const confirmBtn = overlay.querySelector('.video-prompt-confirm');
      
      function addToQueue() {
        const customPrompt = input.value.trim();
        const videoPrompt = customPrompt || generateVideoPrompt(img.prompt);
        
        const newItem = {
          id: Date.now(),
          image: img,
          prompt: videoPrompt,
          status: 'generating',
          model: defaultVideoModel,
          videoUrl: null
        };
        
        videoQueue.push(newItem);
        
        renderGrid();
        renderVideoQueue();
        updateVideoTabBadge();
        overlay.remove();
        
        // Auto-start video generation
        generateVideo(newItem.id);
      }
      
      function cancel() {
        overlay.remove();
      }
      
      // Event listeners
      confirmBtn.addEventListener('click', addToQueue);
      cancelBtn.addEventListener('click', cancel);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) cancel();
      });
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          addToQueue();
        }
        if (e.key === 'Escape') cancel();
      });
      
      // Focus input
      setTimeout(() => input.focus(), 100);
    }

    function generateVideoPrompt(imagePrompt) {
      // Research-backed video prompt enhancement for Kling/AI video gen
      // Based on: fal.ai Kling 2.6 Pro guide, Leonardo.ai Kling prompts, VEED guide
      
      if (!imagePrompt) {
        return 'Gentle camera movement, natural subtle motion, cinematic lighting, shallow depth of field, high quality UGC style';
      }
      
      // Motion types that work well with different subjects
      const motionPatterns = {
        person: [
          'subtle natural breathing motion, gentle hair movement from soft breeze',
          'slight head turn with natural eye movement, relaxed posture shift',
          'natural micro-movements, subtle facial expression change',
          'gentle body sway, authentic candid movement'
        ],
        product: [
          'slow 15-degree rotation, subtle floating motion',
          'gentle camera orbit around subject, soft highlight shifts',
          'smooth push-in revealing product details',
          'elegant slow-motion presentation'
        ],
        scene: [
          'slow cinematic pan across the scene',
          'gentle parallax movement, atmospheric elements drift naturally',
          'smooth tracking shot through environment',
          'subtle depth reveal with rack focus'
        ]
      };
      
      // Camera movements (Kling-optimized)
      const cameraMovements = [
        'camera slowly tracks right while maintaining focus',
        'gentle push-in toward subject',
        'subtle dolly movement with shallow depth of field',
        'smooth handheld-style micro-movements',
        'slow cinematic pan',
        'gentle floating camera movement'
      ];
      
      // Style additions for UGC/social media
      const ugcStyle = [
        'natural lighting, authentic social media aesthetic',
        'high-quality UGC style, minimal polish, genuine feel',
        'iPhone-captured quality, natural color grading',
        'candid documentary feel, organic movement'
      ];
      
      // Detect subject type from prompt
      const promptLower = imagePrompt.toLowerCase();
      let subjectType = 'scene';
      if (promptLower.includes('person') || promptLower.includes('woman') || promptLower.includes('man') || 
          promptLower.includes('girl') || promptLower.includes('guy') || promptLower.includes('influencer') ||
          promptLower.includes('holding') || promptLower.includes('sitting') || promptLower.includes('standing')) {
        subjectType = 'person';
      } else if (promptLower.includes('product') || promptLower.includes('bottle') || promptLower.includes('box') ||
                 promptLower.includes('phone') || promptLower.includes('device') || promptLower.includes('package')) {
        subjectType = 'product';
      }
      
      // Build enhanced prompt
      const motion = motionPatterns[subjectType][Math.floor(Math.random() * motionPatterns[subjectType].length)];
      const camera = cameraMovements[Math.floor(Math.random() * cameraMovements.length)];
      const style = ugcStyle[Math.floor(Math.random() * ugcStyle.length)];
      
      return `${motion}, ${camera}, ${style}`;
    }

    function updateVideoTabBadge() {
      const tab = document.querySelector('.nav-tab[data-tab="videos"]');
      const pendingCount = videoQueue.filter(v => v.status === 'pending').length;
      const bulkGenerating = typeof bulkItems !== 'undefined' ? bulkItems.filter(it => it.status === 'generating').length : 0;
      const totalPending = pendingCount + bulkGenerating;
      
      if (totalPending > 0) {
        tab.innerHTML = `Videos <span style="background: var(--accent); color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px; margin-left: 6px;">${totalPending}</span>`;
      } else {
        tab.textContent = 'Videos';
      }
    }
    
    // Render bulk i2v jobs in the Videos tab
    function renderBulkJobsInVideoTab() {
      let bulkSection = document.getElementById('bulk-i2v-video-section');
      
      // Check if we have any bulk items
      if (typeof bulkItems === 'undefined' || bulkItems.length === 0) {
        if (bulkSection) bulkSection.remove();
        return;
      }
      
      const generating = bulkItems.filter(it => it.status === 'generating').length;
      const done = bulkItems.filter(it => it.status === 'done').length;
      const failed = bulkItems.filter(it => it.status === 'error').length;
      
      if (generating === 0 && done === 0 && failed === 0) {
        if (bulkSection) bulkSection.remove();
        return;
      }
      
      // Create or update section
      if (!bulkSection) {
        bulkSection = document.createElement('div');
        bulkSection.id = 'bulk-i2v-video-section';
        bulkSection.style.cssText = 'margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px;';
        videoQueueContainer.parentElement.insertBefore(bulkSection, videoQueueContainer);
      }
      
      bulkSection.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <div style="display: flex; align-items: center; gap: 12px;">
            <span style="font-weight: 600; color: var(--text-primary);"> Bulk I2V Generation</span>
            <span style="font-size: 13px; color: var(--text-secondary);">
              ${generating > 0 ? `<span style="color: var(--accent);">${generating} generating</span>` : ''}
              ${done > 0 ? `<span style="color: #22c55e; margin-left: 8px;">${done} done</span>` : ''}
              ${failed > 0 ? `<span style="color: #ef4444; margin-left: 8px;">${failed} failed</span>` : ''}
            </span>
          </div>
          ${done > 0 ? `<button id="bulk-download-btn" onclick="downloadAllBulkVideos()" style="background: var(--accent); color: white; border: none; padding: 8px 16px; border-radius: 8px; font-size: 13px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 6px;">
            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
            Download All (${done})
          </button>` : ''}
        </div>
        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px;">
          ${bulkItems.filter(it => it.status === 'generating' || it.status === 'done' || it.status === 'error').map(item => `
            <div style="position: relative; aspect-ratio: 9/16; border-radius: 8px; overflow: hidden; background: var(--bg-tertiary);">
              ${item.status === 'done' && item.videoUrl 
                ? `<video src="${item.videoUrl}" style="width: 100%; height: 100%; object-fit: cover;" muted loop playsinline preload="none" onmouseover="this.play()" onmouseout="this.pause(); this.currentTime=0;"></video>`
                : `<img src="${item.url}" style="width: 100%; height: 100%; object-fit: cover; ${item.status === 'generating' ? 'filter: brightness(0.5);' : ''}" loading="lazy">
                   <div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;">
                     ${item.status === 'generating' 
                       ? '<div style="width: 24px; height: 24px; border: 2px solid var(--accent); border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>'
                       : item.status === 'error' 
                         ? `<button onclick="retrySingleBulkVideo('${item.taskId}')" style="background: #ef4444; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 11px; cursor: pointer; display: flex; align-items: center; gap: 4px;">
                              <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>
                              Retry
                            </button>` 
                         : ''}
                   </div>`
              }
            </div>
          `).join('')}
        </div>
      `;
    }

    function renderVideoQueue() {
      if (videoQueue.length === 0) {
        videoQueueContainer.innerHTML = '';
        videoEmptyState.style.display = 'block';
        videoCount.textContent = '0 videos';
        return;
      }

      videoEmptyState.style.display = 'none';
      videoCount.textContent = `${videoQueue.length} video${videoQueue.length === 1 ? '' : 's'}`;
      
      videoQueueContainer.innerHTML = `
        <div class="video-queue-grid">
          ${videoQueue.map((item, i) => `
            <div class="video-queue-item ${item.status}" data-id="${item.id}">
              <div class="video-queue-preview">
                ${item.status === 'complete' && item.videoUrl ? `
                  <video class="video-queue-thumb" src="${item.videoUrl}" autoplay loop muted playsinline></video>
                ` : `
                  <img class="video-queue-thumb ${item.status === 'generating' ? 'generating-blur' : ''}" src="${item.image.url}" alt="">
                  ${item.status === 'generating' ? '<div class="video-generating-overlay"><div class="spinner"></div><span>Generating...</span></div>' : ''}
                `}
              </div>
              <div class="video-queue-meta">
                <div class="video-queue-prompt">${item.prompt.substring(0, 60)}${item.prompt.length > 60 ? '...' : ''}</div>
                <div class="video-queue-status-row">
                  <span class="video-queue-status-dot ${item.status}"></span>
                  <span>${item.status === 'generating' ? 'Generating...' : item.status === 'complete' ? 'Ready' : item.status === 'error' ? 'Error' : 'Pending'}</span>
                  <button class="video-queue-remove" onclick="removeFromQueue(${item.id})" title="Remove"></button>
                </div>
              </div>
            </div>
          `).join('')}
        </div>
        ${videoQueue.filter(v => v.status === 'pending').length > 1 ? `
          <div style="margin-top: 20px; text-align: center;">
            <button class="video-queue-btn primary" onclick="generateAllVideos()" style="width: auto; padding: 12px 32px;">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 16px; height: 16px;">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
              </svg>
              Generate All (${videoQueue.filter(v => v.status === 'pending').length} videos)
            </button>
          </div>
        ` : ''}
      `;
    }

    function updateVideoPrompt(id, newPrompt) {
      const item = videoQueue.find(v => v.id === id);
      if (item) item.prompt = newPrompt;
    }

    function updateVideoModel(id, model) {
      const item = videoQueue.find(v => v.id === id);
      if (item) item.model = model;
    }

    function removeFromQueue(id) {
      videoQueue = videoQueue.filter(v => v.id !== id);
      renderGrid();
      renderVideoQueue();
      updateVideoTabBadge();
    }

    async function generateVideo(id) {
      const item = videoQueue.find(v => v.id === id);
      if (!item) return;
      
      item.status = 'generating';
      renderVideoQueue();
      
      try {
        // Use Kling API (via PiAPI Host-Your-Account)
        const response = await fetch('/api/kling/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            imageUrl: item.image.url,
            prompt: item.prompt,
            duration: 5,
            aspectRatio: item.image.ratio || '9:16',
            model: item.model || 'kling3'
          })
        });

        if (response.ok) {
          const data = await response.json();
          item.taskId = data.taskId;
          
          // Poll for completion
          item.videoUrl = await pollVideoStatus(data.taskId);
          item.status = item.videoUrl ? 'complete' : 'error';
        } else {
          item.status = 'error';
        }
      } catch (err) {
        console.error('Video generation failed:', err);
        item.status = 'error';
      }
      
      renderVideoQueue();
      updateVideoTabBadge();
    }

    async function generateAllVideos() {
      const pending = videoQueue.filter(v => v.status === 'pending');
      for (const item of pending) {
        await generateVideo(item.id);
      }
    }

    function downloadVideo(id) {
      const item = videoQueue.find(v => v.id === id);
      if (item?.videoUrl) {
        const a = document.createElement('a');
        a.href = item.videoUrl;
        a.download = `aditor-video-${item.id}.mp4`;
        a.click();
      }
    }

    // Poll for video generation completion
    async function pollVideoStatus(taskId, maxAttempts = 60) {
      for (let i = 0; i < maxAttempts; i++) {
        await new Promise(r => setTimeout(r, 5000)); // Wait 5 seconds between polls
        
        try {
          const response = await fetch(`/api/kling/status/${taskId}`);
          if (response.ok) {
            const data = await response.json();
            console.log(`[Kling] Poll ${i + 1}: ${data.status}`);
            
            if (data.status === 'complete' && data.videoUrl) {
              return data.videoUrl;
            } else if (data.status === 'error') {
              console.error('[Kling] Generation failed');
              return null;
            }
          }
        } catch (err) {
          console.error('[Kling] Poll error:', err);
        }
      }
      
      console.error('[Kling] Timeout after', maxAttempts, 'attempts');
      return null;
    }

    // Legacy function for modal
    function addToVideoQueue(index) {
      toggleVideoQueue(index);
    }

    // ===== GENERATE =====
    generateBtn.addEventListener('click', generate);
    promptInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        generate();
      }
    });

    // Track active generations for concurrent requests
    let activeGenerations = 0;
    const activeAbortControllers = new Map(); // placeholderId  AbortController

    function cancelGeneration(index) {
      const img = images[index];
      if (img && img.loading && img.id) {
        // Abort the fetch if still in flight
        const controller = activeAbortControllers.get(img.id);
        if (controller) {
          controller.abort();
          activeAbortControllers.delete(img.id);
        }
        // Remove from images array
        images.splice(index, 1);
        activeGenerations = Math.max(0, activeGenerations - 1);
        updateGeneratingText();
        if (activeGenerations === 0) {
          generating.classList.remove('active');
        }
        saveImages();
        renderGrid();
      }
    }
    // Expose globally for onclick
    window.cancelGeneration = cancelGeneration;
    
    async function generate() {
      const rawPrompt = promptInput.value.trim();
      if (!rawPrompt && references.length === 0) return;

      const genCount = parseInt(document.getElementById('gen-count').value) || 1;

      let basePrompt = rawPrompt;
      let negativePrompt = '';
      let useLLMExpansion = (genMode === 'broll' || genMode === 'talking');
      
      // For B-roll and Talking Head modes, we'll use LLM expansion via backend
      // Raw mode: use prompt as-is
      if (genMode !== 'raw') {
        negativePrompt = 'phone frame, device bezel, iOS interface, Android UI, status bar, home bar, camera app, viewfinder, REC indicator, screenshot frame, notification bar, app interface, UI elements, UI overlay, professional studio lighting, bokeh, blurred background, centered composition, posed, perfect, polished, stock photo, watermark, text, timestamp, date, timecode, yellow tint, thumb in frame';
      }

      // Save values before clearing UI
      const savedPrompt = rawPrompt;
      const savedReferences = [...references];
      const savedRatio = selectedRatio;
      const savedModel = selectedModel;
      
      // Clear input immediately so user can prep next prompt
      promptInput.value = '';
      references = [];
      renderReferences();

      // Add loading placeholders to grid immediately
      const placeholderIds = [];
      for (let i = 0; i < genCount; i++) {
        const placeholderId = 'loading-' + Date.now() + '-' + i;
        placeholderIds.push(placeholderId);
        images.unshift({
          id: placeholderId,
          url: null,
          prompt: savedPrompt,
          ratio: savedRatio,
          model: savedModel,
          createdAt: new Date().toISOString(),
          loading: true,
          saved: false
        });
      }
      renderGrid();

      // Show generating indicator if first batch
      activeGenerations += genCount;
      generating.classList.add('active');
      updateGeneratingText();

      // Generate all images concurrently
      const generateOne = async (placeholderId, index) => {
        const abortController = new AbortController();
        activeAbortControllers.set(placeholderId, abortController);
        try {
          let finalPrompt = basePrompt;
          
          // Use LLM expansion for B-roll and Talking Head modes
          if (useLLMExpansion && savedPrompt) {
            console.log(` LLM expanding: "${savedPrompt.slice(0, 50)}..."`);
            const modeHint = genMode === 'talking' 
              ? 'This is for a talking head video still - person should be mid-sentence, looking at camera, in a home setting.'
              : 'This is UGC b-roll content - candid, casual, real-looking phone photo.';
            
            const expandRes = await fetch('/api/prompt/expand', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ 
                prompt: `${savedPrompt}. ${modeHint}`,
                mode: genMode
              }),
              signal: abortController.signal
            });
            
            if (expandRes.ok) {
              const expandData = await expandRes.json();
              if (expandData.expanded) {
                finalPrompt = expandData.expanded;
                console.log(` Expanded to: "${finalPrompt.slice(0, 100)}..."`);
              }
            }
          }
          
          const response = await fetch('/api/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: finalPrompt,
              negativePrompt,
              references: savedReferences,
              ratio: savedRatio,
              model: savedModel
            }),
            signal: abortController.signal
          });

          const data = await response.json();
          console.log(`Image ${index + 1} response:`, data);

          // Find and update placeholder
          const placeholderIndex = images.findIndex(img => img.id === placeholderId);
          if (placeholderIndex >= 0) {
            if (response.ok && data.url) {
              images[placeholderIndex] = {
                url: data.url,
                prompt: savedPrompt,
                ratio: savedRatio,
                model: savedModel,
                createdAt: new Date().toISOString(),
                saved: false
              };
            } else {
              // Remove failed placeholder
              images.splice(placeholderIndex, 1);
              console.error('API error:', data);
            }
            saveImages();
            renderGrid();
          }
        } catch (err) {
          console.error(`Generation ${index + 1} failed:`, err);
          // Remove failed placeholder
          const placeholderIndex = images.findIndex(img => img.id === placeholderId);
          if (placeholderIndex >= 0) {
            images.splice(placeholderIndex, 1);
            renderGrid();
          }
        } finally {
          activeAbortControllers.delete(placeholderId);
          activeGenerations--;
          updateGeneratingText();
          if (activeGenerations === 0) {
            generating.classList.remove('active');
          }
        }
      };

      // Fire all requests concurrently
      placeholderIds.forEach((id, i) => generateOne(id, i));
    }
    
    function updateGeneratingText() {
      const text = activeGenerations > 0 ? `Generating ${activeGenerations}...` : 'Generating...';
      document.querySelector('.generating-text').textContent = text;
    }

    // ===== KEYBOARD SHORTCUTS =====
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeModal();
      }
    });

    // ===== PASTE IMAGES =====
    document.addEventListener('paste', (e) => {
      const items = e.clipboardData?.items;
      if (!items) return;

      for (const item of items) {
        if (item.type.startsWith('image/')) {
          const file = item.getAsFile();
          const reader = new FileReader();
          reader.onload = (e) => addReference(e.target.result);
          reader.readAsDataURL(file);
        }
      }
    });

    // ===== WORKFLOW STUDIO =====
    const workflowConfigs = {
      'script-to-video': {
        title: 'Script  UGC Video',
        desc: 'Upload avatar, paste script, select voice  get UGC video',
        customLayout: 'ugc-video',
        showUrl: false,
        showUpload: false,
        showScript: false,
        uploadHint: '',
        endpoint: '/api/ugc-video'
      },
      'kickstarter': {
        title: 'Kickstarter',
        desc: 'Paste a product page URL to generate 9:16 b-roll images and offer badges for VSLs.',
        showUrl: true,
        showUpload: false,
        showScript: false,
        uploadHint: '',
        endpoint: '/api/kickstarter'
      },
      'image-ads': {
        title: 'Image Ads',
        desc: 'Upload your product image and up to 8 inspiration ads to generate matching ad creatives.',
        showUrl: false,
        showUpload: true,
        showScript: false,
        uploadHint: 'Upload product image + inspiration ads',
        endpoint: '/api/image-ads'
      },
      'script-explainer': {
        title: 'Script  Explainer',
        desc: 'Paste your script and we\'ll generate consistent visual frames for an explainer video.',
        showUrl: false,
        showUpload: false,
        showScript: true,
        uploadHint: '',
        endpoint: '/api/script-explainer'
      },
      'screenshot-broll': {
        title: 'Screenshot  B-roll',
        desc: 'Upload a product image and a creator screenshot to recreate the frame with your product.',
        showUrl: false,
        showUpload: true,
        showScript: false,
        uploadHint: 'Upload product + creator screenshot',
        endpoint: '/api/screenshot-broll'
      },
      'motion-transfer': {
        title: 'Motion Transfer',
        desc: 'Record yourself with webcam, upload a character, and transfer your motion to them.',
        customLayout: 'motion-transfer',
        showUrl: false,
        showUpload: false,
        showScript: false,
        uploadHint: '',
        endpoint: '/api/motion-transfer',
        model: 'kling-motion-pro'
      }
    };

    let currentWorkflow = 'script-to-video';
    let workflowFiles = [];
    let workflowResults = [];

    // Workflow sidebar click handler
    document.querySelectorAll('.workflow-item').forEach(item => {
      item.addEventListener('click', () => {
        const workflow = item.dataset.workflow;
        selectWorkflow(workflow);
      });
    });

    function selectWorkflow(workflow) {
      currentWorkflow = workflow;
      const config = workflowConfigs[workflow];
      if (!config) return;

      // Update sidebar active state
      document.querySelectorAll('.workflow-item').forEach(item => {
        item.classList.toggle('active', item.dataset.workflow === workflow);
      });

      // Update header
      document.getElementById('workflow-title').textContent = config.title;
      document.getElementById('workflow-description').textContent = config.desc;

      // Handle custom layouts
      const ugcLayout = document.getElementById('ugc-video-layout');
      const motionLayout = document.getElementById('motion-transfer-layout');
      const genericForm = document.getElementById('workflow-form');
      const uploadZone = document.getElementById('workflow-upload-zone');
      const promptBar = document.querySelector('.prompt-container');

      // Hide all custom layouts first
      ugcLayout.style.display = 'none';
      motionLayout.style.display = 'none';
      genericForm.style.display = 'none';
      uploadZone.style.display = 'none';

      if (config.customLayout === 'ugc-video') {
        ugcLayout.style.display = 'grid';
        if (promptBar) promptBar.style.display = 'none';
      } else if (config.customLayout === 'motion-transfer') {
        motionLayout.style.display = 'grid';
        if (promptBar) promptBar.style.display = 'none';
        // Stop any active webcam when switching away
        stopWebcam();
      } else {
        // Show generic form
        genericForm.style.display = 'block';
        if (promptBar) promptBar.style.display = 'block';
        
        // Show/hide form fields
        document.getElementById('url-field').style.display = config.showUrl ? 'flex' : 'none';
        document.getElementById('script-field').style.display = config.showScript ? 'flex' : 'none';
        uploadZone.style.display = config.showUpload ? 'block' : 'none';
        document.getElementById('workflow-upload-hint').textContent = config.uploadHint;
      }

      // Clear form
      document.getElementById('workflow-url').value = '';
      document.getElementById('workflow-script').value = '';
      workflowFiles = [];
      renderWorkflowPreviews();

      // Clear results
      workflowResults = [];
      renderWorkflowResults();
    }

    // File upload handling
    const workflowUploadZone = document.getElementById('workflow-upload-zone');
    const workflowFileInput = document.getElementById('workflow-file-input');

    workflowUploadZone.addEventListener('click', (e) => {
      if (e.target.closest('.workflow-preview-remove')) return;
      workflowFileInput.click();
    });

    workflowUploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      workflowUploadZone.classList.add('dragover');
    });

    workflowUploadZone.addEventListener('dragleave', () => {
      workflowUploadZone.classList.remove('dragover');
    });

    workflowUploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      workflowUploadZone.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files);
      workflowFiles.push(...files);
      renderWorkflowPreviews();
    });

    workflowFileInput.addEventListener('change', () => {
      const files = Array.from(workflowFileInput.files);
      workflowFiles.push(...files);
      renderWorkflowPreviews();
      workflowFileInput.value = '';
    });

    function renderWorkflowPreviews() {
      const container = document.getElementById('workflow-upload-preview');
      container.classList.toggle('has-files', workflowFiles.length > 0);
      
      container.innerHTML = workflowFiles.map((file, i) => {
        const isVideo = file.type.startsWith('video/');
        const url = URL.createObjectURL(file);
        return `
          <div class="workflow-preview-item">
            ${isVideo 
              ? `<video src="${url}" muted></video>`
              : `<img src="${url}" alt="${file.name}">`
            }
            <button class="workflow-preview-remove" onclick="removeWorkflowFile(${i})"></button>
          </div>
        `;
      }).join('');
    }

    window.removeWorkflowFile = function(index) {
      workflowFiles.splice(index, 1);
      renderWorkflowPreviews();
    };

    // Form submission
    document.getElementById('workflow-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      await runWorkflow();
    });

    // ===== UGC VIDEO WORKFLOW HANDLERS =====
    let ugcAvatarFile = null;
    let elevenLabsVoices = [];
    let selectedVoiceId = '';

    // Load ElevenLabs voices
    async function loadElevenLabsVoices() {
      try {
        const res = await fetch('/api/elevenlabs/voices');
        const data = await res.json();
        elevenLabsVoices = data.voices || [];
        console.log(`Loaded ${elevenLabsVoices.length} ElevenLabs voices`);
        renderVoiceDropdown(elevenLabsVoices);
      } catch (err) {
        console.error('Failed to load voices:', err);
      }
    }

    function renderVoiceDropdown(voices) {
      const dropdown = document.getElementById('ugc-voice-dropdown');
      dropdown.innerHTML = voices.slice(0, 50).map(v => `
        <div class="ugc-voice-option" data-id="${v.id}" data-name="${v.name}">
          <div>
            <div class="ugc-voice-name">${v.name}</div>
            <div class="ugc-voice-category">${v.category || ''} ${v.labels?.gender || ''}</div>
          </div>
          ${v.previewUrl ? `<button class="ugc-voice-preview-btn" onclick="event.stopPropagation(); playVoicePreview('${v.previewUrl}')"> Preview</button>` : ''}
        </div>
      `).join('');
    }

    window.playVoicePreview = function(url) {
      const audio = new Audio(url);
      audio.play();
    };

    // Voice search functionality
    const voiceSearch = document.getElementById('ugc-voice-search');
    const voiceDropdown = document.getElementById('ugc-voice-dropdown');
    const voiceInput = document.getElementById('ugc-voice');

    voiceSearch.addEventListener('focus', () => {
      voiceDropdown.classList.add('open');
      if (elevenLabsVoices.length === 0) loadElevenLabsVoices();
    });

    voiceSearch.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase();
      const filtered = elevenLabsVoices.filter(v => 
        v.name.toLowerCase().includes(query) ||
        (v.labels?.accent || '').toLowerCase().includes(query) ||
        (v.labels?.gender || '').toLowerCase().includes(query)
      );
      renderVoiceDropdown(filtered);
      voiceDropdown.classList.add('open');
    });

    voiceDropdown.addEventListener('click', (e) => {
      const option = e.target.closest('.ugc-voice-option');
      if (option && !e.target.classList.contains('ugc-voice-preview-btn')) {
        const id = option.dataset.id;
        const name = option.dataset.name;
        voiceInput.value = id;
        voiceSearch.value = name;
        selectedVoiceId = id;
        voiceDropdown.classList.remove('open');
      }
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.ugc-voice-search-container')) {
        voiceDropdown.classList.remove('open');
      }
    });

    // Load voices on page load
    loadElevenLabsVoices();

    const ugcAvatarUpload = document.getElementById('ugc-avatar-upload');
    const ugcAvatarInput = document.getElementById('ugc-avatar-input');

    ugcAvatarUpload.addEventListener('click', () => ugcAvatarInput.click());
    
    ugcAvatarUpload.addEventListener('dragover', (e) => {
      e.preventDefault();
      ugcAvatarUpload.classList.add('dragover');
    });
    
    ugcAvatarUpload.addEventListener('dragleave', () => {
      ugcAvatarUpload.classList.remove('dragover');
    });
    
    ugcAvatarUpload.addEventListener('drop', (e) => {
      e.preventDefault();
      ugcAvatarUpload.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        setUgcAvatar(file);
      }
    });
    
    ugcAvatarInput.addEventListener('change', () => {
      const file = ugcAvatarInput.files[0];
      if (file) setUgcAvatar(file);
    });

    function setUgcAvatar(file) {
      ugcAvatarFile = file;
      const url = URL.createObjectURL(file);
      
      // Remove existing preview
      const existingPreview = ugcAvatarUpload.querySelector('.avatar-preview');
      if (existingPreview) existingPreview.remove();
      
      // Add preview image
      const img = document.createElement('img');
      img.src = url;
      img.className = 'avatar-preview';
      ugcAvatarUpload.appendChild(img);
      ugcAvatarUpload.classList.add('has-image');
    }

    // UGC Generate button
    document.getElementById('ugc-generate-btn').addEventListener('click', async () => {
      const script = document.getElementById('ugc-script').value.trim();
      const voice = document.getElementById('ugc-voice').value;
      
      if (!ugcAvatarFile) {
        alert('Please upload an avatar image');
        return;
      }
      if (!script) {
        alert('Please enter a script');
        return;
      }
      if (!voice) {
        alert('Please select a voice');
        return;
      }

      const btn = document.getElementById('ugc-generate-btn');
      btn.disabled = true;
      btn.textContent = 'Generating...';

      // Show loading in results
      workflowResults = [{ loading: true, id: 'loading-0', isVideo: true }];
      renderWorkflowResults();

      try {
        const formData = new FormData();
        formData.append('avatar', ugcAvatarFile);
        formData.append('script', script);
        formData.append('voice', voice);

        const response = await fetch('/api/ugc-video', {
          method: 'POST',
          body: formData
        });

        const data = await response.json();
        
        if (data.videoUrl) {
          workflowResults = [{ 
            url: data.videoUrl, 
            isVideo: true,
            downloadUrl: data.downloadUrl || data.videoUrl
          }];
        } else if (data.jobId) {
          // Poll for completion
          await pollUgcVideoStatus(data.jobId);
        } else {
          workflowResults = [];
          console.error('UGC video error:', data);
        }
        renderWorkflowResults();
      } catch (err) {
        console.error('UGC video error:', err);
        workflowResults = [];
        renderWorkflowResults();
      } finally {
        btn.disabled = false;
        btn.textContent = 'Generate';
      }
    });

    async function pollUgcVideoStatus(jobId) {
      return new Promise((resolve) => {
        const pollInterval = setInterval(async () => {
          try {
            const res = await fetch(`/api/ugc-video/status/${jobId}`);
            const status = await res.json();
            
            if (status.status === 'complete' && status.videoUrl) {
              clearInterval(pollInterval);
              workflowResults = [{ 
                url: status.videoUrl, 
                isVideo: true,
                downloadUrl: status.downloadUrl || status.videoUrl
              }];
              renderWorkflowResults();
              resolve();
            } else if (status.status === 'error') {
              clearInterval(pollInterval);
              workflowResults = [];
              renderWorkflowResults();
              resolve();
            }
          } catch (err) {
            console.error('Poll error:', err);
          }
        }, 3000);
      });
    }

    // ===== MOTION TRANSFER WORKFLOW HANDLERS =====
    let webcamStream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordedBlob = null;
    let characterFile = null;
    let recordingTimer = null;
    let recordingSeconds = 0;

    const webcamVideo = document.getElementById('webcam-video');
    const webcamPlayback = document.getElementById('webcam-playback');
    const webcamPlaceholder = document.getElementById('webcam-placeholder');
    const webcamTimer = document.getElementById('webcam-timer');
    const startBtn = document.getElementById('webcam-start-btn');
    const stopBtn = document.getElementById('webcam-stop-btn');
    const retryBtn = document.getElementById('webcam-retry-btn');
    const characterUpload = document.getElementById('character-upload');
    const characterInput = document.getElementById('character-input');
    const motionGenerateBtn = document.getElementById('motion-generate-btn');

    function stopWebcam() {
      if (webcamStream) {
        webcamStream.getTracks().forEach(track => track.stop());
        webcamStream = null;
      }
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
      clearInterval(recordingTimer);
    }

    startBtn?.addEventListener('click', async () => {
      try {
        webcamStream = await navigator.mediaDevices.getUserMedia({ 
          video: { width: 720, height: 1280, facingMode: 'user' }, 
          audio: false 
        });
        webcamVideo.srcObject = webcamStream;
        webcamVideo.style.display = 'block';
        webcamPlayback.style.display = 'none';
        webcamPlaceholder.style.display = 'none';
        
        // Start recording
        recordedChunks = [];
        mediaRecorder = new MediaRecorder(webcamStream, { mimeType: 'video/webm;codecs=vp9' });
        
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) recordedChunks.push(e.data);
        };
        
        mediaRecorder.onstop = () => {
          recordedBlob = new Blob(recordedChunks, { type: 'video/webm' });
          webcamPlayback.src = URL.createObjectURL(recordedBlob);
          webcamVideo.style.display = 'none';
          webcamPlayback.style.display = 'block';
          stopBtn.style.display = 'none';
          retryBtn.style.display = 'inline-flex';
          webcamTimer.classList.remove('recording');
          clearInterval(recordingTimer);
        };
        
        mediaRecorder.start();
        
        // Update UI
        startBtn.style.display = 'none';
        stopBtn.style.display = 'inline-flex';
        retryBtn.style.display = 'none';
        webcamTimer.classList.add('recording');
        
        // Start timer
        recordingSeconds = 0;
        recordingTimer = setInterval(() => {
          recordingSeconds++;
          const mins = Math.floor(recordingSeconds / 60);
          const secs = recordingSeconds % 60;
          webcamTimer.textContent = ` REC ${mins}:${secs.toString().padStart(2, '0')}`;
        }, 1000);
        
      } catch (err) {
        console.error('Webcam error:', err);
        alert('Could not access webcam. Please allow camera permissions.');
      }
    });

    stopBtn?.addEventListener('click', () => {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        stopWebcam();
      }
    });

    retryBtn?.addEventListener('click', () => {
      recordedBlob = null;
      webcamPlayback.style.display = 'none';
      webcamPlaceholder.style.display = 'flex';
      startBtn.style.display = 'inline-flex';
      retryBtn.style.display = 'none';
    });

    // Character upload
    characterUpload?.addEventListener('click', () => characterInput?.click());
    
    characterUpload?.addEventListener('dragover', (e) => {
      e.preventDefault();
      characterUpload.classList.add('dragover');
    });
    
    characterUpload?.addEventListener('dragleave', () => {
      characterUpload.classList.remove('dragover');
    });
    
    characterUpload?.addEventListener('drop', (e) => {
      e.preventDefault();
      characterUpload.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        setCharacterImage(file);
      }
    });
    
    characterInput?.addEventListener('change', () => {
      const file = characterInput.files[0];
      if (file) setCharacterImage(file);
    });

    function setCharacterImage(file) {
      characterFile = file;
      const url = URL.createObjectURL(file);
      
      const existingPreview = characterUpload.querySelector('.character-preview');
      if (existingPreview) existingPreview.remove();
      
      const img = document.createElement('img');
      img.src = url;
      img.className = 'character-preview';
      characterUpload.appendChild(img);
      characterUpload.classList.add('has-image');
    }

    // Generate motion transfer
    motionGenerateBtn?.addEventListener('click', async () => {
      if (!recordedBlob) {
        alert('Please record a video first');
        return;
      }
      if (!characterFile) {
        alert('Please upload a character image');
        return;
      }

      motionGenerateBtn.disabled = true;
      motionGenerateBtn.textContent = 'Generating...';

      // Show loading in results
      workflowResults = [{ loading: true, id: 'loading-0', isVideo: true }];
      renderWorkflowResults();

      try {
        const formData = new FormData();
        formData.append('video', recordedBlob, 'webcam.webm');
        formData.append('image', characterFile);
        formData.append('model', 'kling-motion-pro');

        const response = await fetch('/api/motion-transfer', {
          method: 'POST',
          body: formData
        });

        const data = await response.json();
        
        if (data.videoUrl) {
          workflowResults = [{ 
            url: data.videoUrl, 
            isVideo: true,
            downloadUrl: data.downloadUrl || data.videoUrl
          }];
        } else if (data.jobId || data.taskId) {
          await pollMotionTransferStatus(data.jobId || data.taskId);
        } else {
          workflowResults = [];
          console.error('Motion transfer error:', data);
        }
        renderWorkflowResults();
      } catch (err) {
        console.error('Motion transfer error:', err);
        workflowResults = [];
        renderWorkflowResults();
      } finally {
        motionGenerateBtn.disabled = false;
        motionGenerateBtn.textContent = 'Generate Motion Transfer';
      }
    });

    async function pollMotionTransferStatus(taskId) {
      return new Promise((resolve) => {
        const pollInterval = setInterval(async () => {
          try {
            const res = await fetch(`/api/motion-transfer/status/${taskId}`);
            const status = await res.json();
            
            if (status.status === 'complete' && status.videoUrl) {
              clearInterval(pollInterval);
              workflowResults = [{ 
                url: status.videoUrl, 
                isVideo: true,
                downloadUrl: status.downloadUrl || status.videoUrl
              }];
              renderWorkflowResults();
              resolve();
            } else if (status.status === 'error' || status.status === 'failed') {
              clearInterval(pollInterval);
              workflowResults = [];
              renderWorkflowResults();
              resolve();
            }
          } catch (err) {
            console.error('Poll error:', err);
          }
        }, 3000);
      });
    }

    async function runWorkflow() {
      const config = workflowConfigs[currentWorkflow];
      const submitBtn = document.getElementById('workflow-submit');
      submitBtn.disabled = true;
      submitBtn.textContent = 'Generating...';

      try {
        if (currentWorkflow === 'kickstarter') {
          await runKickstarterWorkflow();
        } else if (currentWorkflow === 'motion-transfer') {
          await runMotionTransferWorkflow();
        } else if (currentWorkflow === 'script-to-video' || currentWorkflow === 'script-explainer') {
          await runScriptToVideoWorkflow();
        } else {
          // Generic workflow handler (TODO: implement others)
          console.log('Workflow not yet implemented:', currentWorkflow);
        }
      } catch (err) {
        console.error('Workflow error:', err);
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Generate';
      }
    }

    async function runKickstarterWorkflow() {
      const url = document.getElementById('workflow-url').value.trim();
      if (!url) return;

      // Add loading placeholders
      workflowResults = Array(7).fill().map((_, i) => ({ loading: true, id: 'loading-' + i }));
      renderWorkflowResults();

      const response = await fetch('/api/kickstarter', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url })
      });
      
      const data = await response.json();
      if (!data.jobId) {
        workflowResults = [];
        renderWorkflowResults();
        return;
      }

      // Poll for status
      const pollInterval = setInterval(async () => {
        try {
          const statusRes = await fetch(`/api/kickstarter/status/${data.jobId}`);
          const status = await statusRes.json();
          
          if (status.generatedImages && status.generatedImages.length > 0) {
            workflowResults = status.generatedImages.map(img => ({
              url: img.thumbnail || img.url || img,
              fullRes: img.fullRes || img.url || img,
              thumbnail: img.thumbnail || img.url || img
            }));
            renderWorkflowResults();
          }

          if (status.status === 'complete' || status.status === 'error') {
            clearInterval(pollInterval);
          }
        } catch (err) {
          console.error('Poll error:', err);
        }
      }, 3000);
    }

    async function runMotionTransferWorkflow() {
      if (workflowFiles.length < 2) {
        alert('Please upload an image and a driving video');
        return;
      }

      const formData = new FormData();
      formData.append('model', 'kling-motion-pro');
      formData.append('type', 'video-to-video');
      
      // First file should be image, second should be video
      workflowFiles.forEach((file, i) => {
        if (file.type.startsWith('image/')) {
          formData.append('image', file);
        } else if (file.type.startsWith('video/')) {
          formData.append('video', file);
        }
      });

      workflowResults = [{ loading: true, id: 'loading-0' }];
      renderWorkflowResults();

      const response = await fetch('/api/runcomfy/generate', {
        method: 'POST',
        body: formData
      });

      const data = await response.json();
      if (data.videoUrl) {
        workflowResults = [{ url: data.videoUrl, isVideo: true }];
      } else if (data.taskId) {
        // Poll for completion
        await pollRunComfyStatus(data.taskId);
      } else {
        workflowResults = [];
      }
      renderWorkflowResults();
    }

    async function runScriptToVideoWorkflow() {
      const script = document.getElementById('workflow-script')?.value?.trim();
      if (!script) {
        alert('Please enter a script');
        return;
      }

      // Add loading placeholders
      workflowResults = Array(5).fill().map((_, i) => ({ loading: true, id: 'loading-' + i }));
      renderWorkflowResults();

      try {
        const response = await fetch('/api/script-explainer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ script })
        });
        
        const data = await response.json();
        if (data.jobId) {
          // Poll for status
          const pollInterval = setInterval(async () => {
            try {
              const statusRes = await fetch(`/api/script-explainer/status/${data.jobId}`);
              const status = await statusRes.json();
              
              if (status.status === 'complete' && status.results) {
                clearInterval(pollInterval);
                workflowResults = status.results.map(r => ({
                  url: r.url || r,
                  thumbnail: r.thumbnail,
                  fullRes: r.fullRes || r.url || r
                }));
                renderWorkflowResults();
              } else if (status.status === 'error') {
                clearInterval(pollInterval);
                workflowResults = [];
                renderWorkflowResults();
              }
            } catch (err) {
              console.error('Poll error:', err);
            }
          }, 3000);
        } else if (data.results) {
          workflowResults = data.results.map(r => ({
            url: r.url || r,
            thumbnail: r.thumbnail,
            fullRes: r.fullRes || r.url || r
          }));
          renderWorkflowResults();
        } else {
          workflowResults = [];
          renderWorkflowResults();
        }
      } catch (err) {
        console.error('Script workflow error:', err);
        workflowResults = [];
        renderWorkflowResults();
      }
    }

    async function pollRunComfyStatus(taskId) {
      // TODO: implement polling for RunComfy tasks
      console.log('Polling for task:', taskId);
    }

    function renderWorkflowResults() {
      const grid = document.getElementById('workflow-results-grid');
      const empty = document.getElementById('workflow-results-empty');
      const count = document.getElementById('workflow-results-count');

      const actualResults = workflowResults.filter(r => r.url);
      count.textContent = actualResults.length;

      if (workflowResults.length === 0) {
        grid.innerHTML = '';
        empty.style.display = 'block';
        return;
      }

      empty.style.display = 'none';
      grid.innerHTML = workflowResults.map((result, i) => {
        if (result.loading) {
          return `
            <div class="workflow-result-item workflow-result-loading">
              <div class="grid-item-spinner"></div>
            </div>
          `;
        }
        
        if (result.isVideo) {
          const downloadUrl = result.downloadUrl || result.url;
          return `
            <div class="workflow-result-item workflow-result-video">
              <video src="${result.url}" controls muted></video>
              <a href="${downloadUrl}" download class="workflow-download-link" target="_blank">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="16" height="16">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                </svg>
                Download Video
              </a>
            </div>
          `;
        }
        
        // Use thumbnail for display, store fullRes for later use
        const displayUrl = result.thumbnail || result.url;
        const fullResUrl = result.fullRes || result.url;
        return `
          <div class="workflow-result-item" onclick="addToMainGrid('${fullResUrl}')" data-full-res="${fullResUrl}">
            <img src="${displayUrl}" alt="Result ${i + 1}" loading="lazy">
          </div>
        `;
      }).join('');
    }

    window.addToMainGrid = function(url) {
      images.unshift({
        url: url,
        prompt: currentWorkflow + ' workflow output',
        ratio: '9:16',
        model: 'workflow',
        createdAt: new Date().toISOString(),
        saved: false
      });
      saveImages();
      renderGrid();
      // Switch to Images tab
      document.querySelector('[data-tab="images"]').click();
    };

    // Legacy shortcut-card handler (for compatibility)
    document.querySelectorAll('.shortcut-card').forEach(card => {
      card.addEventListener('click', () => {
        const workflow = card.dataset.workflow;
        selectWorkflow(workflow);
        document.querySelector('[data-tab="shortcuts"]').click();
      });
    });

    // Legacy showWorkflowModal - now redirects to workflow studio
    function showWorkflowModal(workflow) {
      selectWorkflow(workflow);
      document.querySelector('[data-tab="shortcuts"]').click();
    }

    // ===== CONTEXT PROFILES (disabled in UI) =====
    const contextSelect = document.getElementById('context-profile');
    const newContextBtn = document.getElementById('new-context-btn');

    // Only run if context UI elements exist
    if (contextSelect && newContextBtn) {
      async function loadContextProfiles() {
      try {
        const response = await fetch('/api/context/profiles');
        if (response.ok) {
          const data = await response.json();
          // Clear existing options except "No context"
          contextSelect.innerHTML = '<option value="">No context</option>';
          // Add profiles
          data.profiles.forEach(profile => {
            const option = document.createElement('option');
            option.value = profile.id;
            option.textContent = profile.name || profile.id;
            option.title = profile.tagline || '';
            contextSelect.appendChild(option);
          });
          // Restore selection from localStorage
          const savedContext = localStorage.getItem('aditor_context_profile');
          if (savedContext && data.profiles.find(p => p.id === savedContext)) {
            contextSelect.value = savedContext;
          }
        }
      } catch (err) {
        console.error('Failed to load context profiles:', err);
      }
    }

    // Save selection to localStorage
    contextSelect.addEventListener('change', () => {
      localStorage.setItem('aditor_context_profile', contextSelect.value);
      if (contextSelect.value) {
        console.log(' Context profile active:', contextSelect.value);
      }
    });

    // New context profile modal
    newContextBtn.addEventListener('click', () => {
      showContextModal();
    });

    function showContextModal() {
      const overlay = document.createElement('div');
      overlay.className = 'context-modal-overlay';
      overlay.innerHTML = `
        <div class="context-modal">
          <h2>Create Context Profile</h2>
          <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
            Describe your brand or product. The AI will create a consistent style guide for all generations.
          </p>
          <input type="text" class="context-name-input" placeholder="Profile name (e.g., wellness-brand)" />
          <textarea class="context-vision-input" placeholder="Describe your brand vision, target audience, visual style, product type...

Example: Premium wellness supplement brand targeting health-conscious millennials. Clean, minimal aesthetic with earth tones. Products are organic, science-backed. Think Ritual meets Athletic Greens."></textarea>
          <div class="context-modal-actions">
            <button class="context-cancel-btn">Cancel</button>
            <button class="context-generate-btn">Generate Profile</button>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);

      const nameInput = overlay.querySelector('.context-name-input');
      const visionInput = overlay.querySelector('.context-vision-input');
      const generateBtn = overlay.querySelector('.context-generate-btn');
      const cancelBtn = overlay.querySelector('.context-cancel-btn');

      cancelBtn.addEventListener('click', () => overlay.remove());
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) overlay.remove();
      });

      generateBtn.addEventListener('click', async () => {
        const name = nameInput.value.trim();
        const vision = visionInput.value.trim();
        
        if (!vision) {
          visionInput.style.borderColor = 'red';
          return;
        }

        generateBtn.textContent = 'Generating...';
        generateBtn.disabled = true;

        try {
          const response = await fetch('/api/context/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, vision })
          });

          if (response.ok) {
            const data = await response.json();
            console.log(' Context profile created:', data.profile);
            await loadContextProfiles();
            contextSelect.value = data.profile.id;
            localStorage.setItem('aditor_context_profile', data.profile.id);
            overlay.remove();
          } else {
            const err = await response.json();
            alert('Failed to generate profile: ' + (err.error || 'Unknown error'));
            generateBtn.textContent = 'Generate Profile';
            generateBtn.disabled = false;
          }
        } catch (err) {
          console.error('Context generation error:', err);
          alert('Failed to generate profile');
          generateBtn.textContent = 'Generate Profile';
          generateBtn.disabled = false;
        }
      });

      nameInput.focus();
    }
    } // end if (contextSelect && newContextBtn)

    // ===== INIT =====
    renderGrid();
    // loadContextProfiles(); // disabled - context UI removed
    
    // Initialize workflow (UGC video is default, needs custom layout)
    selectWorkflow('script-to-video');
    
    // Ensure prompt bar is visible on Images tab (default)
    const activeTab = document.querySelector('.nav-tab.active');
    if (activeTab && activeTab.dataset.tab === 'images') {
      const promptContainer = document.querySelector('.prompt-container');
      if (promptContainer) promptContainer.style.display = 'block';
    }

    // ===== RETRY SINGLE BULK VIDEO =====
    async function retrySingleBulkVideo(taskId) {
      const item = bulkItems.find(it => it.taskId === taskId);
      if (!item) return;
      
      item.status = 'generating';
      item.error = null;
      renderBulkJobsInVideoTab();
      
      try {
        const duration = parseInt(document.getElementById('bulk-duration')?.value || '5');
        const res = await fetch('/api/bulk-i2v/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            items: [{ url: item.url, prompt: item.prompt }], 
            duration,
            mode: 'std'
          })
        });
        const data = await res.json();
        
        if (data.batch && data.batch.jobs && data.batch.jobs[0]) {
          item.taskId = data.batch.jobs[0].id;
          item.status = data.batch.jobs[0].status === 'failed' ? 'error' : 'generating';
          
          // Start polling if not already
          if (!bulkPollInterval) {
            bulkBatchId = data.batchId;
            bulkPollInterval = setInterval(pollBulkStatus, 5000);
          }
        }
        
        renderBulkJobsInVideoTab();
        // Button already shows generating state
      } catch (err) {
        console.error('[Bulk I2V] Retry failed:', err);
        item.status = 'error';
        item.error = err.message;
        renderBulkJobsInVideoTab();
        // Error state shown on the item itself
      }
    }

    // ===== DOWNLOAD ALL BULK VIDEOS =====
    async function downloadAllBulkVideos() {
      const doneItems = bulkItems.filter(it => it.status === 'done' && it.videoUrl);
      if (!doneItems.length) return;
      
      const btn = document.getElementById('bulk-download-btn');
      if (btn) {
        btn.disabled = true;
        btn.innerHTML = `<svg class="spin" width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="31.4" stroke-dashoffset="10"/></svg> Downloading...`;
      }
      
      for (let i = 0; i < doneItems.length; i++) {
        const item = doneItems[i];
        try {
          // Use proxy to avoid CORS issues with external video hosts
          const filename = `broll-${i + 1}.mp4`;
          const proxyUrl = `${API_BASE}/api/proxy/video?url=${encodeURIComponent(item.videoUrl)}&filename=${encodeURIComponent(filename)}`;
          
          const a = document.createElement('a');
          a.href = proxyUrl;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          
          if (btn) btn.innerHTML = `<svg class="spin" width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="31.4" stroke-dashoffset="10"/></svg> ${i + 1}/${doneItems.length}...`;
          await new Promise(r => setTimeout(r, 500)); // Slight delay between downloads
        } catch (err) {
          console.error(`Failed to download video ${i + 1}:`, err);
        }
      }
      
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = `<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg> Downloaded `;
        setTimeout(() => {
          btn.innerHTML = `<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg> Download All (${doneItems.length})`;
        }, 2000);
      }
    }

    // ===== TOAST NOTIFICATIONS =====
    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = 'toast-notification';
      toast.style.cssText = `
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        background: ${type === 'success' ? '#22c55e' : type === 'error' ? '#ef4444' : '#3b82f6'};
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        z-index: 10000;
        animation: slideUp 0.3s ease;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      `;
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => {
        toast.style.animation = 'fadeOut 0.3s ease forwards';
        setTimeout(() => toast.remove(), 300);
      }, 4000);
    }

    // ===== BULK I2V TERMINAL MODE =====
    let bulkItems = []; // { id, file, url, filename, prompt, displayedPrompt, status, taskId, videoUrl }
    let bulkBatchId = null;
    let bulkPollInterval = null;
    let bulkMode = false;

    // Load all bulk jobs from backend on page load
    (async function loadActiveBulkJobs() {
      try {
        const res = await fetch('/api/bulk-i2v/jobs');
        const data = await res.json();
        if (data.batches && data.batches.length > 0) {
          // Load ALL batches with done or generating jobs
          bulkItems = [];
          let generatingBatchId = null;
          
          for (const batch of data.batches) {
            const hasRelevantJobs = batch.jobs.some(j => j.status === 'generating' || j.status === 'done' || j.status === 'failed');
            if (hasRelevantJobs) {
              for (const j of batch.jobs) {
                bulkItems.push({
                  id: j.id,
                  batchId: batch.id,
                  url: j.imageUrl || '',
                  filename: j.imageUrl ? j.imageUrl.split('/').pop() : '',
                  prompt: j.prompt || '',
                  displayedPrompt: j.prompt || '',
                  status: j.status === 'failed' ? 'error' : j.status === 'done' ? 'done' : 'generating',
                  taskId: j.id,
                  videoUrl: j.videoUrl || null
                });
              }
              // Track the batch with generating jobs for polling
              if (batch.jobs.some(j => j.status === 'generating')) {
                generatingBatchId = batch.id;
              }
            }
          }
          
          if (bulkItems.length > 0) {
            bulkBatchId = generatingBatchId || data.batches[0].id;
            console.log(`[Bulk I2V] Loaded ${bulkItems.length} jobs from ${data.batches.length} batches`);
            renderBulkJobsInVideoTab();
            updateVideoTabBadge();
            
            // Resume polling if still generating
            if (bulkItems.some(it => it.status === 'generating')) {
              bulkPollInterval = setInterval(pollBulkStatus, 5000);
            }
          }
        }
      } catch (err) {
        console.log('[Bulk I2V] No active jobs to load');
      }
    })();

    const bulkTerminal = document.getElementById('bulk-terminal');
    const bulkTerminalBody = document.getElementById('bulk-terminal-body');
    const bulkFileInput = document.getElementById('bulk-file-input');
    const bulkCloseBtn = document.getElementById('bulk-close');
    const bulkAnalyzeBtn = document.getElementById('bulk-analyze-btn');
    const bulkGenerateBtn = document.getElementById('bulk-generate-btn');
    const bulkProgressBar = document.getElementById('bulk-progress-bar');

    // Enter bulk mode when multiple images are dropped
    function enterBulkMode() {
      if (bulkMode) return;
      bulkMode = true;
      promptBar.classList.add('bulk-mode');
      console.log('[Bulk I2V] Entered terminal mode');
    }

    // Exit bulk mode
    function exitBulkMode() {
      bulkMode = false;
      promptBar.classList.remove('bulk-mode');
      bulkItems = [];
      bulkBatchId = null;
      if (bulkPollInterval) {
        clearInterval(bulkPollInterval);
        bulkPollInterval = null;
      }
      renderBulkTerminal();
      console.log('[Bulk I2V] Exited terminal mode');
    }

    bulkCloseBtn.addEventListener('click', exitBulkMode);

    // Handle file drops on prompt bar for bulk mode
    promptBar.addEventListener('drop', async (e) => {
      e.preventDefault();
      promptBar.classList.remove('drag-over');
      
      const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
      
      // If multiple images dropped, enter bulk mode
      if (files.length > 1) {
        enterBulkMode();
        await handleBulkFiles(files);
        return;
      }
      
      // Single image or grid drag - handle as reference (existing behavior)
      const imgSrc = e.dataTransfer.getData('text/plain');
      if (imgSrc && imgSrc.length > 0) {
        addReference(imgSrc);
        return;
      }
      
      if (files.length === 1) {
        const reader = new FileReader();
        reader.onload = (ev) => addReference(ev.target.result);
        reader.readAsDataURL(files[0]);
      }
    });

    // Also allow dropping on the whole main area when in Images tab
    document.querySelector('#images-section')?.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    document.querySelector('#images-section')?.addEventListener('drop', async (e) => {
      e.preventDefault();
      const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
      if (files.length > 1) {
        enterBulkMode();
        await handleBulkFiles(files);
      }
    });

    // Handle bulk file upload
    async function handleBulkFiles(files) {
      if (!files.length) return;
      
      // Clear old items if not currently generating (new upload session)
      const hasActiveGeneration = bulkItems.some(it => it.status === 'generating' || it.status === 'uploading' || it.status === 'analyzing');
      if (!hasActiveGeneration && bulkItems.length > 0) {
        console.log('[Bulk I2V] New upload session - clearing previous items');
        bulkItems = [];
        bulkBatchId = null;
      }
      
      const formData = new FormData();
      for (const f of files) {
        formData.append('images', f);
        // Add placeholder immediately with loading state
        bulkItems.push({
          id: 'temp-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
          file: f,
          url: URL.createObjectURL(f),
          filename: f.name,
          prompt: '',
          displayedPrompt: '',
          status: 'uploading',
          taskId: null,
          videoUrl: null
        });
      }
      renderBulkTerminal();

      try {
        const res = await fetch('/api/bulk-i2v/upload', { method: 'POST', body: formData });
        const data = await res.json();
        if (data.error) throw new Error(data.error);

        // Update items with server URLs
        for (const img of data.images) {
          const item = bulkItems.find(it => it.filename === img.filename);
          if (item) {
            item.url = img.url;
            item.status = 'uploaded';
          }
        }
        renderBulkTerminal();
        updateBulkStats();
        console.log(`[Bulk I2V] Uploaded ${data.images.length} images`);
        
        // Auto-start analysis immediately after upload
        bulkAnalyzeBtn.click();
      } catch (err) {
        console.error('[Bulk I2V] Upload failed:', err);
        bulkItems.forEach(it => {
          if (it.status === 'uploading') it.status = 'error';
        });
        renderBulkTerminal();
      }
    }

    // Analyze with Gemini
    bulkAnalyzeBtn.addEventListener('click', async () => {
      const toAnalyze = bulkItems.filter(it => !it.prompt && it.status !== 'analyzing');
      if (!toAnalyze.length) return;

      bulkAnalyzeBtn.disabled = true;
      bulkAnalyzeBtn.innerHTML = '<svg class="spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" width="14" height="14"><circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="31.4" stroke-dashoffset="10"/></svg> Analyzing...';
      
      toAnalyze.forEach(it => it.status = 'analyzing');
      renderBulkTerminal();

      try {
        const res = await fetch('/api/bulk-i2v/analyze', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ images: toAnalyze.map(it => ({ url: it.url, filename: it.filename })) })
        });
        const data = await res.json();

        // Start typewriter effect for each result
        for (const result of data.results) {
          const item = bulkItems.find(it => it.filename === result.filename);
          if (item && result.prompt) {
            item.prompt = result.prompt;
            item.status = 'ready';
            // Start typewriter animation
            typewriterPrompt(item);
          } else if (item) {
            item.status = 'error';
          }
        }
        
        renderBulkTerminal();
        updateBulkStats();
      } catch (err) {
        console.error('[Bulk I2V] Analysis failed:', err);
        toAnalyze.forEach(it => it.status = 'error');
        renderBulkTerminal();
      }

      bulkAnalyzeBtn.disabled = false;
      bulkAnalyzeBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg> Analyze';
    });

    // Typewriter effect for prompts
    function typewriterPrompt(item) {
      const fullPrompt = item.prompt;
      let charIndex = 0;
      item.displayedPrompt = '';
      item.isTyping = true;
      
      const typeInterval = setInterval(() => {
        if (charIndex < fullPrompt.length) {
          item.displayedPrompt += fullPrompt[charIndex];
          charIndex++;
          renderBulkTerminal();
        } else {
          item.isTyping = false;
          clearInterval(typeInterval);
          renderBulkTerminal();
        }
      }, 15); // 15ms per character for smooth typing
    }

    // Generate all videos
    bulkGenerateBtn.addEventListener('click', async () => {
      bulkGenerateBtn.disabled = true;
      bulkGenerateBtn.innerHTML = '<svg class="spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" width="14" height="14"><circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="31.4" stroke-dashoffset="10"/></svg> Processing...';

      // Auto-analyze any items that haven't been analyzed yet
      const unanalyzed = bulkItems.filter(it => !it.prompt && (it.status === 'uploaded' || it.status === 'uploading'));
      if (unanalyzed.length > 0) {
        // Wait for any still-uploading items
        let retries = 0;
        while (bulkItems.some(it => it.status === 'uploading') && retries < 30) {
          await new Promise(r => setTimeout(r, 500));
          retries++;
        }

        const toAnalyze = bulkItems.filter(it => !it.prompt && it.status === 'uploaded');
        toAnalyze.forEach(it => it.status = 'analyzing');
        renderBulkTerminal();

        try {
          const analyzeRes = await fetch('/api/bulk-i2v/analyze', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ imageUrls: toAnalyze.map(it => it.url) })
          });
          const analyzeData = await analyzeRes.json();
          if (analyzeData.results) {
            for (let i = 0; i < analyzeData.results.length; i++) {
              const item = toAnalyze[i];
              if (item && analyzeData.results[i]) {
                item.prompt = analyzeData.results[i].prompt;
                item.displayedPrompt = analyzeData.results[i].prompt;
                item.status = 'ready';
              }
            }
          }
          renderBulkTerminal();
        } catch (err) {
          console.error('[Bulk I2V] Auto-analyze failed:', err);
          toAnalyze.forEach(it => it.status = 'error');
          renderBulkTerminal();
          bulkGenerateBtn.disabled = false;
          bulkGenerateBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg> Generate All';
          return;
        }
      }

      const readyItems = bulkItems.filter(it => it.prompt && it.status === 'ready');
      if (!readyItems.length) {
        bulkGenerateBtn.disabled = false;
        bulkGenerateBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg> Generate All';
        return;
      }

      bulkGenerateBtn.innerHTML = '<svg class="spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" width="14" height="14"><circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="31.4" stroke-dashoffset="10"/></svg> Generating...';

      readyItems.forEach(it => it.status = 'generating');
      renderBulkTerminal();
      updateBulkProgress();

      try {
        const duration = parseInt(document.getElementById('bulk-duration').value);
        const res = await fetch('/api/bulk-i2v/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            items: readyItems.map(it => ({ url: it.url, prompt: it.prompt })), 
            duration,
            mode: 'std'
          })
        });
        const data = await res.json();
        bulkBatchId = data.batchId;

        // Map job IDs back
        if (data.batch && data.batch.jobs) {
          data.batch.jobs.forEach((job, idx) => {
            const item = readyItems[idx];
            if (item) {
              item.taskId = job.id;
              item.status = job.status === 'failed' ? 'error' : 'generating';
              item.error = job.error;
            }
          });
        }
        
        renderBulkTerminal();

        // Start polling in background
        if (bulkPollInterval) clearInterval(bulkPollInterval);
        bulkPollInterval = setInterval(pollBulkStatus, 5000);
        
        // Close terminal, clear references, switch to Videos tab
        setTimeout(() => {
          exitBulkMode();
          // Clear reference images from prompt field
          references = [];
          renderReferences();
          // Switch to Videos tab
          document.querySelector('.nav-tab[data-tab="videos"]')?.click();
          // Badge on Videos tab shows generating count
        }, 500);
      } catch (err) {
        console.error('[Bulk I2V] Generation failed:', err);
        readyItems.forEach(it => it.status = 'error');
        renderBulkTerminal();
        bulkGenerateBtn.disabled = false;
        bulkGenerateBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg> Generate All';
        return;
      }

      bulkGenerateBtn.disabled = false;
      bulkGenerateBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg> Generate All';
    });

    // Poll for generation status (handles multiple batches)
    async function pollBulkStatus() {
      // Get unique batch IDs that have generating items
      const generatingBatchIds = [...new Set(bulkItems.filter(it => it.status === 'generating' && it.batchId).map(it => it.batchId))];
      if (generatingBatchIds.length === 0 && !bulkBatchId) return;
      
      // Also include the current bulkBatchId if set
      const batchIds = bulkBatchId ? [...new Set([...generatingBatchIds, bulkBatchId])] : generatingBatchIds;
      
      let changed = false;
      for (const batchId of batchIds) {
        try {
          const res = await fetch(`/api/bulk-i2v/status/${batchId}`);
          const data = await res.json();
          
          if (data.batch && data.batch.jobs) {
            data.batch.jobs.forEach(job => {
              const item = bulkItems.find(it => it.taskId === job.id);
              if (item) {
                if (job.status === 'done' && job.videoUrl && item.status !== 'done') {
                  item.status = 'done';
                  item.videoUrl = job.videoUrl;
                  changed = true;
                } else if (job.status === 'failed' && item.status !== 'error') {
                  item.status = 'error';
                  item.error = job.error;
                  changed = true;
                }
              }
            });
          }
        } catch (err) {
          console.log(`[Bulk I2V] Failed to poll batch ${batchId}`);
        }
      }
      
      // Only re-render when status actually changed
      if (changed) {
        renderBulkTerminal();
        updateBulkStats();
        updateBulkProgress();
        renderBulkJobsInVideoTab();
        updateVideoTabBadge();
      }

      // Check if all items are done
      const stillGenerating = bulkItems.some(it => it.status === 'generating');
      if (!stillGenerating) {
        clearInterval(bulkPollInterval);
        bulkPollInterval = null;
        const doneCount = bulkItems.filter(it => it.status === 'done').length;
        const failCount = bulkItems.filter(it => it.status === 'error').length;
        console.log(`[Bulk I2V] All complete: ${doneCount} done, ${failCount} failed`);
        
        // Completion handled by UI state
        if (doneCount > 0) {
          // Videos tab and section update automatically
        } else {
          // All failed - section shows retry buttons
            }
          }
        }
      } catch (err) {
        console.error('[Bulk I2V] Poll error:', err);
      }
    }

    // Update stats display
    function updateBulkStats() {
      document.getElementById('bulk-count-total').textContent = bulkItems.length;
      document.getElementById('bulk-count-ready').textContent = bulkItems.filter(it => it.status === 'ready').length;
      document.getElementById('bulk-count-done').textContent = bulkItems.filter(it => it.status === 'done').length;
      
      // Enable generate button as soon as we have any items (processing happens in background)
      bulkGenerateBtn.disabled = bulkItems.length === 0;
    }

    // Update progress bar
    function updateBulkProgress() {
      const generating = bulkItems.filter(it => it.status === 'generating' || it.status === 'done');
      const done = bulkItems.filter(it => it.status === 'done');
      
      if (generating.length === 0) {
        bulkProgressBar.style.width = '0%';
      } else {
        const progress = (done.length / generating.length) * 100;
        bulkProgressBar.style.width = `${progress}%`;
      }
    }

    // Render terminal lines
    function renderBulkTerminal() {
      bulkTerminalBody.innerHTML = bulkItems.map((item, i) => {
        const statusBadge = getStatusBadge(item.status);
        const promptClass = item.isTyping ? 'typing' : (item.status === 'analyzing' ? 'analyzing' : (item.status === 'error' ? 'error' : ''));
        const promptText = item.displayedPrompt || item.prompt || (item.status === 'analyzing' ? 'Analyzing with Gemini...' : (item.status === 'uploading' ? 'Uploading...' : ''));
        
        return `
          <div class="bulk-line" data-index="${i}">
            <div class="bulk-line-thumb">
              ${item.status === 'done' && item.videoUrl 
                ? `<video src="${item.videoUrl}" muted loop playsinline></video>`
                : `<img src="${item.url}" alt="${item.filename}">`
              }
            </div>
            <div class="bulk-line-content">
              <div class="bulk-line-filename">
                <span>${item.filename}</span>
                <span class="bulk-line-arrow"></span>
              </div>
              <div class="bulk-line-prompt ${promptClass}">${promptText || '...'}</div>
            </div>
            <div class="bulk-line-status">
              <span class="bulk-line-badge ${item.status}">${statusBadge}</span>
              ${item.status === 'done' && item.videoUrl ? `
                <button class="bulk-line-action play" onclick="playBulkVideo(${i})" title="Play">
                  <svg fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                </button>
                <button class="bulk-line-action" onclick="downloadBulkVideo(${i})" title="Download">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
                </button>
              ` : ''}
              <button class="bulk-line-action" onclick="removeBulkItem(${i})" title="Remove">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
              </button>
            </div>
          </div>
        `;
      }).join('');

      // Auto-play videos on hover
      bulkTerminalBody.querySelectorAll('.bulk-line-thumb video').forEach(video => {
        video.closest('.bulk-line').addEventListener('mouseenter', () => video.play());
        video.closest('.bulk-line').addEventListener('mouseleave', () => video.pause());
      });

      updateBulkStats();
    }

    function getStatusBadge(status) {
      const badges = {
        'uploading': ' UPLOAD',
        'uploaded': ' READY',
        'analyzing': ' ANALYZING',
        'ready': ' READY',
        'generating': ' GENERATING',
        'done': ' DONE',
        'error': ' ERROR'
      };
      return badges[status] || status;
    }

    // Play video in modal
    window.playBulkVideo = function(index) {
      const item = bulkItems[index];
      if (!item?.videoUrl) return;

      const modal = document.createElement('div');
      modal.className = 'bulk-video-modal';
      modal.innerHTML = `
        <button class="bulk-video-modal-close" onclick="this.closest('.bulk-video-modal').remove()"></button>
        <video src="${item.videoUrl}" controls autoplay></video>
        <a class="bulk-video-modal-download" href="${item.videoUrl}" download="${item.filename.replace(/\.[^.]+$/, '')}.mp4">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="18" height="18"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
          Download Video
        </a>
      `;
      document.body.appendChild(modal);
      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });
    };

    // Download video
    window.downloadBulkVideo = function(index) {
      const item = bulkItems[index];
      if (!item?.videoUrl) return;
      
      const a = document.createElement('a');
      a.href = item.videoUrl;
      a.download = item.filename.replace(/\.[^.]+$/, '') + '.mp4';
      a.click();
    };

    // Remove item from bulk list
    window.removeBulkItem = function(index) {
      bulkItems.splice(index, 1);
      renderBulkTerminal();
      
      if (bulkItems.length === 0) {
        exitBulkMode();
      }
    };

    // Add spin animation for loading states
    const spinStyle = document.createElement('style');
    spinStyle.textContent = `
      @keyframes spin { to { transform: rotate(360deg); } }
      .spin { animation: spin 1s linear infinite; }
    `;
    document.head.appendChild(spinStyle);
  </script>

<script src="/cdn-cgi/scripts/7d0fa10a/cloudflare-static/rocket-loader.min.js" data-cf-settings="0aa74984300c6238b39e36b1-|49" defer></script></body>
</html>
