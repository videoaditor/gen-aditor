<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aditor Studio</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #08080c;
      --bg-secondary: #0f0f14;
      --bg-tertiary: #16161d;
      --bg-hover: #1c1c26;
      --border: #232330;
      --text-primary: #ffffff;
      --text-secondary: #8b8b9e;
      --text-tertiary: #5c5c6f;
      --accent: #f97316;
      --accent-hover: #ea580c;
      --accent-glow: rgba(249, 115, 22, 0.15);
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* ===== TOP NAV ===== */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      padding: 16px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(8, 8, 12, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border);
    }

    .nav-logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      font-size: 18px;
    }

    .nav-logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--accent) 0%, #c2410c 100%);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 16px;
    }

    .nav-logo-img {
      height: 28px;
      width: auto;
    }

    .nav-tabs {
      display: flex;
      gap: 4px;
      background: var(--bg-tertiary);
      padding: 4px;
      border-radius: 12px;
    }

    .nav-tab {
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .nav-tab:hover {
      color: var(--text-primary);
      background: var(--bg-hover);
    }

    .nav-tab.active {
      color: var(--text-primary);
      background: var(--bg-primary);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .nav-profile {
      width: 36px;
      height: 36px;
      background: var(--bg-tertiary);
      border-radius: 50%;
      border: 2px solid var(--border);
      cursor: pointer;
      transition: border-color 0.2s ease;
    }

    .nav-profile:hover {
      border-color: var(--accent);
    }

    /* ===== MAIN CONTENT ===== */
    .main {
      padding-top: 80px;
      padding-bottom: 140px;
      min-height: 100vh;
    }

    /* ===== IMAGE GRID ===== */
    .grid-container {
      padding: 24px;
    }

    .grid-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    .grid-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .grid-count {
      font-size: 13px;
      color: var(--text-tertiary);
    }

    .masonry-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 12px;
    }

    @media (max-width: 1600px) {
      .masonry-grid { grid-template-columns: repeat(5, 1fr); }
    }
    @media (max-width: 1400px) {
      .masonry-grid { grid-template-columns: repeat(4, 1fr); }
    }
    @media (max-width: 1100px) {
      .masonry-grid { grid-template-columns: repeat(3, 1fr); }
    }
    @media (max-width: 800px) {
      .masonry-grid { grid-template-columns: repeat(2, 1fr); }
    }

    .grid-item {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      cursor: pointer;
      background: var(--bg-secondary);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      aspect-ratio: 9 / 16;
    }

    .grid-item:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
    }

    .grid-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      -webkit-user-drag: none;
      user-select: none;
    }

    .grid-item-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 50%);
      opacity: 0;
      transition: opacity 0.2s ease;
      display: flex;
      align-items: flex-end;
      padding: 12px;
    }

    .grid-item:hover .grid-item-overlay {
      opacity: 1;
    }

    .grid-item-actions {
      display: flex;
      gap: 8px;
      width: 100%;
    }

    .grid-item-btn {
      flex: 1;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .grid-item-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .grid-item-btn.primary {
      background: var(--accent);
    }

    .grid-item-btn.primary:hover {
      background: var(--accent-hover);
    }

    /* Drag indicator */
    .grid-item.dragging {
      opacity: 0.5;
    }

    .grid-item-drag-hint {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border-radius: 6px;
      font-size: 11px;
      color: var(--text-secondary);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .grid-item:hover .grid-item-drag-hint {
      opacity: 1;
    }

    /* Save to video button */
    .grid-item-save {
      position: absolute;
      bottom: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border: none;
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.2s ease;
    }

    .grid-item:hover .grid-item-save {
      opacity: 1;
    }

    .grid-item-save:hover {
      background: var(--accent);
      color: white;
      transform: scale(1.1);
    }

    .grid-item-save.saved {
      opacity: 1;
      background: var(--accent);
      color: white;
    }

    /* Delete button */
    .grid-item-delete {
      position: absolute;
      bottom: 8px;
      left: 8px;
      width: 32px;
      height: 32px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border: none;
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.2s ease;
    }

    .grid-item:hover .grid-item-delete {
      opacity: 1;
    }

    .grid-item-delete:hover {
      background: #dc2626;
      color: white;
      transform: scale(1.1);
    }

    .grid-item-delete svg {
      width: 16px;
      height: 16px;
    }

    /* Loading placeholder */
    .grid-item-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-tertiary);
      border: 2px dashed var(--border);
    }

    .grid-item-loading-inner {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 16px;
    }

    .grid-item-cancel {
      background: rgba(255, 60, 60, 0.2);
      border: 1px solid rgba(255, 60, 60, 0.4);
      color: #ff6b6b;
      padding: 6px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s;
    }
    .grid-item-cancel:hover {
      background: rgba(255, 60, 60, 0.4);
      color: #fff;
    }

    .grid-item-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .grid-item-loading-text {
      font-size: 12px;
      color: var(--text-secondary);
      text-align: center;
      max-width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .grid-item-save svg {
      width: 16px;
      height: 16px;
    }

    /* ===== PROMPT BAR ===== */
    .prompt-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 16px 24px 24px;
      background: linear-gradient(to top, var(--bg-primary) 70%, transparent);
      pointer-events: none;
    }

    .prompt-bar {
      max-width: 800px;
      margin: 0 auto;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 12px;
      pointer-events: auto;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .prompt-bar:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px var(--accent-glow);
    }

    .prompt-bar.drag-over {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px var(--accent-glow);
      background: var(--bg-tertiary);
    }

    .prompt-references {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      min-height: 0;
    }

    .prompt-references:empty {
      display: none;
    }

    .prompt-ref {
      position: relative;
      width: 48px;
      height: 48px;
      border-radius: 8px;
      overflow: hidden;
      background: var(--bg-tertiary);
    }

    .prompt-ref img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .prompt-ref-remove {
      position: absolute;
      top: -4px;
      right: -4px;
      width: 18px;
      height: 18px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 50%;
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
    }

    .prompt-ref-remove:hover {
      background: #dc2626;
      color: white;
      border-color: #dc2626;
    }

    .prompt-input-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .prompt-input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      font-size: 15px;
      color: var(--text-primary);
      padding: 8px 12px;
    }

    .prompt-input::placeholder {
      color: var(--text-tertiary);
    }

    /* ===== @ MENTION AUTOCOMPLETE ===== */
    .mention-dropdown {
      position: absolute;
      background: #0f0f14;
      border: 1px solid #232330;
      border-radius: 12px;
      padding: 8px 0;
      min-width: 280px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      display: none;
    }

    .mention-dropdown.show {
      display: block;
    }

    .mention-header {
      padding: 8px 16px;
      font-size: 11px;
      font-weight: 600;
      color: #8b8b9e;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .mention-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 16px;
      cursor: pointer;
      transition: background 0.15s;
    }

    .mention-item:hover,
    .mention-item.active {
      background: #232330;
    }

    .mention-item img {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      object-fit: cover;
      background: #1a1a24;
    }

    .mention-item .mention-info {
      flex: 1;
    }

    .mention-item .mention-name {
      font-size: 14px;
      font-weight: 500;
      color: #fff;
    }

    .mention-item .mention-brand {
      font-size: 11px;
      color: #8b8b9e;
    }

    .mention-item .mention-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid #232330;
    }

    /* ===== AVATAR PICKER MODAL ===== */
    .avatar-picker-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 3000;
    }

    .avatar-picker-overlay.show {
      display: flex;
    }

    .avatar-picker-modal {
      background: #0f0f14;
      border: 1px solid #232330;
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 480px;
    }

    .avatar-picker-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      text-align: center;
    }

    .avatar-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
      margin-bottom: 20px;
    }

    .avatar-option {
      aspect-ratio: 1;
      border-radius: 12px;
      overflow: hidden;
      cursor: pointer;
      border: 3px solid transparent;
      transition: all 0.2s;
      background: #1a1a24;
    }

    .avatar-option:hover {
      border-color: #8b5cf6;
      transform: scale(1.05);
    }

    .avatar-option.selected {
      border-color: #a78bfa;
      box-shadow: 0 0 20px rgba(167,139,250,0.3);
    }

    .avatar-option img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .avatar-picker-close {
      width: 100%;
      padding: 12px;
      background: #232330;
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.15s;
    }

    .avatar-picker-close:hover {
      background: #2a2a3a;
    }

    /* Product reference chip */
    .product-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(135deg, #8b5cf6 0%, #a78bfa 100%);
      color: white;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
      margin-right: 8px;
    }

    .product-chip .remove {
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.15s;
    }

    .product-chip .remove:hover {
      opacity: 1;
    }

    .prompt-btn {
      width: 44px;
      height: 44px;
      background: var(--accent);
      border: none;
      border-radius: 12px;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease, transform 0.1s ease;
    }

    .prompt-btn:hover {
      background: var(--accent-hover);
    }

    .prompt-btn:active {
      transform: scale(0.95);
    }

    .prompt-btn svg {
      width: 20px;
      height: 20px;
    }

    .prompt-options {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
      align-items: center;
    }

    .prompt-option {
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s ease;
    }

    .prompt-option:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .prompt-option.active {
      background: var(--accent-glow);
      border-color: var(--accent);
      color: var(--accent);
    }

    .prompt-option svg {
      width: 14px;
      height: 14px;
    }

    .prompt-select {
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%238b8b9e' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      padding-right: 28px;
      transition: all 0.2s ease;
    }

    .prompt-select:hover {
      background-color: var(--bg-hover);
      color: var(--text-primary);
    }

    .prompt-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .prompt-spacer {
      flex: 1;
    }

    /* ===== FULLSCREEN MODAL ===== */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(20px);
      z-index: 200;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 40px;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-content {
      max-width: 90vw;
      max-height: 90vh;
      position: relative;
    }

    .modal-image {
      max-width: 100%;
      max-height: 80vh;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 20px;
    }

    .modal-btn {
      padding: 12px 24px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s ease;
    }

    .modal-btn:hover {
      background: var(--bg-hover);
    }

    .modal-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
    }

    .modal-btn.primary:hover {
      background: var(--accent-hover);
    }

    .modal-close {
      position: fixed;
      top: 80px;
      right: 40px;
      width: 44px;
      height: 44px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 50%;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.2s ease;
      z-index: 1001;
    }

    .modal-close:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .modal-meta {
      margin-top: 16px;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border-radius: 12px;
      font-size: 13px;
      color: var(--text-secondary);
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .modal-meta:empty {
      display: none;
    }

    .modal-meta-prompt {
      margin-bottom: 8px;
      color: var(--text-primary);
      line-height: 1.5;
    }

    .modal-meta-settings {
      display: flex;
      gap: 16px;
      font-size: 12px;
    }

    .modal-meta-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .modal-meta-label {
      color: var(--text-tertiary);
    }

    .modal-meta-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .modal-meta-btn {
      padding: 6px 12px;
      background: var(--bg-hover);
      border: none;
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .modal-meta-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    /* ===== EMPTY STATE ===== */
    .empty-state {
      text-align: center;
      padding: 80px 20px;
    }

    .empty-icon {
      width: 80px;
      height: 80px;
      background: var(--bg-secondary);
      border-radius: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 24px;
    }

    .empty-icon svg {
      width: 40px;
      height: 40px;
      color: var(--text-tertiary);
    }

    .empty-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .empty-desc {
      color: var(--text-secondary);
      font-size: 14px;
      max-width: 400px;
      margin: 0 auto;
    }

    /* ===== LOADING ===== */
    .generating {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px 32px;
      display: none;
      align-items: center;
      gap: 16px;
      z-index: 150;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .generating.active {
      display: none; /* Removed - placeholder cards already show loading state */
    }

    .generating-spinner {
      width: 24px;
      height: 24px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .generating-text {
      font-size: 14px;
      font-weight: 500;
    }

    /* ===== DRAG GHOST ===== */
    .drag-ghost {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      width: 80px;
      height: 120px;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      opacity: 0.9;
    }

    .drag-ghost img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* ===== WORKFLOW STUDIO (Shortcuts Tab) ===== */
    .workflow-studio {
      display: grid;
      grid-template-columns: 220px 1fr 320px;
      height: calc(100vh - 65px);
      gap: 0;
    }

    /* Left sidebar - workflow list */
    .workflow-sidebar {
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      padding: 16px 0;
      overflow-y: auto;
    }

    .workflow-sidebar-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-tertiary);
      padding: 0 16px;
      margin-bottom: 12px;
    }

    .workflow-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      cursor: pointer;
      transition: all 0.15s ease;
      border-left: 3px solid transparent;
    }

    .workflow-item:hover {
      background: var(--bg-hover);
    }

    .workflow-item.active {
      background: var(--accent-glow);
      border-left-color: var(--accent);
    }

    .workflow-item-icon {
      width: 36px;
      height: 36px;
      background: var(--bg-tertiary);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .workflow-item.active .workflow-item-icon {
      background: var(--accent);
    }

    .workflow-item-icon svg {
      width: 18px;
      height: 18px;
      color: var(--text-secondary);
    }

    .workflow-item.active .workflow-item-icon svg {
      color: white;
    }

    .workflow-item-text {
      flex: 1;
      min-width: 0;
    }

    .workflow-item-name {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .workflow-item.coming-soon {
      opacity: 0.45;
      cursor: default;
      pointer-events: none;
    }

    .workflow-item.coming-soon:hover {
      background: transparent;
    }

    .workflow-item.coming-soon .workflow-item-name {
      color: var(--text-secondary);
    }

    .workflow-divider {
      padding: 16px 16px 8px;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-tertiary);
      text-transform: uppercase;
      letter-spacing: 0.8px;
      border-top: 1px solid var(--border);
      margin-top: 8px;
    }

    .workflow-item-desc {
      font-size: 11px;
      color: var(--text-tertiary);
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Center - workflow input area */
    .workflow-main {
      padding: 32px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .workflow-header {
      margin-bottom: 24px;
    }

    .workflow-header h2 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .workflow-header p {
      font-size: 14px;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    /* ===== MOTION TRANSFER WORKFLOW LAYOUT ===== */
    .motion-transfer-layout {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      height: 100%;
    }

    .webcam-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .webcam-container {
      flex: 1;
      background: var(--bg-tertiary);
      border-radius: 16px;
      overflow: hidden;
      position: relative;
      min-height: 360px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .webcam-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* Mirror for natural feel */
    }

    .webcam-preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .webcam-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      color: var(--text-secondary);
    }

    .webcam-placeholder svg {
      width: 48px;
      height: 48px;
    }

    .webcam-controls {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .webcam-btn {
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .webcam-btn-start {
      background: var(--accent);
      color: white;
      border: none;
    }

    .webcam-btn-start:hover {
      background: var(--accent-hover);
    }

    .webcam-btn-stop {
      background: #ef4444;
      color: white;
      border: none;
    }

    .webcam-btn-stop:hover {
      background: #dc2626;
    }

    .webcam-btn-retry {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    .webcam-btn-retry:hover {
      background: var(--bg-hover);
    }

    .webcam-timer {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(239, 68, 68, 0.9);
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      display: none;
    }

    .webcam-timer.recording {
      display: block;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .character-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .character-upload {
      flex: 1;
      border: 2px dashed var(--border);
      border-radius: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 360px;
      position: relative;
      overflow: hidden;
    }

    .character-upload:hover {
      border-color: var(--accent);
      background: var(--accent-glow);
    }

    .character-upload.has-image {
      border-style: solid;
    }

    .character-upload .character-preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
    }

    .character-upload .character-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      color: var(--text-secondary);
    }

    .character-upload.has-image .character-placeholder {
      display: none;
    }

    .character-placeholder svg {
      width: 48px;
      height: 48px;
    }

    .motion-generate-row {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 16px;
    }

    .motion-generate-btn {
      padding: 14px 48px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .motion-generate-btn:hover {
      background: var(--accent-hover);
    }

    .motion-generate-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* ===== UGC VIDEO WORKFLOW LAYOUT ===== */
    .ugc-video-layout {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 24px;
      height: 100%;
    }

    .ugc-avatar-section {
      display: flex;
      flex-direction: column;
    }

    .ugc-avatar-upload {
      flex: 1;
      border: 2px dashed var(--border);
      border-radius: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 300px;
      position: relative;
      overflow: hidden;
    }

    .ugc-avatar-upload:hover,
    .ugc-avatar-upload.has-image:hover {
      border-color: var(--accent);
      background: var(--accent-glow);
    }

    .ugc-avatar-upload.has-image {
      border-style: solid;
      padding: 0;
    }

    .ugc-avatar-upload .avatar-preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
    }

    .ugc-avatar-upload .avatar-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      color: var(--text-secondary);
    }

    .ugc-avatar-upload.has-image .avatar-placeholder {
      display: none;
    }

    .ugc-avatar-upload .avatar-placeholder svg {
      width: 48px;
      height: 48px;
    }

    .ugc-script-section {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .ugc-script-textarea {
      flex: 1;
      min-height: 240px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 14px;
      line-height: 1.6;
      resize: none;
    }

    .ugc-script-textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .ugc-script-textarea::placeholder {
      color: var(--text-tertiary);
    }

    .ugc-voice-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .ugc-voice-row label {
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .ugc-voice-search-container {
      flex: 1;
      max-width: 400px;
      position: relative;
    }

    .ugc-voice-search {
      width: 100%;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      color: var(--text-primary);
      font-size: 14px;
    }

    .ugc-voice-search:focus {
      outline: none;
      border-color: var(--accent);
    }

    .ugc-voice-search::placeholder {
      color: var(--text-tertiary);
    }

    .ugc-voice-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 8px 8px;
      z-index: 100;
      display: none;
    }

    .ugc-voice-dropdown.open {
      display: block;
    }

    .ugc-voice-option {
      padding: 10px 14px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
    }

    .ugc-voice-option:last-child {
      border-bottom: none;
    }

    .ugc-voice-option:hover {
      background: var(--bg-hover);
    }

    .ugc-voice-option.selected {
      background: var(--accent-glow);
    }

    .ugc-voice-name {
      font-size: 14px;
      color: var(--text-primary);
    }

    .ugc-voice-category {
      font-size: 11px;
      color: var(--text-tertiary);
      text-transform: uppercase;
    }

    .ugc-voice-preview-btn {
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
    }

    .ugc-voice-preview-btn:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .ugc-voice-select {
      flex: 1;
      max-width: 300px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
    }

    .ugc-voice-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .ugc-generate-btn {
      padding: 12px 32px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .ugc-generate-btn:hover {
      background: var(--accent-hover);
    }

    .ugc-generate-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .workflow-upload-zone {
      border: 2px dashed var(--border);
      border-radius: 16px;
      padding: 48px 32px;
      text-align: center;
      transition: all 0.2s ease;
      cursor: pointer;
      margin-bottom: 24px;
    }

    .workflow-upload-zone:hover,
    .workflow-upload-zone.dragover {
      border-color: var(--accent);
      background: var(--accent-glow);
    }

    .workflow-upload-icon {
      width: 64px;
      height: 64px;
      background: var(--bg-tertiary);
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px;
    }

    .workflow-upload-icon svg {
      width: 32px;
      height: 32px;
      color: var(--text-secondary);
    }

    .workflow-upload-zone:hover .workflow-upload-icon,
    .workflow-upload-zone.dragover .workflow-upload-icon {
      background: var(--accent);
    }

    .workflow-upload-zone:hover .workflow-upload-icon svg,
    .workflow-upload-zone.dragover .workflow-upload-icon svg {
      color: white;
    }

    .workflow-upload-text {
      font-size: 15px;
      color: var(--text-primary);
      margin-bottom: 8px;
    }

    .workflow-upload-hint {
      font-size: 13px;
      color: var(--text-tertiary);
    }

    .workflow-upload-preview {
      display: none;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 16px;
    }

    .workflow-upload-preview.has-files {
      display: flex;
    }

    .workflow-preview-item {
      position: relative;
      width: 80px;
      height: 80px;
      border-radius: 8px;
      overflow: hidden;
      background: var(--bg-tertiary);
    }

    .workflow-preview-item img,
    .workflow-preview-item video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .workflow-preview-remove {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 20px;
      height: 20px;
      background: rgba(0,0,0,0.7);
      border: none;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .workflow-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
      flex: 1;
    }

    .workflow-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .workflow-field label {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .workflow-field input,
    .workflow-field textarea {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 14px;
      font-size: 14px;
      color: var(--text-primary);
      transition: border-color 0.2s ease;
    }

    .workflow-field input:focus,
    .workflow-field textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .workflow-field textarea {
      resize: vertical;
      min-height: 100px;
    }

    .workflow-submit-btn {
      background: var(--accent);
      border: none;
      border-radius: 12px;
      padding: 14px 24px;
      font-size: 15px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: background 0.2s ease;
      margin-top: auto;
    }

    .workflow-submit-btn:hover {
      background: var(--accent-hover);
    }

    .workflow-submit-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Right - results panel */
    .workflow-results {
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      padding: 16px;
      overflow-y: auto;
    }

    .workflow-results-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .workflow-results-count {
      background: var(--bg-tertiary);
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 12px;
    }

    .workflow-results-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    .workflow-result-item {
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      aspect-ratio: 9 / 16;
      background: var(--bg-tertiary);
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .workflow-result-item:hover {
      transform: scale(1.02);
    }

    .workflow-result-item img,
    .workflow-result-item video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .workflow-result-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .workflow-result-loading .grid-item-spinner {
      width: 24px;
      height: 24px;
    }

    .workflow-result-video {
      aspect-ratio: 9 / 16;
      display: flex;
      flex-direction: column;
    }

    .workflow-result-video video {
      flex: 1;
      min-height: 0;
    }

    .workflow-download-link {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px;
      background: var(--accent);
      color: white;
      text-decoration: none;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.2s ease;
    }

    .workflow-download-link:hover {
      background: var(--accent-hover);
    }

    .workflow-results-empty {
      text-align: center;
      padding: 40px 16px;
      color: var(--text-tertiary);
      font-size: 13px;
    }

    .workflow-results-empty svg {
      width: 48px;
      height: 48px;
      color: var(--border);
      margin-bottom: 12px;
    }

    /* ===== DYNAMIC WORKFLOW FORMS ===== */
    .workflow-loading {
      color: var(--text-dim);
      padding: 16px 12px;
      font-size: 13px;
    }
    .dynamic-wf-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 4px 0;
    }
    .dynamic-wf-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .dynamic-wf-field label {
      font-size: 13px;
      color: var(--text-dim);
      font-weight: 500;
    }
    .dynamic-wf-field label .wf-required {
      color: var(--accent);
      margin-left: 2px;
    }
    .dynamic-wf-field input[type="text"],
    .dynamic-wf-field input[type="number"],
    .dynamic-wf-field textarea,
    .dynamic-wf-field select {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 12px;
      color: var(--text);
      font-size: 14px;
      outline: none;
      transition: border-color 0.15s;
    }
    .dynamic-wf-field input:focus,
    .dynamic-wf-field textarea:focus,
    .dynamic-wf-field select:focus {
      border-color: var(--accent);
    }
    .dynamic-wf-field textarea {
      min-height: 100px;
      resize: vertical;
    }
    .dynamic-wf-field .wf-hint {
      font-size: 11px;
      color: var(--text-dim);
      opacity: 0.7;
    }
    .dynamic-wf-field .wf-image-upload {
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 32px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
      color: var(--text-dim);
    }
    .dynamic-wf-field .wf-image-upload:hover {
      border-color: var(--accent);
      background: rgba(255,255,255,0.02);
    }
    .dynamic-wf-field .wf-image-upload.has-image {
      border-style: solid;
      border-color: var(--accent);
      padding: 8px;
    }
    .dynamic-wf-field .wf-image-upload img {
      max-height: 180px;
      border-radius: 8px;
    }
    .dynamic-wf-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 20px;
    }
    .dynamic-wf-run-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 28px;
      background: var(--accent);
      color: #000;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.15s;
    }
    .dynamic-wf-run-btn:hover { opacity: 0.85; }
    .dynamic-wf-run-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .dynamic-wf-cost {
      font-size: 12px;
      color: var(--text-dim);
    }
    .dynamic-wf-status {
      margin-top: 16px;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
    }
    .dynamic-wf-status.running {
      background: rgba(99,102,241,0.1);
      color: #818cf8;
      border: 1px solid rgba(99,102,241,0.2);
    }
    .dynamic-wf-status.done {
      background: rgba(34,197,94,0.1);
      color: #4ade80;
      border: 1px solid rgba(34,197,94,0.2);
    }
    .dynamic-wf-status.error {
      background: rgba(239,68,68,0.1);
      color: #f87171;
      border: 1px solid rgba(239,68,68,0.2);
    }
    .dynamic-wf-output {
      margin-top: 16px;
    }
    .dynamic-wf-output img,
    .dynamic-wf-output video {
      max-width: 100%;
      border-radius: 12px;
      border: 1px solid var(--border);
    }
    /* Starred workflow sidebar items */
    .workflow-item .workflow-star {
      margin-left: auto;
      font-size: 14px;
      opacity: 0.5;
      cursor: pointer;
    }
    .workflow-item .workflow-star:hover { opacity: 1; }
    .workflow-item .workflow-star.active { opacity: 1; color: #fbbf24; }

    /* Legacy shortcut styles (hidden, kept for compatibility) */
    .shortcuts-grid {
      display: none;
    }

    .shortcut-card {
      display: none;
    }

    .shortcut-icon {
      width: 48px;
      height: 48px;
      background: var(--accent-glow);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
    }

    .shortcut-icon svg {
      width: 24px;
      height: 24px;
      color: var(--accent);
    }

    .shortcut-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .shortcut-desc {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    /* ===== VIDEO QUEUE ===== */
    .video-queue-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 12px;
    }

    @media (max-width: 1600px) {
      .video-queue-grid { grid-template-columns: repeat(5, 1fr); }
    }
    @media (max-width: 1400px) {
      .video-queue-grid { grid-template-columns: repeat(4, 1fr); }
    }
    @media (max-width: 1100px) {
      .video-queue-grid { grid-template-columns: repeat(3, 1fr); }
    }
    @media (max-width: 800px) {
      .video-queue-grid { grid-template-columns: repeat(2, 1fr); }
    }

    .video-queue-item {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      transition: all 0.2s ease;
    }

    .video-queue-item.generating {
      border-color: var(--accent);
    }

    .video-queue-item:hover {
      border-color: var(--accent);
    }

    .video-queue-preview {
      position: relative;
      aspect-ratio: 9 / 16;
      background: var(--bg-secondary);
      border-radius: 8px;
      overflow: hidden;
    }

    .video-queue-thumb {
      width: 100%;
      height: 100%;
      aspect-ratio: 9 / 16;
      border-radius: 8px;
      object-fit: cover;
      background: var(--bg-secondary);
    }

    .video-queue-thumb.generating-blur {
      filter: blur(8px);
      opacity: 0.6;
    }

    .video-generating-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      color: white;
      font-size: 14px;
      font-weight: 500;
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .video-queue-preview {
      position: relative;
    }

    .video-queue-meta {
      padding: 12px;
      border-top: 1px solid var(--border);
    }

    .video-queue-status-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .video-queue-remove {
      margin-left: auto;
      background: none;
      border: none;
      color: var(--text-tertiary);
      font-size: 18px;
      cursor: pointer;
      padding: 0 4px;
    }

    .video-queue-remove:hover {
      color: #dc2626;
    }

    .video-queue-info {
      flex: 1;
      min-width: 0;
    }

    .video-queue-prompt {
      font-size: 13px;
      color: var(--text-primary);
      line-height: 1.5;
      margin-bottom: 8px;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .video-queue-prompt-input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 13px;
      color: var(--text-primary);
      resize: none;
      font-family: inherit;
    }

    .video-queue-prompt-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .video-queue-status {
      font-size: 12px;
      color: var(--text-tertiary);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .video-queue-status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-tertiary);
    }

    .video-queue-status-dot.pending { background: #f59e0b; }
    .video-queue-status-dot.generating { background: var(--accent); animation: pulse 1s infinite; }
    .video-queue-status-dot.complete { background: #22c55e; }
    .video-queue-status-dot.error { background: #ef4444; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .video-queue-actions {
      display: flex;
      gap: 8px;
      padding: 12px;
      border-top: 1px solid var(--border);
    }

    .video-queue-btn {
      flex: 1;
      padding: 10px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .video-queue-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .video-queue-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .video-queue-btn.primary:hover {
      background: var(--accent-hover);
    }

    .video-queue-btn svg {
      width: 14px;
      height: 14px;
    }

    /* ===== SECTIONS ===== */
    .section {
      display: none;
    }

    .section.active {
      display: block;
    }

    /* ===== VIDEO PROMPT POPUP ===== */
    .video-prompt-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(4px);
    }

    .video-prompt-popup {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 440px;
    }

    .video-prompt-popup h3 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .video-prompt-hint {
      color: var(--text-secondary);
      font-size: 14px;
      margin-bottom: 16px;
    }

    .video-prompt-input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      color: var(--text-primary);
      font-size: 14px;
      margin-bottom: 16px;
    }

    .video-prompt-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .video-prompt-input::placeholder {
      color: var(--text-tertiary);
    }

    .video-prompt-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .video-prompt-cancel {
      padding: 10px 20px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .video-prompt-cancel:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .video-prompt-confirm {
      padding: 10px 20px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .video-prompt-confirm:hover {
      background: var(--accent-hover);
    }

    /* ===== CONTEXT PROFILE MODAL ===== */
    .context-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
    }

    .context-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 500px;
    }

    .context-modal h2 {
      margin: 0 0 8px 0;
      font-size: 20px;
    }

    .context-name-input {
      width: 100%;
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: white;
      font-size: 14px;
      margin-bottom: 12px;
    }

    .context-vision-input {
      width: 100%;
      height: 160px;
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: white;
      font-size: 14px;
      resize: vertical;
      font-family: inherit;
    }

    .context-vision-input::placeholder {
      color: var(--text-tertiary);
    }

    .context-modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    .context-cancel-btn {
      padding: 10px 20px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .context-cancel-btn:hover {
      background: var(--bg-tertiary);
    }

    .context-generate-btn {
      padding: 10px 20px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-weight: 500;
    }

    .context-generate-btn:hover {
      background: var(--accent-hover);
    }

    .context-generate-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* ===== WORKFLOW MODALS ===== */
    .workflow-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
    }

    .workflow-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 28px;
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
    }

    .workflow-modal-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
    }

    .workflow-modal h2 {
      margin: 0 0 8px 0;
      font-size: 22px;
    }

    .workflow-desc {
      color: var(--text-secondary);
      font-size: 14px;
      margin-bottom: 20px;
    }

    .workflow-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .workflow-input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .workflow-input-group label {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .workflow-input-group input,
    .workflow-input-group textarea {
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: white;
      font-size: 14px;
    }

    .workflow-input-group textarea {
      min-height: 120px;
      resize: vertical;
      font-family: inherit;
    }

    .workflow-input-group input[type="file"] {
      padding: 10px;
    }

    .workflow-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 8px;
    }

    .workflow-cancel {
      padding: 10px 20px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .workflow-submit {
      padding: 10px 24px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-weight: 500;
    }

    .workflow-submit:hover {
      background: var(--accent-hover);
    }

    .workflow-status {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      color: var(--text-secondary);
    }

    .workflow-results {
      margin-top: 16px;
    }

    .workflow-output-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
    }

    /* ===== BULK I2V TERMINAL MODE ===== */
    .prompt-bar.bulk-mode {
      max-width: 900px;
      border-color: var(--accent);
      box-shadow: 0 0 0 4px var(--accent-glow), 0 0 40px rgba(249, 115, 22, 0.1);
    }

    .bulk-terminal {
      display: none;
      flex-direction: column;
      gap: 0;
      background: #0a0a0f;
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 8px;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
      position: relative;
    }

    .bulk-terminal::before {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.03) 2px,
        rgba(0, 0, 0, 0.03) 4px
      );
      pointer-events: none;
      z-index: 1;
    }

    .prompt-bar.bulk-mode .bulk-terminal {
      display: flex;
    }

    .prompt-bar.bulk-mode .prompt-input-row,
    .prompt-bar.bulk-mode .prompt-options {
      display: none;
    }

    .bulk-terminal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: #111116;
      border-bottom: 1px solid #1a1a22;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .bulk-terminal-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      color: #22c55e;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .bulk-terminal-title::before {
      content: '';
      color: #22c55e;
      animation: blink-dot 1.5s infinite;
    }

    @keyframes blink-dot {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    .bulk-terminal-close {
      background: none;
      border: none;
      color: var(--text-tertiary);
      font-size: 18px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.15s;
    }

    .bulk-terminal-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #ef4444;
    }

    .bulk-terminal-body {
      max-height: 320px;
      overflow-y: auto;
      padding: 8px 0;
    }

    .bulk-terminal-body::-webkit-scrollbar {
      width: 6px;
    }

    .bulk-terminal-body::-webkit-scrollbar-track {
      background: transparent;
    }

    .bulk-terminal-body::-webkit-scrollbar-thumb {
      background: #2a2a35;
      border-radius: 3px;
    }

    .bulk-line {
      display: grid;
      grid-template-columns: 48px 1fr auto;
      gap: 12px;
      align-items: center;
      padding: 8px 14px;
      border-bottom: 1px solid #15151c;
      transition: background 0.15s;
      position: relative;
      z-index: 2;
    }

    .bulk-line:last-child {
      border-bottom: none;
    }

    .bulk-line:hover {
      background: rgba(255, 255, 255, 0.02);
    }

    .bulk-line-thumb {
      width: 48px;
      height: 48px;
      border-radius: 6px;
      overflow: hidden;
      background: #1a1a22;
      flex-shrink: 0;
    }

    .bulk-line-thumb img,
    .bulk-line-thumb video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .bulk-line-content {
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .bulk-line-filename {
      font-size: 11px;
      color: #6b6b7a;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .bulk-line-filename span {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .bulk-line-arrow {
      color: #f97316;
      flex-shrink: 0;
    }

    .bulk-line-prompt {
      font-size: 13px;
      line-height: 1.4;
      color: #22c55e;
      min-height: 18px;
      position: relative;
      word-break: break-word;
    }

    .bulk-line-prompt.typing::after {
      content: '';
      color: var(--accent);
      animation: cursor-blink 0.8s infinite;
      margin-left: 2px;
    }

    .bulk-line-prompt.analyzing {
      color: #eab308;
    }

    .bulk-line-prompt.error {
      color: #ef4444;
    }

    @keyframes cursor-blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .bulk-line-status {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .bulk-line-badge {
      font-size: 10px;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .bulk-line-badge.analyzing {
      background: rgba(234, 179, 8, 0.15);
      color: #eab308;
    }

    .bulk-line-badge.ready {
      background: rgba(34, 197, 94, 0.15);
      color: #22c55e;
    }

    .bulk-line-badge.generating {
      background: rgba(249, 115, 22, 0.15);
      color: #f97316;
      animation: pulse-badge 1.5s infinite;
    }

    .bulk-line-badge.done {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .bulk-line-badge.error {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
    }

    @keyframes pulse-badge {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .bulk-line-action {
      background: none;
      border: 1px solid #2a2a35;
      color: var(--text-secondary);
      width: 28px;
      height: 28px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .bulk-line-action:hover {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .bulk-line-action.play {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .bulk-line-action svg {
      width: 14px;
      height: 14px;
    }

    .bulk-terminal-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      background: #111116;
      border-top: 1px solid #1a1a22;
      gap: 12px;
    }

    .bulk-footer-stats {
      font-size: 11px;
      color: var(--text-tertiary);
      display: flex;
      gap: 16px;
    }

    .bulk-footer-stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .bulk-footer-stat .count {
      color: var(--text-primary);
      font-weight: 600;
    }

    .bulk-footer-actions {
      display: flex;
      gap: 8px;
    }

    .bulk-footer-btn {
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
    }

    .bulk-footer-btn.secondary {
      background: #1a1a22;
      border: 1px solid #2a2a35;
      color: var(--text-secondary);
    }

    .bulk-footer-btn.secondary:hover {
      background: #22222c;
      color: var(--text-primary);
    }

    .bulk-footer-btn.primary {
      background: var(--accent);
      border: none;
      color: white;
    }

    .bulk-footer-btn.primary:hover {
      background: var(--accent-hover);
    }

    .bulk-footer-btn.primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .bulk-footer-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Progress bar for overall generation */
    .bulk-progress {
      height: 3px;
      background: #1a1a22;
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
    }

    .bulk-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #22c55e);
      width: 0%;
      transition: width 0.3s ease;
    }

    /* Video modal for preview */
    .bulk-video-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(8px);
    }

    .bulk-video-modal video {
      max-width: 90vw;
      max-height: 80vh;
      border-radius: 12px;
    }

    .bulk-video-modal-close {
      position: absolute;
      top: 20px;
      right: 20px;
      background: var(--bg-tertiary);
      border: none;
      color: white;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
    }

    .bulk-video-modal-download {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--accent);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }
  </style>
</head>
<body>

  <!-- Navigation -->
  <nav class="nav">
    <div class="nav-logo">
      <img src="/aditor-logo.png" alt="Aditor" class="nav-logo-img">
      <span>Aditor Studio</span>
    </div>
    
    <div class="nav-tabs">
      <button class="nav-tab active" data-tab="images">Images</button>
      <button class="nav-tab" data-tab="videos">Videos</button>
      <button class="nav-tab" data-tab="shortcuts">Shortcuts</button>
    </div>
    
    <div class="nav-profile" id="nav-profile" style="display:flex;align-items:center;gap:10px;position:relative;">
      <span id="tenant-name" style="font-size:13px;color:#8b8b9e;"></span>
      <div id="user-avatar" style="width:36px;height:36px;border-radius:50%;background:#232330;overflow:hidden;cursor:pointer;display:none;border:2px solid #232330;transition:border-color 0.2s;" onclick="toggleUserMenu()">
        <img id="user-pic" style="width:100%;height:100%;object-fit:cover;" src="" alt="">
      </div>
      <!-- Enhanced User Dropdown Menu -->
      <div id="user-menu" style="display:none;position:absolute;top:50px;right:0;background:#0f0f14;border:1px solid #232330;border-radius:12px;padding:8px;min-width:200px;z-index:200;box-shadow:0 4px 20px rgba(0,0,0,0.5);">
        <div id="user-info" style="padding:12px;border-bottom:1px solid #232330;margin-bottom:4px;">
          <div id="user-name" style="font-size:14px;font-weight:500;color:#fff;margin-bottom:2px;"></div>
          <div id="user-email" style="font-size:11px;color:#8b8b9e;"></div>
        </div>
        <button onclick="openAvatarPicker()" style="width:100%;padding:10px 12px;background:none;border:none;color:#fff;font-size:13px;text-align:left;cursor:pointer;border-radius:6px;display:flex;align-items:center;gap:8px;transition:background 0.15s;">
          <span></span> Switch Avatar
        </button>
        <button onclick="openBrandsPage()" style="width:100%;padding:10px 12px;background:none;border:none;color:#fff;font-size:13px;text-align:left;cursor:pointer;border-radius:6px;display:flex;align-items:center;gap:8px;transition:background 0.15s;">
          <span></span> My Brands
        </button>
        <div style="border-top:1px solid #232330;margin:4px 0;"></div>
        <button onclick="signOut()" style="width:100%;padding:10px 12px;background:none;border:none;color:#ef4444;font-size:13px;text-align:left;cursor:pointer;border-radius:6px;display:flex;align-items:center;gap:8px;transition:background 0.15s;">
          <span></span> Logout
        </button>
      </div>
    </div>
  </nav>
  <style>
    #user-menu.show { display: block !important; }
  </style>

  <!-- Main Content -->
  <main class="main">
    
    <!-- Images Section -->
    <section id="images-section" class="section active">
      <div class="grid-container">
        <div class="grid-header">
          <span class="grid-title">Your Images</span>
          <span class="grid-count" id="image-count">0 images</span>
        </div>
        
        <div class="masonry-grid" id="image-grid">
          <!-- Images will be loaded here -->
        </div>

        <div class="empty-state" id="empty-state">
          <div class="empty-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
            </svg>
          </div>
          <h3 class="empty-title">No images yet</h3>
          <p class="empty-desc">Start creating! Describe what you want in the prompt bar below, or drag reference images to guide the generation.</p>
          <button onclick="recoverFromServer()" style="margin-top: 16px; padding: 10px 20px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-secondary); cursor: pointer;">Recover images from server</button>
        </div>
      </div>
    </section>

    <!-- Videos Section -->
    <section id="videos-section" class="section">
      <div class="grid-container">
        <div class="grid-header">
          <span class="grid-title">Video Queue</span>
          <span class="grid-count" id="video-count">0 videos</span>
        </div>
        
        <div id="video-queue-container">
          <!-- Video queue items will be rendered here -->
        </div>

        <div class="empty-state" id="video-empty-state">
          <div class="empty-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
            </svg>
          </div>
          <h3 class="empty-title">No videos queued</h3>
          <p class="empty-desc">Click the  on any image to add it to the video queue. We'll auto-generate a motion prompt and start rendering with Kling 3.</p>
        </div>
      </div>
    </section>

    <!-- Workflow Studio (Shortcuts Section) -->
    <section id="shortcuts-section" class="section">
      <div class="workflow-studio">
        <!-- Left Sidebar - Workflow List (dynamically loaded from /api/workflows) -->
        <div class="workflow-sidebar">
          <div class="workflow-sidebar-title"> Workflows</div>
          <div id="workflow-sidebar-list">
            <!-- Populated dynamically from starred workflows -->
            <div class="workflow-loading">Loading workflows...</div>
          </div>
          <div class="workflow-divider">Legacy</div>
          <div class="workflow-item" data-workflow="script-to-video">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Script  UGC Video</div>
              <div class="workflow-item-desc">Script + avatar  full video</div>
            </div>
          </div>
          <div class="workflow-item" data-workflow="product-easy-wins">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Product Easy Wins</div>
              <div class="workflow-item-desc">1 image  9 lifestyle shots</div>
            </div>
          </div>
          <div class="workflow-item" data-workflow="motion-transfer">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Motion Transfer</div>
              <div class="workflow-item-desc">Image + video  animate</div>
            </div>
          </div>
        </div>

        <!-- Center - Active Workflow Input -->
        <div class="workflow-main" id="workflow-main">
          <div class="workflow-header">
            <h2 id="workflow-title">Script  UGC Video</h2>
            <p id="workflow-description">Upload avatar, paste script, select voice  get UGC video</p>
          </div>

          <!-- Dynamic Workflow Form (loaded from starred workflows JSON) -->
          <div id="dynamic-workflow-layout" style="display: none;">
            <div id="dynamic-workflow-form" class="dynamic-wf-form"></div>
            <div class="dynamic-wf-actions">
              <button type="button" class="dynamic-wf-run-btn" id="dynamic-wf-run-btn">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="18" height="18"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/></svg>
                Generate
              </button>
              <span class="dynamic-wf-cost" id="dynamic-wf-cost"></span>
            </div>
            <div id="dynamic-wf-status" class="dynamic-wf-status" style="display:none;"></div>
            <div id="dynamic-wf-output" class="dynamic-wf-output"></div>
          </div>

          <!-- UGC Video Layout (default for script-to-video) -->
          <div class="ugc-video-layout" id="ugc-video-layout">
            <div class="ugc-avatar-section">
              <div class="ugc-avatar-upload" id="ugc-avatar-upload">
                <div class="avatar-placeholder">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                  </svg>
                  <span>Drop avatar image</span>
                </div>
                <input type="file" id="ugc-avatar-input" accept="image/*" hidden>
              </div>
            </div>
            
            <div class="ugc-script-section">
              <textarea class="ugc-script-textarea" id="ugc-script" placeholder="Paste your script here..."></textarea>
              
              <div class="ugc-voice-row">
                <label>Voice</label>
                <div class="ugc-voice-search-container">
                  <input type="text" class="ugc-voice-search" id="ugc-voice-search" placeholder="Search voices..." autocomplete="off">
                  <input type="hidden" id="ugc-voice" value="">
                  <div class="ugc-voice-dropdown" id="ugc-voice-dropdown"></div>
                </div>
                <button type="button" class="ugc-generate-btn" id="ugc-generate-btn">Generate</button>
              </div>
            </div>
          </div>

          <!-- Motion Transfer Layout (webcam + character) -->
          <div class="motion-transfer-layout" id="motion-transfer-layout" style="display: none;">
            <div class="webcam-section">
              <div class="webcam-container" id="webcam-container">
                <video class="webcam-video" id="webcam-video" autoplay muted playsinline style="display: none;"></video>
                <video class="webcam-preview" id="webcam-playback" controls style="display: none;"></video>
                <div class="webcam-placeholder" id="webcam-placeholder">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                  </svg>
                  <span>Click Start to enable webcam</span>
                </div>
                <div class="webcam-timer" id="webcam-timer"> REC 0:00</div>
              </div>
              <div class="webcam-controls">
                <button type="button" class="webcam-btn webcam-btn-start" id="webcam-start-btn">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="18" height="18">
                    <circle cx="12" cy="12" r="10" stroke-width="2"/>
                    <circle cx="12" cy="12" r="4" fill="currentColor"/>
                  </svg>
                  Start Recording
                </button>
                <button type="button" class="webcam-btn webcam-btn-stop" id="webcam-stop-btn" style="display: none;">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="18" height="18">
                    <rect x="6" y="6" width="12" height="12" fill="currentColor"/>
                  </svg>
                  Stop
                </button>
                <button type="button" class="webcam-btn webcam-btn-retry" id="webcam-retry-btn" style="display: none;">
                   Re-record
                </button>
              </div>
            </div>
            
            <div class="character-section">
              <div class="character-upload" id="character-upload">
                <div class="character-placeholder">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                  </svg>
                  <span>Drop character image</span>
                </div>
                <input type="file" id="character-input" accept="image/*" hidden>
              </div>
              <div class="motion-generate-row">
                <button type="button" class="motion-generate-btn" id="motion-generate-btn">Generate Motion Transfer</button>
              </div>
            </div>
          </div>

          <!-- Generic workflow upload zone (for other workflows) -->
          <div class="workflow-upload-zone" id="workflow-upload-zone" style="display: none;">
            <div class="workflow-upload-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
              </svg>
            </div>
            <div class="workflow-upload-text">Drop files here or click to upload</div>
            <div class="workflow-upload-hint" id="workflow-upload-hint">Accepts images and videos</div>
            <input type="file" id="workflow-file-input" multiple hidden>
            <div class="workflow-upload-preview" id="workflow-upload-preview"></div>
          </div>

          <!-- Generic workflow form (for other workflows) -->
          <form class="workflow-form" id="workflow-form" style="display: none;">
            <div class="workflow-field" id="url-field" style="display: none;">
              <label for="workflow-url">Product URL</label>
              <input type="url" id="workflow-url" placeholder="https://example.com/product">
            </div>

            <div class="workflow-field" id="script-field" style="display: none;">
              <label for="workflow-script">Script</label>
              <textarea id="workflow-script" placeholder="Paste your script here..."></textarea>
            </div>

            <button type="submit" class="workflow-submit-btn" id="workflow-submit">Generate</button>
          </form>
        </div>

        <!-- Right - Results Panel -->
        <div class="workflow-results">
          <div class="workflow-results-title">
            Results
            <span class="workflow-results-count" id="workflow-results-count">0</span>
          </div>
          
          <div class="workflow-results-empty" id="workflow-results-empty">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
            </svg>
            <div>Results will appear here</div>
          </div>

          <div class="workflow-results-grid" id="workflow-results-grid"></div>
        </div>
      </div>
    </section>

  </main>

  <!-- Prompt Bar -->
  <div class="prompt-container">
    <div class="prompt-bar" id="prompt-bar">
      <!-- Bulk I2V Terminal (hidden by default) -->
      <div class="bulk-terminal" id="bulk-terminal">
        <div class="bulk-terminal-header">
          <div class="bulk-terminal-title">
            <span>BULK I2V</span>
          </div>
          <button class="bulk-terminal-close" id="bulk-close" title="Exit bulk mode"></button>
        </div>
        <div class="bulk-terminal-body" id="bulk-terminal-body">
          <!-- Lines will be rendered here -->
        </div>
        <div class="bulk-terminal-footer">
          <div class="bulk-footer-stats" id="bulk-stats">
            <div class="bulk-footer-stat"><span class="count" id="bulk-count-total">0</span> images</div>
            <div class="bulk-footer-stat"><span class="count" id="bulk-count-ready">0</span> ready</div>
            <div class="bulk-footer-stat"><span class="count" id="bulk-count-done">0</span> done</div>
          </div>
          <div class="bulk-footer-actions">
            <select class="prompt-select" id="bulk-duration" style="font-size: 11px; padding: 6px 10px;">
              <option value="5">5s</option>
              <option value="10">10s</option>
            </select>
            <button class="bulk-footer-btn secondary" id="bulk-analyze-btn">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg>
              Analyze
            </button>
            <button class="bulk-footer-btn primary" id="bulk-generate-btn" disabled>
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
              Generate All
            </button>
          </div>
        </div>
        <div class="bulk-progress">
          <div class="bulk-progress-bar" id="bulk-progress-bar"></div>
        </div>
      </div>

      <div class="prompt-references" id="prompt-references">
        <!-- Reference images appear here -->
      </div>
      
      <div class="prompt-input-row">
        <input type="text" class="prompt-input" id="prompt-input" placeholder="Describe your image... or drop images here for bulk video">
        <button class="prompt-btn" id="generate-btn">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3l14 9-14 9V3z"/>
          </svg>
        </button>
      </div>
      
      <div class="prompt-options">
        <button class="prompt-option active" id="gen-mode-btn" title="Click to switch mode"> B-roll</button>
        <select class="prompt-select" id="aspect-ratio">
          <option value="9:16" selected>9:16 vertical</option>
          <option value="1:1">1:1 square</option>
          <option value="16:9">16:9 horizontal</option>
          <option value="4:5">4:5 portrait</option>
        </select>
        <select class="prompt-select" id="model-select">
          <option value="nano-banana-pro" selected>Nano Banana Pro</option>
          <option value="seedream">Seedream 4</option>
          <option value="z-image">Z Image</option>
        </select>
        <select class="prompt-select" id="gen-count" title="Number of images to generate">
          <option value="1">1</option>
          <option value="2" selected>2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="6">6</option>
          <option value="8">8</option>
        </select>
        <span style="color: var(--text-tertiary); font-size: 12px; margin-left: 8px;"></span>
        <select class="prompt-select" id="video-model-select" title="Default video model for starred images">
          <option value="kling3" selected>Kling 3</option>
          <option value="seedance2">Seedance 2</option>
        </select>
      </div>
    </div>
  </div>

  <!-- Hidden file input for bulk upload -->
  <input type="file" id="bulk-file-input" multiple accept="image/*" style="display:none">

  <!-- Fullscreen Modal -->
  <div class="modal-overlay" id="modal">
    <div class="modal-content">
      <button class="modal-close" id="modal-close"></button>
      <img class="modal-image" id="modal-image" src="">
      <div class="modal-actions">
        <button class="modal-btn" id="modal-variations">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM14 5a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1V5zM4 15a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1v-4zM14 15a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/>
          </svg>
          4 Variations
        </button>
        <button class="modal-btn" id="modal-reference">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"/>
          </svg>
          Reference
        </button>
        <button class="modal-btn" id="modal-reuse">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
          </svg>
          Reuse Prompt
        </button>
        <button class="modal-btn" id="modal-video">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
          </svg>
           Video
        </button>
        <button class="modal-btn primary" id="modal-download">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
          </svg>
          Download
        </button>
      </div>
      <div class="modal-meta" id="modal-meta">
        <!-- Prompt and settings will appear here -->
      </div>
    </div>
  </div>

  <!-- Generating indicator -->
  <div class="generating" id="generating">
    <div class="generating-spinner"></div>
    <span class="generating-text">Generating...</span>
  </div>

  <script data-cfasync="false">
    // ===== STATE =====
    let images = [];
    let references = [];
    let currentImage = null;
    let selectedRatio = '9:16';
    let selectedModel = 'nano-banana-pro';
    let genMode = 'broll'; // 'broll' | 'talking' | 'raw'
    let videoQueue = []; // {id, image, prompt, status: 'pending'|'generating'|'complete'|'error', videoUrl}

    // ===== PERSISTENCE =====
    const STORAGE_KEY = 'aditor_studio_images';
    
    function loadSavedImages() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          images = JSON.parse(saved);
          // Clean up any stuck loading placeholders from previous sessions
          const beforeCount = images.length;
          images = images.filter(img => !img.loading);
          if (images.length < beforeCount) {
            console.log(`Cleaned ${beforeCount - images.length} stuck loading items`);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(images));
          }
          console.log(`Loaded ${images.length} images from storage`);
        }
      } catch (e) {
        console.error('Failed to load images:', e);
      }
      
      // If no images in localStorage, try to load from server
      if (images.length === 0) {
        loadRecentFromServer();
      }
    }
    
    async function loadRecentFromServer() {
      try {
        const response = await fetch('/api/outputs/recent');
        if (response.ok) {
          const data = await response.json();
          if (data.images && data.images.length > 0) {
            images = data.images;
            saveImages();
            renderGrid();
            console.log(`Loaded ${images.length} recent images from server`);
          }
        }
      } catch (e) {
        console.log('No recent images from server');
      }
    }
    
    function saveImages() {
      try {
        // Keep last 100 images max
        const toSave = images.slice(0, 100);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
      } catch (e) {
        console.error('Failed to save images:', e);
      }
    }

    // Recovery function - loads all images from server
    window.recoverFromServer = async function() {
      try {
        const response = await fetch('/api/outputs/recent?limit=100');
        if (response.ok) {
          const data = await response.json();
          if (data.images && data.images.length > 0) {
            images = data.images;
            saveImages();
            renderGrid();
            console.log(` Recovered ${images.length} images from server`);
            alert(`Recovered ${images.length} images!`);
          } else {
            alert('No images found on server');
          }
        }
      } catch (e) {
        console.error('Recovery failed:', e);
        alert('Failed to recover images: ' + e.message);
      }
    };
    
    // Load on startup
    loadSavedImages();

    // ===== DOM =====
    const imageGrid = document.getElementById('image-grid');
    const imageCount = document.getElementById('image-count');
    const emptyState = document.getElementById('empty-state');
    const promptBar = document.getElementById('prompt-bar');
    const promptInput = document.getElementById('prompt-input');
    const promptReferences = document.getElementById('prompt-references');
    const generateBtn = document.getElementById('generate-btn');
    const modal = document.getElementById('modal');
    const modalImage = document.getElementById('modal-image');
    const generating = document.getElementById('generating');

    // ===== TAB SWITCHING =====
    document.querySelectorAll('.nav-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tab.dataset.tab}-section`).classList.add('active');
        
        // Handle prompt bar visibility based on tab and workflow
        const promptBar = document.querySelector('.prompt-container');
        if (promptBar) {
          if (tab.dataset.tab === 'bulk-i2v') {
            promptBar.style.display = 'none';
          } else if (tab.dataset.tab === 'shortcuts') {
            const config = workflowConfigs[currentWorkflow];
            promptBar.style.display = config?.customLayout ? 'none' : 'block';
          } else {
            promptBar.style.display = 'block';
          }
        }
        
        // Refresh and render bulk i2v jobs when switching to Videos tab
        if (tab.dataset.tab === 'videos' && typeof renderBulkJobsInVideoTab === 'function') {
          // Fetch fresh data from server
          fetch('/api/bulk-i2v/jobs?limit=20')
            .then(res => res.json())
            .then(data => {
              if (data.batches && data.batches.length > 0) {
                window._bulkVideoTabItems = [];
                for (const batch of data.batches) {
                  for (const j of batch.jobs) {
                    if (j.status === 'done' || j.status === 'failed' || j.status === 'generating') {
                      window._bulkVideoTabItems.push({
                        id: j.id,
                        batchId: batch.id,
                        url: j.imageUrl || '',
                        filename: j.imageUrl ? j.imageUrl.split('/').pop() : '',
                        prompt: j.prompt || '',
                        displayedPrompt: j.prompt || '',
                        status: j.status === 'failed' ? 'error' : j.status,
                        taskId: j.id,
                        videoUrl: j.videoUrl || null
                      });
                    }
                  }
                }
              }
              renderBulkJobsInVideoTab();
              updateVideoTabBadge();
            })
            .catch(() => renderBulkJobsInVideoTab());
        }
      });
    });

    // ===== PROMPT OPTIONS =====
    const aspectRatioSelect = document.getElementById('aspect-ratio');
    const modelSelect = document.getElementById('model-select');
    
    aspectRatioSelect.addEventListener('change', (e) => {
      selectedRatio = e.target.value;
    });
    
    modelSelect.addEventListener('change', (e) => {
      selectedModel = e.target.value;
    });

    // Generation mode toggle (click to cycle)
    const genModeBtn = document.getElementById('gen-mode-btn');
    const genModes = ['broll', 'talking', 'raw'];
    const genModeLabels = {
      'broll': ' B-roll',
      'talking': ' Talking Head', 
      'raw': ' Raw'
    };
    
    genModeBtn.addEventListener('click', () => {
      const currentIndex = genModes.indexOf(genMode);
      const nextIndex = (currentIndex + 1) % genModes.length;
      genMode = genModes[nextIndex];
      genModeBtn.textContent = genModeLabels[genMode];
      genModeBtn.classList.toggle('active', genMode !== 'raw');
    });

    // Default video model for starred images
    const videoModelSelect = document.getElementById('video-model-select');
    let defaultVideoModel = 'kling3';
    videoModelSelect.addEventListener('change', (e) => {
      defaultVideoModel = e.target.value;
    });

    // ===== UGC PROMPT ENHANCER =====
    // Automatically makes prompts more realistic/authentic for UGC-style content
    
    const UGC_ENHANCEMENTS = {
      // Add these for realism
      add: [
        'shot on iPhone',
        'natural lighting',
        'candid moment',
        'authentic',
        'unposed',
        'real environment',
        'slight motion blur',
        'natural skin texture',
        'casual setting'
      ],
      // Avoid these (make it look AI-generated)
      avoid: [
        'hyper realistic', 'ultra realistic', '8k', 'octane render', 
        'unreal engine', 'studio lighting', 'perfect', 'flawless',
        'symmetrical', 'centered composition', 'professional photo',
        'stock photo', 'advertising', 'commercial'
      ],
      // Replace these terms
      replace: {
        'beautiful': 'natural-looking',
        'perfect skin': 'real skin texture',
        'studio': 'home',
        'professional': 'casual',
        'model': 'person',
        'posing': 'candid'
      },
      // Negative prompt additions (if model supports)
      negative: [
        'artificial', 'plastic skin', 'airbrushed', 'oversaturated',
        'HDR', 'oversharpened', 'stock photo', 'advertisement',
        'symmetrical face', 'perfect teeth', 'glamour lighting'
      ]
    };

    // ===== B-ROLL MODE EXPANSION =====
    // Camera roll realism - like actual photos from someone's phone
    function expandBrollPrompt(prompt) {
      if (!prompt) return prompt;
      
      // Candid photo moments (NO screenshot/UI references)
      const cameraRollVibes = [
        'accidental burst photo, slightly between poses',
        'candid moment caught naturally',
        'photo taken mid-laugh, candid moment',
        'blurry background person walking through',
        'taken while walking, slight motion',
        'quick snap, casual timing',
        'spontaneous photo, unplanned moment',
        'casual photo shared between friends'
      ];
      
      // Lo-fi imperfections
      const lofiElements = [
        'slight grain, not sharp, compressed jpeg quality',
        'soft focus, not everything crisp',
        'small lens flare from window',
        'slight overexposure from bright window',
        'shadow falling across part of frame',
        'warm color cast from indoor lighting',
        'slightly tilted horizon, not perfectly level',
        'harsh flash illuminating foreground only'
      ];
      
      // Framing mistakes real people make
      const framingQuirks = [
        'subject slightly off-center, too much headroom',
        'something random cut off at edge of frame',
        'thumb slightly visible in corner',
        'awkward crop, didnt frame it properly',
        'too close, face fills frame',
        'too far, lots of empty space around subject',
        'reflection visible in glass or mirror behind'
      ];
      
      // Real messy environments (NO branded packaging)
      const realMess = [
        'water bottle and charger on nightstand',
        'pile of clothes on chair in background',
        'shoes kicked off by door visible',
        'cardboard box in corner of room',
        'half-eaten snack on desk',
        'tangled earbuds somewhere in frame',
        'random hand cream or chapstick visible',
        'phone charger cable dangling'
      ];
      
      // Time of day feeling
      const timeVibes = [
        'lazy sunday morning light',
        'late night scrolling lighting, just lamp on',
        'harsh midday light through window',
        'getting ready to go out lighting',
        'just got home energy',
        'waiting for food to arrive vibes'
      ];
      
      const vibe = cameraRollVibes[Math.floor(Math.random() * cameraRollVibes.length)];
      const lofi = lofiElements[Math.floor(Math.random() * lofiElements.length)];
      const framing = framingQuirks[Math.floor(Math.random() * framingQuirks.length)];
      const mess = realMess[Math.floor(Math.random() * realMess.length)];
      const time = timeVibes[Math.floor(Math.random() * timeVibes.length)];
      
      return `${vibe} of ${prompt}, ${lofi}, ${framing}, ${mess}, ${time}, shot on iphone, vertical 9:16 portrait, raw photo file, not aesthetic not curated, casual authentic photograph, candid snapshot, fullscreen image with no UI no timestamps no dates no text overlays`;
    }
    
    // ===== TALKING HEAD MODE EXPANSION =====
    // For creating stills that will be animated to talk
    function expandTalkingHeadPrompt(prompt) {
      if (!prompt) return prompt;
      
      // Camera setups (NO phone visible ever)
      const cameraSetups = [
        'selfie camera at natural arms length, slightly below eye level',
        'phone propped on window ledge, soft natural light',
        'tripod setup at desk height, eye-level framing',
        'camera resting against books on shelf, casual angle',
        'ring light setup visible in catch lights, phone mounted'
      ];
      
      // Mid-sentence expressions (for lip sync)
      const expressions = [
        'mouth slightly open mid-word, engaged expression',
        'about to say something, slight eyebrow raise',
        'paused mid-thought, relaxed face',
        'casual talking expression, not too animated',
        'natural speaking moment, eyes engaged with camera'
      ];
      
      // Backgrounds (sharp focus, not blurred)
      const backgrounds = [
        'living room bookshelf and couch in sharp focus behind',
        'bedroom with bed and nightstand visible, everything in focus',
        'home office with monitor and plants visible',
        'kitchen with cabinets and fridge magnets in background',
        'plain wall with one piece of art, simple background'
      ];
      
      // Lighting (flat, not cinematic)
      const lighting = [
        'flat even indoor lighting, soft and natural',
        'soft daylight from window, no harsh shadows',
        'ring light creating even illumination',
        'overhead room light plus window, balanced',
        'natural afternoon light, not golden hour'
      ];
      
      // Clothing (not generic)
      const clothingNotes = [
        'wearing lived-in comfortable clothes',
        'casual hoodie or sweater',
        'simple t-shirt, slightly wrinkled naturally',
        'cozy cardigan or flannel'
      ];
      
      const setup = cameraSetups[Math.floor(Math.random() * cameraSetups.length)];
      const expression = expressions[Math.floor(Math.random() * expressions.length)];
      const bg = backgrounds[Math.floor(Math.random() * backgrounds.length)];
      const light = lighting[Math.floor(Math.random() * lighting.length)];
      const clothes = clothingNotes[Math.floor(Math.random() * clothingNotes.length)];
      
      return `Vertical 9:16 iPhone video frame of ${prompt}, ${expression}, ${setup}, ${light}, ${bg}, ${clothes}, NO phone visible in frame, no text no UI no overlays no REC indicator no timestamps no dates, casual home video feel, authentic not performative, relaxed genuine expression`;
    }

    function enhancePromptForUGC(prompt) {
      if (!prompt) return prompt;
      
      let enhanced = prompt.toLowerCase();
      
      // Remove terms that make images look AI-generated
      UGC_ENHANCEMENTS.avoid.forEach(term => {
        enhanced = enhanced.replace(new RegExp(term, 'gi'), '');
      });
      
      // Replace problematic terms
      Object.entries(UGC_ENHANCEMENTS.replace).forEach(([from, to]) => {
        enhanced = enhanced.replace(new RegExp(from, 'gi'), to);
      });
      
      // Clean up extra spaces
      enhanced = enhanced.replace(/\s+/g, ' ').trim();
      
      // Add UGC modifiers (pick 3-4 relevant ones)
      const addons = [];
      
      // Always add these core ones
      addons.push('shot on iPhone 15 Pro');
      addons.push('natural lighting');
      
      // Add context-specific ones
      if (enhanced.includes('person') || enhanced.includes('woman') || enhanced.includes('man') || enhanced.includes('creator')) {
        addons.push('candid moment');
        addons.push('authentic expression');
        addons.push('natural skin texture with pores');
      }
      
      if (enhanced.includes('product') || enhanced.includes('holding')) {
        addons.push('casual home environment');
        addons.push('slightly messy background');
      }
      
      // Combine
      const finalPrompt = `${enhanced}, ${addons.join(', ')}`;
      
      return finalPrompt;
    }

    function getUGCNegativePrompt() {
      return UGC_ENHANCEMENTS.negative.join(', ');
    }

    // ===== LLM PROMPT EXPANSION =====
    // Converts simple prompts to detailed JSON for Nano Banana Pro
    
    const PROMPT_EXPANSION_TEMPLATE = `You are a prompt engineer for Nano Banana Pro image generation. Convert the user's simple request into a detailed JSON prompt optimized for ultra-realistic UGC (user-generated content) style images.

The output must be authentic-looking content suitable for social media ads - NOT polished studio shots.

USER REQUEST: {{INPUT}}

Output a JSON object with these exact keys:
{
  "label": "short-kebab-case-name",
  "tags": ["3-5 style tags"],
  "Style": ["documentary-candid-style", "social-media-native"],
  "Subject": ["detailed subject description", "physical traits if person", "expression"],
  "MadeOutOf": ["materials", "textures", "fabric types"],
  "Arrangement": "pose and placement description",
  "Background": "realistic home/casual environment",
  "ColorRestriction": ["natural tones only", "no oversaturation"],
  "Lighting": "describe natural/phone lighting",
  "Camera": {
    "type": "iPhone 15 Pro or similar phone",
    "lens": "24-35mm equivalent",
    "aperture": "f/1.8",
    "style": "selfie or handheld"
  },
  "OutputStyle": "authentic social media photo",
  "Mood": "casual, relatable, real"
}

CRITICAL RULES FOR UGC REALISM:
- ALWAYS use phone camera specs (iPhone 15 Pro, Pixel 8)
- NEVER use studio lighting terms
- ALWAYS include "natural skin texture with pores" for people
- ALWAYS use messy/real backgrounds (bathroom counter, bedroom, kitchen)
- Include slight imperfections (motion blur ok, not perfectly centered)
- Expression should be natural, not posed/model-like

Return ONLY the JSON, no explanation.`;

    async function expandPromptWithLLM(simplePrompt) {
      try {
        // Get selected context profile
        const contextSelect = document.getElementById('context-profile');
        const contextId = contextSelect?.value || null;
        
        const response = await fetch('/api/prompt/expand', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: simplePrompt,
            mode: 'ugc',
            contextId: contextId
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('LLM expanded JSON:', data.json);
          if (contextId) console.log('Using context profile:', contextId);
          return data.json;
        }
      } catch (err) {
        console.error('LLM expansion failed:', err);
      }
      
      // Fallback: return null (will use simple enhancement)
      return null;
    }

    function jsonPromptToString(jsonPrompt) {
      // Convert JSON prompt to string format for Nano Banana Pro
      if (!jsonPrompt) return null;
      
      const parts = [];
      
      if (jsonPrompt.Style) parts.push(`Style: ${jsonPrompt.Style.join(', ')}`);
      if (jsonPrompt.Subject) parts.push(`Subject: ${jsonPrompt.Subject.join(', ')}`);
      if (jsonPrompt.MadeOutOf) parts.push(`Materials: ${jsonPrompt.MadeOutOf.join(', ')}`);
      if (jsonPrompt.Arrangement) parts.push(`Pose: ${jsonPrompt.Arrangement}`);
      if (jsonPrompt.Background) parts.push(`Background: ${jsonPrompt.Background}`);
      if (jsonPrompt.Lighting) parts.push(`Lighting: ${jsonPrompt.Lighting}`);
      if (jsonPrompt.Camera) {
        parts.push(`Camera: ${jsonPrompt.Camera.type}, ${jsonPrompt.Camera.lens}, ${jsonPrompt.Camera.aperture}, ${jsonPrompt.Camera.style}`);
      }
      if (jsonPrompt.OutputStyle) parts.push(`Output: ${jsonPrompt.OutputStyle}`);
      if (jsonPrompt.Mood) parts.push(`Mood: ${jsonPrompt.Mood}`);
      if (jsonPrompt.ColorRestriction) parts.push(`Colors: ${jsonPrompt.ColorRestriction.join(', ')}`);
      
      return parts.join('. ');
    }

    // ===== DRAG & DROP =====
    
    // Grid items are draggable - direct attachment
    function makeGridItemDraggable(item, imgSrc) {
      item.setAttribute('draggable', 'true');
      item.dataset.src = imgSrc;
      
      item.ondragstart = function(e) {
        e.dataTransfer.setData('text/plain', imgSrc);
        e.dataTransfer.effectAllowed = 'copy';
        item.classList.add('dragging');
        console.log('[Drag] Started:', imgSrc);
      };
      
      item.ondragend = function() {
        item.classList.remove('dragging');
      };
    }

    // Prompt bar accepts drops
    promptBar.addEventListener('dragover', (e) => {
      e.preventDefault();
      promptBar.classList.add('drag-over');
    });

    promptBar.addEventListener('dragleave', () => {
      promptBar.classList.remove('drag-over');
    });

    promptBar.addEventListener('drop', async (e) => {
      e.preventDefault();
      promptBar.classList.remove('drag-over');
      
      const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
      
      // If multiple images dropped, enter bulk mode
      if (files.length > 1) {
        enterBulkMode();
        await handleBulkFiles(files);
        return;
      }
      
      // Handle image from grid (http URLs or local /outputs/ paths)
      const imgSrc = e.dataTransfer.getData('text/plain');
      console.log('[Drop] Received:', imgSrc);
      
      if (imgSrc && imgSrc.length > 0) {
        addReference(imgSrc);
        return;
      }
      
      // Handle single file drop
      if (files.length === 1) {
        const reader = new FileReader();
        reader.onload = (ev) => addReference(ev.target.result);
        reader.readAsDataURL(files[0]);
      }
    });

    // ===== REFERENCES =====
    function addReference(src) {
      if (references.length >= 4) return; // Max 4 references
      references.push(src);
      renderReferences();
    }

    function removeReference(index) {
      references.splice(index, 1);
      renderReferences();
    }

    function renderReferences() {
      promptReferences.innerHTML = references.map((src, i) => `
        <div class="prompt-ref">
          <img src="${src}" alt="Reference ${i + 1}">
          <button class="prompt-ref-remove" onclick="removeReference(${i})"></button>
        </div>
      `).join('');
    }

    // ===== IMAGE GRID =====
    function renderGrid() {
      if (images.length === 0) {
        imageGrid.innerHTML = '';
        emptyState.style.display = 'block';
        imageCount.textContent = '0 images';
        return;
      }

      emptyState.style.display = 'none';
      imageCount.textContent = `${images.length} image${images.length === 1 ? '' : 's'}`;
      
      imageGrid.innerHTML = images.map((img, i) => {
        // Loading placeholder
        if (img.loading) {
          return `
            <div class="grid-item grid-item-loading" data-index="${i}">
              <div class="grid-item-loading-inner">
                <div class="grid-item-spinner"></div>
                <span class="grid-item-loading-text">${img.prompt ? img.prompt.slice(0, 30) + '...' : 'Generating...'}</span>
                <button class="grid-item-cancel" onclick="event.stopPropagation(); cancelGeneration(${i})" title="Cancel generation"> Cancel</button>
              </div>
            </div>
          `;
        }
        
        const isQueued = videoQueue.some(v => v.image.url === img.url);
        return `
          <div class="grid-item" data-index="${i}">
            <img src="${img.url}" alt="${img.prompt || 'Generated image'}" loading="lazy">
            <span class="grid-item-drag-hint">Drag to reference</span>
            <button class="grid-item-delete" onclick="event.stopPropagation(); deleteImage(${i})" title="Delete image">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
              </svg>
            </button>
            <button class="grid-item-save ${isQueued ? 'saved' : ''}" onclick="event.stopPropagation(); toggleVideoQueue(${i})" title="${isQueued ? 'Remove from video queue' : 'Add to video queue'}">
              <svg fill="${isQueued ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"/>
              </svg>
            </button>
          </div>
        `;
      }).join('');

      // Make items draggable
      document.querySelectorAll('.grid-item').forEach((item, i) => {
        makeGridItemDraggable(item, images[i].url);
        item.addEventListener('click', (e) => {
          if (e.target.tagName !== 'BUTTON' && !e.target.closest('.grid-item-save')) {
            openModal(i);
          }
        });
      });
    }

    // ===== MODAL =====
    const modalMeta = document.getElementById('modal-meta');

    function openModal(index) {
      currentImage = images[index];
      modalImage.src = currentImage.url;
      
      // Show metadata
      if (currentImage.prompt) {
        modalMeta.innerHTML = `
          <div class="modal-meta-prompt">"${currentImage.prompt}"</div>
          <div class="modal-meta-settings">
            <div class="modal-meta-item">
              <span class="modal-meta-label">Ratio:</span>
              <span>${currentImage.ratio || '9:16'}</span>
            </div>
            <div class="modal-meta-item">
              <span class="modal-meta-label">Model:</span>
              <span>${currentImage.model || 'Flux'}</span>
            </div>
          </div>
          <div class="modal-meta-actions">
            <button class="modal-meta-btn" onclick="copyPrompt()">Copy prompt</button>
            <button class="modal-meta-btn" onclick="rerunPrompt()">Re-run</button>
          </div>
        `;
      } else {
        modalMeta.innerHTML = '';
      }
      
      modal.classList.add('active');
    }

    function closeModal() {
      modal.classList.remove('active');
      currentImage = null;
    }

    function copyPrompt() {
      if (currentImage?.prompt) {
        navigator.clipboard.writeText(currentImage.prompt);
      }
    }

    function rerunPrompt() {
      if (currentImage?.prompt) {
        promptInput.value = currentImage.prompt;
        if (currentImage.ratio) {
          aspectRatioSelect.value = currentImage.ratio;
          selectedRatio = currentImage.ratio;
        }
        closeModal();
        promptInput.focus();
      }
    }

    document.getElementById('modal-close').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });

    document.getElementById('modal-reference').addEventListener('click', () => {
      if (currentImage) {
        addReference(currentImage.url);
        closeModal();
      }
    });

    document.getElementById('modal-variations').addEventListener('click', () => {
      if (currentImage) {
        // Generate 4 variations
        generateVariations(currentImage);
        closeModal();
      }
    });

    document.getElementById('modal-download').addEventListener('click', () => {
      if (currentImage) {
        const a = document.createElement('a');
        a.href = currentImage.url;
        a.download = `aditor-${Date.now()}.png`;
        a.click();
      }
    });

    document.getElementById('modal-video').addEventListener('click', () => {
      if (currentImage) {
        addToVideoQueue(images.indexOf(currentImage));
        closeModal();
      }
    });

    document.getElementById('modal-reuse').addEventListener('click', () => {
      if (currentImage && currentImage.prompt) {
        promptInput.value = currentImage.prompt;
        closeModal();
        promptInput.focus();
      }
    });

    async function generateVariations(img) {
      generating.classList.add('active');
      document.querySelector('.generating-text').textContent = 'Generating 4 variations...';
      
      try {
        // TODO: Replace with actual API call
        const response = await fetch('/api/variations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sourceImage: img.url,
            prompt: img.prompt,
            count: 4
          })
        });

        if (response.ok) {
          const data = await response.json();
          data.images.forEach(url => {
            images.unshift({
              url,
              prompt: img.prompt + ' (variation)',
              ratio: img.ratio,
              model: img.model,
              createdAt: new Date().toISOString()
            });
          });
          renderGrid();
        }
      } catch (err) {
        // Demo mode: add placeholder variations
        for (let i = 0; i < 4; i++) {
          images.unshift({
            url: `https://picsum.photos/seed/${Date.now() + i}/400/700`,
            prompt: img.prompt + ' (variation)',
            ratio: img.ratio,
            model: img.model,
            createdAt: new Date().toISOString()
          });
        }
        renderGrid();
      } finally {
        generating.classList.remove('active');
        document.querySelector('.generating-text').textContent = 'Generating...';
      }
    }

    // ===== VIDEO QUEUE =====
    const videoQueueContainer = document.getElementById('video-queue-container');
    const videoEmptyState = document.getElementById('video-empty-state');
    const videoCount = document.getElementById('video-count');

    function deleteImage(index) {
      const img = images[index];
      // Remove from video queue if present
      const queueIndex = videoQueue.findIndex(v => v.image.url === img.url);
      if (queueIndex >= 0) {
        videoQueue.splice(queueIndex, 1);
      }
      // Remove from images array
      images.splice(index, 1);
      saveImages();
      renderGrid();
      renderVideoQueue();
      updateVideoTabBadge();
    }

    function toggleVideoQueue(index) {
      console.log('[Star] toggleVideoQueue called with index:', index);
      const img = images[index];
      console.log('[Star] Image:', img);
      
      if (!img) {
        console.error('[Star] No image found at index', index);
        return;
      }
      
      const existingIndex = videoQueue.findIndex(v => v.image.url === img.url);
      console.log('[Star] Existing in queue:', existingIndex);
      
      if (existingIndex >= 0) {
        // Remove from queue
        videoQueue.splice(existingIndex, 1);
        renderGrid();
        renderVideoQueue();
        updateVideoTabBadge();
      } else {
        // Auto-add with generated prompt and start video gen immediately
        const videoPrompt = generateVideoPrompt(img.prompt);
        console.log('[Star] Generated video prompt:', videoPrompt?.substring(0, 50));
        
        const newItem = {
          id: Date.now(),
          image: img,
          prompt: videoPrompt,
          status: 'pending', // Start as pending, generateVideo will set to generating
          model: defaultVideoModel,
          videoUrl: null
        };
        
        console.log('[Star] Adding new item to videoQueue:', newItem.id);
        videoQueue.unshift(newItem); // Add to top, not bottom
        console.log('[Star] videoQueue length now:', videoQueue.length);
        
        renderGrid();
        renderVideoQueue();
        updateVideoTabBadge();
        
        // Auto-start video generation
        console.log('[Star] Starting video generation for:', newItem.id);
        generateVideo(newItem.id);
      }
    }
    
    function showVideoPromptPopup(img) {
      // Create popup overlay
      const overlay = document.createElement('div');
      overlay.className = 'video-prompt-overlay';
      overlay.innerHTML = `
        <div class="video-prompt-popup">
          <h3>Add to Video Queue</h3>
          <p class="video-prompt-hint">Optional: describe the motion you want</p>
          <input type="text" class="video-prompt-input" placeholder="e.g., slow zoom in, she looks up and smiles..." autofocus>
          <div class="video-prompt-actions">
            <button class="video-prompt-cancel">Cancel</button>
            <button class="video-prompt-confirm">Add to Queue</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      const input = overlay.querySelector('.video-prompt-input');
      const cancelBtn = overlay.querySelector('.video-prompt-cancel');
      const confirmBtn = overlay.querySelector('.video-prompt-confirm');
      
      function addToQueue() {
        const customPrompt = input.value.trim();
        const videoPrompt = customPrompt || generateVideoPrompt(img.prompt);
        
        const newItem = {
          id: Date.now(),
          image: img,
          prompt: videoPrompt,
          status: 'generating',
          model: defaultVideoModel,
          videoUrl: null
        };
        
        videoQueue.unshift(newItem); // Add to top, not bottom
        
        renderGrid();
        renderVideoQueue();
        updateVideoTabBadge();
        overlay.remove();
        
        // Auto-start video generation
        generateVideo(newItem.id);
      }
      
      function cancel() {
        overlay.remove();
      }
      
      // Event listeners
      confirmBtn.addEventListener('click', addToQueue);
      cancelBtn.addEventListener('click', cancel);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) cancel();
      });
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          addToQueue();
        }
        if (e.key === 'Escape') cancel();
      });
      
      // Focus input
      setTimeout(() => input.focus(), 100);
    }

    function generateVideoPrompt(imagePrompt) {
      // Research-backed video prompt enhancement for Kling/AI video gen
      // Based on: fal.ai Kling 2.6 Pro guide, Leonardo.ai Kling prompts, VEED guide
      
      if (!imagePrompt) {
        return 'Gentle camera movement, natural subtle motion, cinematic lighting, shallow depth of field, high quality UGC style';
      }
      
      // Motion types that work well with different subjects
      const motionPatterns = {
        person: [
          'subtle natural breathing motion, gentle hair movement from soft breeze',
          'slight head turn with natural eye movement, relaxed posture shift',
          'natural micro-movements, subtle facial expression change',
          'gentle body sway, authentic candid movement'
        ],
        product: [
          'slow 15-degree rotation, subtle floating motion',
          'gentle camera orbit around subject, soft highlight shifts',
          'smooth push-in revealing product details',
          'elegant slow-motion presentation'
        ],
        scene: [
          'slow cinematic pan across the scene',
          'gentle parallax movement, atmospheric elements drift naturally',
          'smooth tracking shot through environment',
          'subtle depth reveal with rack focus'
        ]
      };
      
      // Camera movements (Kling-optimized)
      const cameraMovements = [
        'camera slowly tracks right while maintaining focus',
        'gentle push-in toward subject',
        'subtle dolly movement with shallow depth of field',
        'smooth handheld-style micro-movements',
        'slow cinematic pan',
        'gentle floating camera movement'
      ];
      
      // Style additions for UGC/social media
      const ugcStyle = [
        'natural lighting, authentic social media aesthetic',
        'high-quality UGC style, minimal polish, genuine feel',
        'iPhone-captured quality, natural color grading',
        'candid documentary feel, organic movement'
      ];
      
      // Detect subject type from prompt
      const promptLower = imagePrompt.toLowerCase();
      let subjectType = 'scene';
      if (promptLower.includes('person') || promptLower.includes('woman') || promptLower.includes('man') || 
          promptLower.includes('girl') || promptLower.includes('guy') || promptLower.includes('influencer') ||
          promptLower.includes('holding') || promptLower.includes('sitting') || promptLower.includes('standing')) {
        subjectType = 'person';
      } else if (promptLower.includes('product') || promptLower.includes('bottle') || promptLower.includes('box') ||
                 promptLower.includes('phone') || promptLower.includes('device') || promptLower.includes('package')) {
        subjectType = 'product';
      }
      
      // Build enhanced prompt
      const motion = motionPatterns[subjectType][Math.floor(Math.random() * motionPatterns[subjectType].length)];
      const camera = cameraMovements[Math.floor(Math.random() * cameraMovements.length)];
      const style = ugcStyle[Math.floor(Math.random() * ugcStyle.length)];
      
      return `${motion}, ${camera}, ${style}`;
    }

    function updateVideoTabBadge() {
      const tab = document.querySelector('.nav-tab[data-tab="videos"]');
      const pendingCount = videoQueue.filter(v => v.status === 'pending').length;
      const bulkGenerating = typeof bulkItems !== 'undefined' ? bulkItems.filter(it => it.status === 'generating').length : 0;
      const totalPending = pendingCount + bulkGenerating;
      
      if (totalPending > 0) {
        tab.innerHTML = `Videos <span style="background: var(--accent); color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px; margin-left: 6px;">${totalPending}</span>`;
      } else {
        tab.textContent = 'Videos';
      }
    }
    
    // Render bulk i2v jobs in the Videos tab
    function renderBulkJobsInVideoTab() {
      let bulkSection = document.getElementById('bulk-i2v-video-section');
      
      // Merge historical items (from page load) with current session items
      // Use Map to dedupe by taskId
      const itemMap = new Map();
      
      // Add historical items first
      if (window._bulkVideoTabItems) {
        for (const item of window._bulkVideoTabItems) {
          itemMap.set(item.taskId, item);
        }
      }
      
      // Add/update with current session items (takes precedence for status updates)
      if (bulkItems && bulkItems.length > 0) {
        for (const item of bulkItems) {
          if (item.status === 'generating' || item.status === 'done' || item.status === 'error') {
            itemMap.set(item.taskId, item);
          }
        }
      }
      
      const allItems = Array.from(itemMap.values());
      
      // Check if we have any bulk items
      if (allItems.length === 0) {
        if (bulkSection) bulkSection.remove();
        return;
      }
      
      const visibleItems = allItems.filter(it => it.status === 'generating' || it.status === 'done' || it.status === 'error');
      if (visibleItems.length === 0) {
        if (bulkSection) bulkSection.remove();
        return;
      }
      
      // Group items by batchId
      const batches = new Map();
      for (const item of visibleItems) {
        const bid = item.batchId || 'unknown';
        if (!batches.has(bid)) batches.set(bid, []);
        batches.get(bid).push(item);
      }
      
      // Create or update section
      if (!bulkSection) {
        bulkSection = document.createElement('div');
        bulkSection.id = 'bulk-i2v-video-section';
        bulkSection.style.cssText = 'margin-bottom: 24px; display: flex; flex-direction: column; gap: 16px;';
        videoQueueContainer.parentElement.insertBefore(bulkSection, videoQueueContainer);
      }
      
      // Render each batch as its own row (newest first - backend already sorts)
      const batchEntries = [...batches.entries()];
      bulkSection.innerHTML = batchEntries.map(([batchId, items], batchIdx) => {
        const generating = items.filter(it => it.status === 'generating').length;
        const done = items.filter(it => it.status === 'done').length;
        const failed = items.filter(it => it.status === 'error').length;
        const batchNum = batchEntries.length - batchIdx;
        
        return `
          <div style="padding: 16px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
              <div style="display: flex; align-items: center; gap: 12px;">
                <span style="font-weight: 600; color: var(--text-primary);"> Batch ${batchNum}</span>
                <span style="font-size: 12px; color: var(--text-tertiary);">${items.length} clips</span>
                <span style="font-size: 13px; color: var(--text-secondary);">
                  ${generating > 0 ? `<span style="color: var(--accent);">${generating} generating</span>` : ''}
                  ${done > 0 ? `<span style="color: #22c55e;${generating > 0 ? ' margin-left: 8px;' : ''}">${done} done</span>` : ''}
                  ${failed > 0 ? `<span style="color: #ef4444; margin-left: 8px;">${failed} failed</span>` : ''}
                </span>
              </div>
              ${done > 0 ? `<button onclick="downloadBatchVideos('${batchId}')" style="background: var(--accent); color: white; border: none; padding: 6px 14px; border-radius: 8px; font-size: 12px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 6px;">
                <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
                Download (${done})
              </button>` : ''}
            </div>
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px;">
              ${items.map(item => `
                <div style="position: relative; aspect-ratio: 9/16; border-radius: 8px; overflow: hidden; background: var(--bg-tertiary);">
                  ${item.status === 'done' && item.videoUrl 
                    ? `<video class="lazy-video" data-src="${item.videoUrl}" style="width: 100%; height: 100%; object-fit: cover;" muted loop playsinline preload="none"></video>`
                    : `<img src="${item.url}" style="width: 100%; height: 100%; object-fit: cover; ${item.status === 'generating' ? 'filter: brightness(0.5);' : ''}" loading="lazy">
                       <div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;">
                         ${item.status === 'generating' 
                           ? '<div style="width: 24px; height: 24px; border: 2px solid var(--accent); border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>'
                           : item.status === 'error' 
                             ? `<button onclick="retrySingleBulkVideo('${item.taskId}')" style="background: #ef4444; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 11px; cursor: pointer; display: flex; align-items: center; gap: 4px;">
                                  <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>
                                  Retry
                                </button>` 
                             : ''}
                       </div>`
                  }
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Download videos for a specific batch as ZIP
    async function downloadBatchVideos(batchId) {
      // Use merged items (same as video tab render)
      const allItems = window._bulkVideoTabItems && window._bulkVideoTabItems.length > 0 
        ? [...window._bulkVideoTabItems, ...bulkItems] 
        : bulkItems;
      const batchDone = allItems.filter(it => it.batchId === batchId && it.status === 'done' && it.videoUrl);
      if (!batchDone.length) return;
      
      const btn = document.querySelector(`[onclick*="${batchId}"]`);
      if (btn) {
        btn.disabled = true;
        btn.innerHTML = '<svg class="spin" width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="31.4" stroke-dashoffset="10"/></svg> Zipping...';
      }
      
      try {
        const urls = batchDone.map(it => it.videoUrl);
        const res = await fetch('/api/proxy/zip-videos', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ urls, batchId })
        });
        
        if (!res.ok) throw new Error('Failed to create zip');
        
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `batch-${batchId.slice(-6)}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error('Failed to download batch:', err);
        // Fallback: open first video directly
        if (batchDone[0]) window.open(`/api/proxy/video?url=${encodeURIComponent(batchDone[0].videoUrl)}&filename=video.mp4`, '_blank');
      }
      
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = `<svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg> Download (${batchDone.length})`;
      }
    }

    function renderVideoQueue() {
      console.log('[VideoQueue] Rendering, length:', videoQueue.length);
      if (videoQueue.length === 0) {
        videoQueueContainer.innerHTML = '';
        videoEmptyState.style.display = 'block';
        videoCount.textContent = '0 videos';
        return;
      }

      videoEmptyState.style.display = 'none';
      console.log('[VideoQueue] Hiding empty state, showing', videoQueue.length, 'items');
      videoCount.textContent = `${videoQueue.length} video${videoQueue.length === 1 ? '' : 's'}`;
      
      videoQueueContainer.innerHTML = `
        <div class="video-queue-grid">
          ${videoQueue.map((item, i) => `
            <div class="video-queue-item ${item.status}" data-id="${item.id}">
              <div class="video-queue-preview">
                ${item.status === 'complete' && item.videoUrl ? `
                  <video class="video-queue-thumb lazy-video" data-src="${item.videoUrl}" poster="${item.image.url}" muted loop playsinline preload="none"></video>
                ` : `
                  <img class="video-queue-thumb ${item.status === 'generating' ? 'generating-blur' : ''}" src="${item.image.url}" alt="" loading="lazy" decoding="async">
                  ${item.status === 'generating' ? '<div class="video-generating-overlay"><div class="spinner"></div><span>Generating...</span></div>' : ''}
                `}
              </div>
              <div class="video-queue-meta">
                <div class="video-queue-prompt">${item.prompt.substring(0, 60)}${item.prompt.length > 60 ? '...' : ''}</div>
                <div class="video-queue-status-row">
                  <span class="video-queue-status-dot ${item.status}"></span>
                  <span>${item.status === 'generating' ? 'Generating...' : item.status === 'complete' ? 'Ready' : item.status === 'error' ? 'Error' : 'Pending'}</span>
                  <button class="video-queue-remove" onclick="removeFromQueue(${item.id})" title="Remove"></button>
                </div>
              </div>
            </div>
          `).join('')}
        </div>
        ${videoQueue.filter(v => v.status === 'pending').length > 1 ? `
          <div style="margin-top: 20px; text-align: center;">
            <button class="video-queue-btn primary" onclick="generateAllVideos()" style="width: auto; padding: 12px 32px;">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 16px; height: 16px;">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
              </svg>
              Generate All (${videoQueue.filter(v => v.status === 'pending').length} videos)
            </button>
          </div>
        ` : ''}
      `;
    }

    function updateVideoPrompt(id, newPrompt) {
      const item = videoQueue.find(v => v.id === id);
      if (item) item.prompt = newPrompt;
    }

    function updateVideoModel(id, model) {
      const item = videoQueue.find(v => v.id === id);
      if (item) item.model = model;
    }

    function removeFromQueue(id) {
      videoQueue = videoQueue.filter(v => v.id !== id);
      renderGrid();
      renderVideoQueue();
      updateVideoTabBadge();
    }

    async function generateVideo(id) {
      const item = videoQueue.find(v => v.id === id);
      if (!item) return;
      
      item.status = 'generating';
      renderVideoQueue();
      
      try {
        // Use Kling API (via PiAPI Host-Your-Account)
        const response = await fetch('/api/kling/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            imageUrl: item.image.url,
            prompt: item.prompt,
            duration: 5,
            aspectRatio: item.image.ratio || '9:16',
            model: item.model || 'kling3'
          })
        });

        if (response.ok) {
          const data = await response.json();
          item.taskId = data.taskId;
          
          // Poll for completion
          item.videoUrl = await pollVideoStatus(data.taskId);
          item.status = item.videoUrl ? 'complete' : 'error';
        } else {
          item.status = 'error';
        }
      } catch (err) {
        console.error('Video generation failed:', err);
        item.status = 'error';
      }
      
      renderVideoQueue();
      updateVideoTabBadge();
    }

    async function generateAllVideos() {
      const pending = videoQueue.filter(v => v.status === 'pending');
      for (const item of pending) {
        await generateVideo(item.id);
      }
    }

    function downloadVideo(id) {
      const item = videoQueue.find(v => v.id === id);
      if (item?.videoUrl) {
        const a = document.createElement('a');
        a.href = item.videoUrl;
        a.download = `aditor-video-${item.id}.mp4`;
        a.click();
      }
    }

    // Poll for video generation completion
    async function pollVideoStatus(taskId, maxAttempts = 60) {
      for (let i = 0; i < maxAttempts; i++) {
        await new Promise(r => setTimeout(r, 5000)); // Wait 5 seconds between polls
        
        try {
          const response = await fetch(`/api/kling/status/${taskId}`);
          if (response.ok) {
            const data = await response.json();
            console.log(`[Kling] Poll ${i + 1}: ${data.status}`);
            
            if (data.status === 'complete' && data.videoUrl) {
              return data.videoUrl;
            } else if (data.status === 'error') {
              console.error('[Kling] Generation failed');
              return null;
            }
          }
        } catch (err) {
          console.error('[Kling] Poll error:', err);
        }
      }
      
      console.error('[Kling] Timeout after', maxAttempts, 'attempts');
      return null;
    }

    // Legacy function for modal
    function addToVideoQueue(index) {
      toggleVideoQueue(index);
    }

    // ===== GENERATE =====
    generateBtn.addEventListener('click', generate);
    promptInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        generate();
      }
    });

    // Track active generations for concurrent requests
    let activeGenerations = 0;
    const activeAbortControllers = new Map(); // placeholderId  AbortController

    function cancelGeneration(index) {
      const img = images[index];
      if (img && img.loading && img.id) {
        // Abort the fetch if still in flight
        const controller = activeAbortControllers.get(img.id);
        if (controller) {
          controller.abort();
          activeAbortControllers.delete(img.id);
        }
        // Remove from images array
        images.splice(index, 1);
        activeGenerations = Math.max(0, activeGenerations - 1);
        updateGeneratingText();
        if (activeGenerations === 0) {
          generating.classList.remove('active');
        }
        saveImages();
        renderGrid();
      }
    }
    // Expose globally for onclick
    window.cancelGeneration = cancelGeneration;
    
    async function generate() {
      const rawPrompt = promptInput.value.trim();
      if (!rawPrompt && references.length === 0) return;

      const genCount = parseInt(document.getElementById('gen-count').value) || 1;

      let basePrompt = rawPrompt;
      let negativePrompt = '';
      let useLLMExpansion = (genMode === 'broll' || genMode === 'talking');
      
      // For B-roll and Talking Head modes, we'll use LLM expansion via backend
      // Raw mode: use prompt as-is
      if (genMode !== 'raw') {
        negativePrompt = 'phone frame, device bezel, iOS interface, Android UI, status bar, home bar, camera app, viewfinder, REC indicator, screenshot frame, notification bar, app interface, UI elements, UI overlay, professional studio lighting, bokeh, blurred background, centered composition, posed, perfect, polished, stock photo, watermark, text, timestamp, date, timecode, yellow tint, thumb in frame';
      }

      // Save values before clearing UI
      let savedPrompt = rawPrompt;
      const savedReferences = [...references];
      const savedRatio = selectedRatio;
      const savedModel = selectedModel;
      
      // ===== PRODUCT MENTION ENHANCEMENT =====
      // Check if we have a selected product from @ mention
      const genContext = window.getGenerationContext ? window.getGenerationContext() : {};
      if (genContext.product) {
        // Add product image as reference if available
        if (genContext.product.image) {
          savedReferences.push(genContext.product.image);
        }
        // Enhance prompt with brand DNA context
        if (genContext.enhancedPrompt) {
          savedPrompt = `${savedPrompt}, ${genContext.enhancedPrompt}`;
        }
        // Clear selected product after use
        selectedProduct = null;
        // Remove product chips
        document.querySelectorAll('.product-chip').forEach(chip => chip.remove());
      }
      // ===== END PRODUCT MENTION ENHANCEMENT =====
      
      // Clear input immediately so user can prep next prompt
      promptInput.value = '';
      references = [];
      renderReferences();

      // Add loading placeholders to grid immediately
      const placeholderIds = [];
      for (let i = 0; i < genCount; i++) {
        const placeholderId = 'loading-' + Date.now() + '-' + i;
        placeholderIds.push(placeholderId);
        images.unshift({
          id: placeholderId,
          url: null,
          prompt: savedPrompt,
          ratio: savedRatio,
          model: savedModel,
          createdAt: new Date().toISOString(),
          loading: true,
          saved: false
        });
      }
      renderGrid();

      // Show generating indicator if first batch
      activeGenerations += genCount;
      generating.classList.add('active');
      updateGeneratingText();

      // Generate all images concurrently
      const generateOne = async (placeholderId, index) => {
        const abortController = new AbortController();
        activeAbortControllers.set(placeholderId, abortController);
        try {
          let finalPrompt = basePrompt;
          
          // Use LLM expansion for B-roll and Talking Head modes
          if (useLLMExpansion && savedPrompt) {
            console.log(` LLM expanding: "${savedPrompt.slice(0, 50)}..."`);
            const modeHint = genMode === 'talking' 
              ? 'This is for a talking head video still - person should be mid-sentence, looking at camera, in a home setting.'
              : 'This is UGC b-roll content - candid, casual, real-looking phone photo.';
            
            const expandRes = await fetch('/api/prompt/expand', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ 
                prompt: `${savedPrompt}. ${modeHint}`,
                mode: genMode
              }),
              signal: abortController.signal
            });
            
            if (expandRes.ok) {
              const expandData = await expandRes.json();
              if (expandData.expanded) {
                finalPrompt = expandData.expanded;
                console.log(` Expanded to: "${finalPrompt.slice(0, 100)}..."`);
              }
            }
          }
          
          const response = await fetch('/api/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: finalPrompt,
              negativePrompt,
              references: savedReferences,
              ratio: savedRatio,
              model: savedModel
            }),
            signal: abortController.signal
          });

          const data = await response.json();
          console.log(`Image ${index + 1} response:`, data);

          // Find and update placeholder
          const placeholderIndex = images.findIndex(img => img.id === placeholderId);
          if (placeholderIndex >= 0) {
            if (response.ok && data.url) {
              images[placeholderIndex] = {
                url: data.url,
                prompt: savedPrompt,
                ratio: savedRatio,
                model: savedModel,
                createdAt: new Date().toISOString(),
                saved: false
              };
            } else {
              // Remove failed placeholder
              images.splice(placeholderIndex, 1);
              console.error('API error:', data);
            }
            saveImages();
            renderGrid();
          }
        } catch (err) {
          console.error(`Generation ${index + 1} failed:`, err);
          // Remove failed placeholder
          const placeholderIndex = images.findIndex(img => img.id === placeholderId);
          if (placeholderIndex >= 0) {
            images.splice(placeholderIndex, 1);
            renderGrid();
          }
        } finally {
          activeAbortControllers.delete(placeholderId);
          activeGenerations--;
          updateGeneratingText();
          if (activeGenerations === 0) {
            generating.classList.remove('active');
          }
        }
      };

      // Fire all requests concurrently
      placeholderIds.forEach((id, i) => generateOne(id, i));
    }
    
    function updateGeneratingText() {
      const text = activeGenerations > 0 ? `Generating ${activeGenerations}...` : 'Generating...';
      document.querySelector('.generating-text').textContent = text;
    }

    // ===== KEYBOARD SHORTCUTS =====
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeModal();
      }
    });

    // ===== PASTE IMAGES =====
    document.addEventListener('paste', (e) => {
      const items = e.clipboardData?.items;
      if (!items) return;

      for (const item of items) {
        if (item.type.startsWith('image/')) {
          const file = item.getAsFile();
          const reader = new FileReader();
          reader.onload = (e) => addReference(e.target.result);
          reader.readAsDataURL(file);
        }
      }
    });

    // ===== DYNAMIC WORKFLOWS (from /api/workflows) =====
    let dynamicWorkflows = [];
    let activeDynamicWorkflow = null;

    async function loadDynamicWorkflows() {
      const container = document.getElementById('workflow-sidebar-list');
      try {
        const resp = await fetch('/api/workflows?starred=true');
        const data = await resp.json();
        dynamicWorkflows = data.workflows || [];

        if (dynamicWorkflows.length === 0) {
          container.innerHTML = '<div class="workflow-loading">No starred workflows yet</div>';
          return;
        }

        container.innerHTML = dynamicWorkflows.map((wf, i) => `
          <div class="workflow-item ${i === 0 ? 'active' : ''}" data-dynamic-workflow="${wf.id}">
            <div class="workflow-item-icon">
              <span style="font-size:20px">${wf.icon || ''}</span>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">${wf.name}</div>
              <div class="workflow-item-desc">${wf.description}</div>
            </div>
          </div>
        `).join('');

        // Click handlers for dynamic workflows
        container.querySelectorAll('[data-dynamic-workflow]').forEach(item => {
          item.addEventListener('click', () => {
            const wfId = item.dataset.dynamicWorkflow;
            selectDynamicWorkflow(wfId);

            // Update active states (clear legacy + dynamic)
            document.querySelectorAll('.workflow-item').forEach(el => el.classList.remove('active'));
            item.classList.add('active');
          });
        });

        // Auto-select first
        if (dynamicWorkflows.length > 0) {
          selectDynamicWorkflow(dynamicWorkflows[0].id);
        }
      } catch (e) {
        container.innerHTML = '<div class="workflow-loading">Failed to load workflows</div>';
        console.error('[Workflows]', e);
      }
    }

    function selectDynamicWorkflow(wfId) {
      const wf = dynamicWorkflows.find(w => w.id === wfId);
      if (!wf) return;
      activeDynamicWorkflow = wf;

      // Update header
      document.getElementById('workflow-title').textContent = wf.name;
      document.getElementById('workflow-description').textContent = wf.description;

      // Hide all custom layouts, show dynamic
      document.getElementById('ugc-video-layout').style.display = 'none';
      document.getElementById('motion-transfer-layout').style.display = 'none';
      const genericForm = document.getElementById('workflow-form');
      if (genericForm) genericForm.style.display = 'none';
      const uploadZone = document.getElementById('workflow-upload-zone');
      if (uploadZone) uploadZone.style.display = 'none';
      const promptBar = document.querySelector('.prompt-container');
      if (promptBar) promptBar.style.display = 'none';

      document.getElementById('dynamic-workflow-layout').style.display = 'block';

      // Render form fields
      renderDynamicForm(wf);
    }

    function renderDynamicForm(wf) {
      const form = document.getElementById('dynamic-workflow-form');
      const costEl = document.getElementById('dynamic-wf-cost');
      const outputEl = document.getElementById('dynamic-wf-output');
      const statusEl = document.getElementById('dynamic-wf-status');

      costEl.textContent = wf.cost_estimate ? `Est. ${wf.cost_estimate}` : '';
      outputEl.innerHTML = '';
      statusEl.style.display = 'none';

      form.innerHTML = (wf.inputs || []).map(input => {
        const required = input.required ? '<span class="wf-required">*</span>' : '';
        const hint = input.hint ? `<div class="wf-hint">${input.hint}</div>` : '';
        let field = '';

        switch (input.type) {
          case 'image':
            field = `
              <div class="wf-image-upload" id="wf-upload-${input.id}" onclick="document.getElementById('wf-file-${input.id}').click()">
                 Drop or click to upload
              </div>
              <input type="file" id="wf-file-${input.id}" data-wf-input="${input.id}" accept="image/*" hidden>
            `;
            break;
          case 'textarea':
            field = `<textarea data-wf-input="${input.id}" placeholder="${input.placeholder || ''}" ${input.required ? 'required' : ''}></textarea>`;
            break;
          case 'text':
            field = `<input type="text" data-wf-input="${input.id}" placeholder="${input.placeholder || ''}">`;
            break;
          case 'number':
            field = `<input type="number" data-wf-input="${input.id}" min="${input.min || 1}" max="${input.max || 100}" value="${input.default || 1}">`;
            break;
          case 'select':
            const options = (input.options || []).map(opt => {
              const val = typeof opt === 'string' ? opt : opt.value;
              const label = typeof opt === 'string' ? opt : opt.label;
              const selected = val === input.default ? 'selected' : '';
              return `<option value="${val}" ${selected}>${label}</option>`;
            }).join('');
            field = `<select data-wf-input="${input.id}">${options}</select>`;
            break;
          case 'checkbox':
            field = `<label style="display:flex;align-items:center;gap:8px;cursor:pointer">
              <input type="checkbox" data-wf-input="${input.id}" ${input.default ? 'checked' : ''}>
              <span>${input.label}</span>
            </label>`;
            return `<div class="dynamic-wf-field">${field}</div>`;
          default:
            field = `<input type="text" data-wf-input="${input.id}" placeholder="${input.placeholder || ''}">`;
        }

        return `<div class="dynamic-wf-field"><label>${input.label} ${required}</label>${field}${hint}</div>`;
      }).join('');

      // Wire up image upload previews
      form.querySelectorAll('input[type="file"]').forEach(fileInput => {
        fileInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const inputId = fileInput.dataset.wfInput;
          const uploadDiv = document.getElementById(`wf-upload-${inputId}`);
          const reader = new FileReader();
          reader.onload = (ev) => {
            uploadDiv.classList.add('has-image');
            uploadDiv.innerHTML = `<img src="${ev.target.result}" alt="uploaded">`;
            uploadDiv.dataset.base64 = ev.target.result;
          };
          reader.readAsDataURL(file);
        });
      });
    }

    // Run dynamic workflow
    document.getElementById('dynamic-wf-run-btn').addEventListener('click', async () => {
      if (!activeDynamicWorkflow) return;

      const btn = document.getElementById('dynamic-wf-run-btn');
      const statusEl = document.getElementById('dynamic-wf-status');
      const outputEl = document.getElementById('dynamic-wf-output');

      // Gather inputs
      const inputs = {};
      document.querySelectorAll('[data-wf-input]').forEach(el => {
        const key = el.dataset.wfInput;
        if (el.type === 'file') {
          const uploadDiv = document.getElementById(`wf-upload-${key}`);
          if (uploadDiv && uploadDiv.dataset.base64) {
            inputs[key] = uploadDiv.dataset.base64;
          }
        } else if (el.type === 'checkbox') {
          inputs[key] = el.checked;
        } else {
          inputs[key] = el.value;
        }
      });

      btn.disabled = true;
      btn.innerHTML = '<svg class="spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" width="18" height="18"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg> Running...';
      statusEl.style.display = 'block';
      statusEl.className = 'dynamic-wf-status running';
      statusEl.textContent = `Running ${activeDynamicWorkflow.name}...`;
      outputEl.innerHTML = '';

      try {
        const resp = await fetch(`/api/workflows/${activeDynamicWorkflow.id}/run`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(inputs)
        });
        const data = await resp.json();

        if (data.error) throw new Error(data.error);

        statusEl.className = 'dynamic-wf-status done';
        statusEl.textContent = ' Complete';

        // Render output
        if (data.output) {
          const url = typeof data.output === 'string' ? data.output : data.output.url || data.output;
          const outputType = activeDynamicWorkflow.output?.type || 'image';
          if (outputType === 'video') {
            outputEl.innerHTML = `<video src="${url}" controls autoplay style="max-width:100%;border-radius:12px"></video>`;
          } else {
            outputEl.innerHTML = `<img src="${url}" style="max-width:100%;border-radius:12px">`;
          }
        }
      } catch (e) {
        statusEl.className = 'dynamic-wf-status error';
        statusEl.textContent = `Error: ${e.message}`;
      } finally {
        btn.disabled = false;
        btn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="18" height="18"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/></svg> Generate';
      }
    });

    // Load workflows on page init
    loadDynamicWorkflows();

    // When switching to legacy workflow, hide dynamic layout
    function hideDynamicLayout() {
      document.getElementById('dynamic-workflow-layout').style.display = 'none';
      activeDynamicWorkflow = null;
    }

    // ===== WORKFLOW STUDIO (LEGACY) =====
    const workflowConfigs = {
      'script-to-video': {
        title: 'Script  UGC Video',
        desc: 'Upload avatar, paste script, select voice  get UGC video',
        customLayout: 'ugc-video',
        showUrl: false,
        showUpload: false,
        showScript: false,
        uploadHint: '',
        endpoint: '/api/ugc-video'
      },
      'kickstarter': {
        title: 'Kickstarter',
        desc: 'Paste a product page URL to generate 9:16 b-roll images and offer badges for VSLs.',
        showUrl: true,
        showUpload: false,
        showScript: false,
        uploadHint: '',
        endpoint: '/api/kickstarter'
      },
      'image-ads': {
        title: 'Image Ads',
        desc: 'Upload your product image and up to 8 inspiration ads to generate matching ad creatives.',
        showUrl: false,
        showUpload: true,
        showScript: false,
        uploadHint: 'Upload product image + inspiration ads',
        endpoint: '/api/image-ads'
      },
      'script-explainer': {
        title: 'Script  Explainer',
        desc: 'Paste your script and we\'ll generate consistent visual frames for an explainer video.',
        showUrl: false,
        showUpload: false,
        showScript: true,
        uploadHint: '',
        endpoint: '/api/script-explainer'
      },
      'screenshot-broll': {
        title: 'Screenshot  B-roll',
        desc: 'Upload a product image and a creator screenshot to recreate the frame with your product.',
        showUrl: false,
        showUpload: true,
        showScript: false,
        uploadHint: 'Upload product + creator screenshot',
        endpoint: '/api/screenshot-broll'
      },
      'motion-transfer': {
        title: 'Motion Transfer',
        desc: 'Record yourself with webcam, upload a character, and transfer your motion to them.',
        customLayout: 'motion-transfer',
        showUrl: false,
        showUpload: false,
        showScript: false,
        uploadHint: '',
        endpoint: '/api/motion-transfer',
        model: 'kling-motion-pro'
      }
    };

    let currentWorkflow = 'script-to-video';
    let workflowFiles = [];
    let workflowResults = [];
    const workflowResultsCache = {}; // Store results per workflow

    // Workflow sidebar click handler
    document.querySelectorAll('.workflow-item').forEach(item => {
      item.addEventListener('click', () => {
        const workflow = item.dataset.workflow;
        selectWorkflow(workflow);
      });
    });

    function selectWorkflow(workflow) {
      // Hide dynamic workflow layout when switching to legacy
      hideDynamicLayout();
      // Clear dynamic sidebar active states
      document.querySelectorAll('[data-dynamic-workflow]').forEach(el => el.classList.remove('active'));

      // Handle special modal workflows
      if (workflow === 'product-easy-wins') {
        openProductEasyWinsModal();
        return;
      }
      
      currentWorkflow = workflow;
      const config = workflowConfigs[workflow];
      if (!config) return;

      // Update sidebar active state
      document.querySelectorAll('.workflow-item').forEach(item => {
        item.classList.toggle('active', item.dataset.workflow === workflow);
      });

      // Update header
      document.getElementById('workflow-title').textContent = config.title;
      document.getElementById('workflow-description').textContent = config.desc;

      // Handle custom layouts
      const ugcLayout = document.getElementById('ugc-video-layout');
      const motionLayout = document.getElementById('motion-transfer-layout');
      const genericForm = document.getElementById('workflow-form');
      const uploadZone = document.getElementById('workflow-upload-zone');
      const promptBar = document.querySelector('.prompt-container');

      // Hide all custom layouts first
      ugcLayout.style.display = 'none';
      motionLayout.style.display = 'none';
      genericForm.style.display = 'none';
      uploadZone.style.display = 'none';

      if (config.customLayout === 'ugc-video') {
        ugcLayout.style.display = 'grid';
        if (promptBar) promptBar.style.display = 'none';
      } else if (config.customLayout === 'motion-transfer') {
        motionLayout.style.display = 'grid';
        if (promptBar) promptBar.style.display = 'none';
        // Stop any active webcam when switching away
        stopWebcam();
      } else {
        // Show generic form
        genericForm.style.display = 'block';
        if (promptBar) promptBar.style.display = 'block';
        
        // Show/hide form fields
        document.getElementById('url-field').style.display = config.showUrl ? 'flex' : 'none';
        document.getElementById('script-field').style.display = config.showScript ? 'flex' : 'none';
        uploadZone.style.display = config.showUpload ? 'block' : 'none';
        document.getElementById('workflow-upload-hint').textContent = config.uploadHint;
      }

      // Clear form inputs (but preserve results per workflow)
      document.getElementById('workflow-url').value = '';
      document.getElementById('workflow-script').value = '';
      workflowFiles = [];
      renderWorkflowPreviews();

      // Restore workflow-specific results (don't clear - each workflow keeps its results)
      workflowResults = workflowResultsCache[workflow] || [];
      renderWorkflowResults();
    }

    // File upload handling
    const workflowUploadZone = document.getElementById('workflow-upload-zone');
    const workflowFileInput = document.getElementById('workflow-file-input');

    workflowUploadZone.addEventListener('click', (e) => {
      if (e.target.closest('.workflow-preview-remove')) return;
      workflowFileInput.click();
    });

    workflowUploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      workflowUploadZone.classList.add('dragover');
    });

    workflowUploadZone.addEventListener('dragleave', () => {
      workflowUploadZone.classList.remove('dragover');
    });

    workflowUploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      workflowUploadZone.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files);
      workflowFiles.push(...files);
      renderWorkflowPreviews();
    });

    workflowFileInput.addEventListener('change', () => {
      const files = Array.from(workflowFileInput.files);
      workflowFiles.push(...files);
      renderWorkflowPreviews();
      workflowFileInput.value = '';
    });

    function renderWorkflowPreviews() {
      const container = document.getElementById('workflow-upload-preview');
      container.classList.toggle('has-files', workflowFiles.length > 0);
      
      container.innerHTML = workflowFiles.map((file, i) => {
        const isVideo = file.type.startsWith('video/');
        const url = URL.createObjectURL(file);
        return `
          <div class="workflow-preview-item">
            ${isVideo 
              ? `<video src="${url}" muted></video>`
              : `<img src="${url}" alt="${file.name}">`
            }
            <button class="workflow-preview-remove" onclick="removeWorkflowFile(${i})"></button>
          </div>
        `;
      }).join('');
    }

    window.removeWorkflowFile = function(index) {
      workflowFiles.splice(index, 1);
      renderWorkflowPreviews();
    };

    // Form submission
    document.getElementById('workflow-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      await runWorkflow();
    });

    // ===== UGC VIDEO WORKFLOW HANDLERS =====
    let ugcAvatarFile = null;
    let elevenLabsVoices = [];
    let selectedVoiceId = '';

    // Load ElevenLabs voices
    async function loadElevenLabsVoices() {
      try {
        const res = await fetch('/api/elevenlabs/voices');
        const data = await res.json();
        elevenLabsVoices = data.voices || [];
        console.log(`Loaded ${elevenLabsVoices.length} ElevenLabs voices`);
        renderVoiceDropdown(elevenLabsVoices);
      } catch (err) {
        console.error('Failed to load voices:', err);
      }
    }

    function renderVoiceDropdown(voices) {
      const dropdown = document.getElementById('ugc-voice-dropdown');
      dropdown.innerHTML = voices.slice(0, 50).map(v => `
        <div class="ugc-voice-option" data-id="${v.id}" data-name="${v.name}">
          <div>
            <div class="ugc-voice-name">${v.name}</div>
            <div class="ugc-voice-category">${v.category || ''} ${v.labels?.gender || ''}</div>
          </div>
          ${v.previewUrl ? `<button class="ugc-voice-preview-btn" onclick="event.stopPropagation(); playVoicePreview('${v.previewUrl}')"> Preview</button>` : ''}
        </div>
      `).join('');
    }

    window.playVoicePreview = function(url) {
      const audio = new Audio(url);
      audio.play();
    };

    // Voice search functionality
    const voiceSearch = document.getElementById('ugc-voice-search');
    const voiceDropdown = document.getElementById('ugc-voice-dropdown');
    const voiceInput = document.getElementById('ugc-voice');

    voiceSearch.addEventListener('focus', () => {
      voiceDropdown.classList.add('open');
      if (elevenLabsVoices.length === 0) loadElevenLabsVoices();
    });

    voiceSearch.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase();
      const filtered = elevenLabsVoices.filter(v => 
        v.name.toLowerCase().includes(query) ||
        (v.labels?.accent || '').toLowerCase().includes(query) ||
        (v.labels?.gender || '').toLowerCase().includes(query)
      );
      renderVoiceDropdown(filtered);
      voiceDropdown.classList.add('open');
    });

    voiceDropdown.addEventListener('click', (e) => {
      const option = e.target.closest('.ugc-voice-option');
      if (option && !e.target.classList.contains('ugc-voice-preview-btn')) {
        const id = option.dataset.id;
        const name = option.dataset.name;
        voiceInput.value = id;
        voiceSearch.value = name;
        selectedVoiceId = id;
        voiceDropdown.classList.remove('open');
      }
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.ugc-voice-search-container')) {
        voiceDropdown.classList.remove('open');
      }
    });

    // Load voices on page load
    loadElevenLabsVoices();

    const ugcAvatarUpload = document.getElementById('ugc-avatar-upload');
    const ugcAvatarInput = document.getElementById('ugc-avatar-input');

    ugcAvatarUpload.addEventListener('click', () => ugcAvatarInput.click());
    
    ugcAvatarUpload.addEventListener('dragover', (e) => {
      e.preventDefault();
      ugcAvatarUpload.classList.add('dragover');
    });
    
    ugcAvatarUpload.addEventListener('dragleave', () => {
      ugcAvatarUpload.classList.remove('dragover');
    });
    
    ugcAvatarUpload.addEventListener('drop', (e) => {
      e.preventDefault();
      ugcAvatarUpload.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        setUgcAvatar(file);
      }
    });
    
    ugcAvatarInput.addEventListener('change', () => {
      const file = ugcAvatarInput.files[0];
      if (file) setUgcAvatar(file);
    });

    function setUgcAvatar(file) {
      ugcAvatarFile = file;
      const url = URL.createObjectURL(file);
      
      // Remove existing preview
      const existingPreview = ugcAvatarUpload.querySelector('.avatar-preview');
      if (existingPreview) existingPreview.remove();
      
      // Add preview image
      const img = document.createElement('img');
      img.src = url;
      img.className = 'avatar-preview';
      ugcAvatarUpload.appendChild(img);
      ugcAvatarUpload.classList.add('has-image');
    }

    // UGC Generate button
    document.getElementById('ugc-generate-btn').addEventListener('click', async () => {
      const script = document.getElementById('ugc-script').value.trim();
      const voice = document.getElementById('ugc-voice').value;
      
      if (!ugcAvatarFile) {
        alert('Please upload an avatar image');
        return;
      }
      if (!script) {
        alert('Please enter a script');
        return;
      }
      if (!voice) {
        alert('Please select a voice');
        return;
      }

      const btn = document.getElementById('ugc-generate-btn');
      btn.disabled = true;
      btn.textContent = 'Generating...';

      // Show loading in results
      workflowResults = [{ loading: true, id: 'loading-0', isVideo: true }];
      renderWorkflowResults();

      try {
        // Convert avatar file to base64 for the API
        const avatarBase64 = await new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.readAsDataURL(ugcAvatarFile);
        });

        const response = await fetch('/api/ugc/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            script,
            voiceId: voice,
            avatarFile: avatarBase64,
            avatarUrl: null
          })
        });

        const data = await response.json();
        
        if (data.videoUrl) {
          workflowResults = [{ 
            url: data.videoUrl, 
            isVideo: true,
            downloadUrl: data.downloadUrl || data.videoUrl
          }];
        } else if (data.jobId) {
          // Poll for completion
          await pollUgcVideoStatus(data.jobId);
        } else {
          workflowResults = [];
          console.error('UGC video error:', data);
        }
        renderWorkflowResults();
      } catch (err) {
        console.error('UGC video error:', err);
        workflowResults = [];
        renderWorkflowResults();
      } finally {
        btn.disabled = false;
        btn.textContent = 'Generate';
      }
    });

    async function pollUgcVideoStatus(jobId) {
      return new Promise((resolve) => {
        const pollInterval = setInterval(async () => {
          try {
            const res = await fetch(`/api/ugc/status/${jobId}`);
            const status = await res.json();
            
            if (status.status === 'complete' && status.videoUrl) {
              clearInterval(pollInterval);
              workflowResults = [{ 
                url: status.videoUrl, 
                isVideo: true,
                downloadUrl: status.downloadUrl || status.videoUrl
              }];
              renderWorkflowResults();
              resolve();
            } else if (status.status === 'error') {
              clearInterval(pollInterval);
              workflowResults = [];
              renderWorkflowResults();
              resolve();
            }
          } catch (err) {
            console.error('Poll error:', err);
          }
        }, 3000);
      });
    }

    // ===== MOTION TRANSFER WORKFLOW HANDLERS =====
    let webcamStream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordedBlob = null;
    let characterFile = null;
    let recordingTimer = null;
    let recordingSeconds = 0;

    const webcamVideo = document.getElementById('webcam-video');
    const webcamPlayback = document.getElementById('webcam-playback');
    const webcamPlaceholder = document.getElementById('webcam-placeholder');
    const webcamTimer = document.getElementById('webcam-timer');
    const startBtn = document.getElementById('webcam-start-btn');
    const stopBtn = document.getElementById('webcam-stop-btn');
    const retryBtn = document.getElementById('webcam-retry-btn');
    const characterUpload = document.getElementById('character-upload');
    const characterInput = document.getElementById('character-input');
    const motionGenerateBtn = document.getElementById('motion-generate-btn');

    function stopWebcam() {
      if (webcamStream) {
        webcamStream.getTracks().forEach(track => track.stop());
        webcamStream = null;
      }
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
      clearInterval(recordingTimer);
    }

    startBtn?.addEventListener('click', async () => {
      try {
        webcamStream = await navigator.mediaDevices.getUserMedia({ 
          video: { width: 720, height: 1280, facingMode: 'user' }, 
          audio: false 
        });
        webcamVideo.srcObject = webcamStream;
        webcamVideo.style.display = 'block';
        webcamPlayback.style.display = 'none';
        webcamPlaceholder.style.display = 'none';
        
        // Start recording
        recordedChunks = [];
        mediaRecorder = new MediaRecorder(webcamStream, { mimeType: 'video/webm;codecs=vp9' });
        
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) recordedChunks.push(e.data);
        };
        
        mediaRecorder.onstop = () => {
          recordedBlob = new Blob(recordedChunks, { type: 'video/webm' });
          webcamPlayback.src = URL.createObjectURL(recordedBlob);
          webcamVideo.style.display = 'none';
          webcamPlayback.style.display = 'block';
          stopBtn.style.display = 'none';
          retryBtn.style.display = 'inline-flex';
          webcamTimer.classList.remove('recording');
          clearInterval(recordingTimer);
        };
        
        mediaRecorder.start();
        
        // Update UI
        startBtn.style.display = 'none';
        stopBtn.style.display = 'inline-flex';
        retryBtn.style.display = 'none';
        webcamTimer.classList.add('recording');
        
        // Start timer
        recordingSeconds = 0;
        recordingTimer = setInterval(() => {
          recordingSeconds++;
          const mins = Math.floor(recordingSeconds / 60);
          const secs = recordingSeconds % 60;
          webcamTimer.textContent = ` REC ${mins}:${secs.toString().padStart(2, '0')}`;
        }, 1000);
        
      } catch (err) {
        console.error('Webcam error:', err);
        alert('Could not access webcam. Please allow camera permissions.');
      }
    });

    stopBtn?.addEventListener('click', () => {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        stopWebcam();
      }
    });

    retryBtn?.addEventListener('click', () => {
      recordedBlob = null;
      webcamPlayback.style.display = 'none';
      webcamPlaceholder.style.display = 'flex';
      startBtn.style.display = 'inline-flex';
      retryBtn.style.display = 'none';
    });

    // Character upload
    characterUpload?.addEventListener('click', () => characterInput?.click());
    
    characterUpload?.addEventListener('dragover', (e) => {
      e.preventDefault();
      characterUpload.classList.add('dragover');
    });
    
    characterUpload?.addEventListener('dragleave', () => {
      characterUpload.classList.remove('dragover');
    });
    
    characterUpload?.addEventListener('drop', (e) => {
      e.preventDefault();
      characterUpload.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        setCharacterImage(file);
      }
    });
    
    characterInput?.addEventListener('change', () => {
      const file = characterInput.files[0];
      if (file) setCharacterImage(file);
    });

    function setCharacterImage(file) {
      characterFile = file;
      const url = URL.createObjectURL(file);
      
      const existingPreview = characterUpload.querySelector('.character-preview');
      if (existingPreview) existingPreview.remove();
      
      const img = document.createElement('img');
      img.src = url;
      img.className = 'character-preview';
      characterUpload.appendChild(img);
      characterUpload.classList.add('has-image');
    }

    // Generate motion transfer
    motionGenerateBtn?.addEventListener('click', async () => {
      if (!recordedBlob) {
        alert('Please record a video first');
        return;
      }
      if (!characterFile) {
        alert('Please upload a character image');
        return;
      }

      motionGenerateBtn.disabled = true;
      motionGenerateBtn.textContent = 'Generating...';

      // Show loading in results
      workflowResults = [{ loading: true, id: 'loading-0', isVideo: true }];
      renderWorkflowResults();

      try {
        const formData = new FormData();
        formData.append('video', recordedBlob, 'webcam.webm');
        formData.append('image', characterFile);
        formData.append('model', 'kling-motion-pro');

        const response = await fetch('/api/motion-transfer', {
          method: 'POST',
          body: formData
        });

        const data = await response.json();
        
        if (data.videoUrl) {
          workflowResults = [{ 
            url: data.videoUrl, 
            isVideo: true,
            downloadUrl: data.downloadUrl || data.videoUrl
          }];
        } else if (data.jobId || data.taskId) {
          await pollMotionTransferStatus(data.jobId || data.taskId);
        } else {
          workflowResults = [];
          console.error('Motion transfer error:', data);
        }
        renderWorkflowResults();
      } catch (err) {
        console.error('Motion transfer error:', err);
        workflowResults = [];
        renderWorkflowResults();
      } finally {
        motionGenerateBtn.disabled = false;
        motionGenerateBtn.textContent = 'Generate Motion Transfer';
      }
    });

    async function pollMotionTransferStatus(taskId) {
      return new Promise((resolve) => {
        const pollInterval = setInterval(async () => {
          try {
            const res = await fetch(`/api/motion-transfer/status/${taskId}`);
            const status = await res.json();
            
            if (status.status === 'complete' && status.videoUrl) {
              clearInterval(pollInterval);
              workflowResults = [{ 
                url: status.videoUrl, 
                isVideo: true,
                downloadUrl: status.downloadUrl || status.videoUrl
              }];
              renderWorkflowResults();
              resolve();
            } else if (status.status === 'error' || status.status === 'failed') {
              clearInterval(pollInterval);
              workflowResults = [];
              renderWorkflowResults();
              resolve();
            }
          } catch (err) {
            console.error('Poll error:', err);
          }
        }, 3000);
      });
    }

    async function runWorkflow() {
      const config = workflowConfigs[currentWorkflow];
      const submitBtn = document.getElementById('workflow-submit');
      submitBtn.disabled = true;
      submitBtn.textContent = 'Generating...';

      try {
        if (currentWorkflow === 'kickstarter') {
          await runKickstarterWorkflow();
        } else if (currentWorkflow === 'motion-transfer') {
          await runMotionTransferWorkflow();
        } else if (currentWorkflow === 'script-to-video' || currentWorkflow === 'script-explainer') {
          await runScriptToVideoWorkflow();
        } else {
          // Generic workflow handler (TODO: implement others)
          console.log('Workflow not yet implemented:', currentWorkflow);
        }
      } catch (err) {
        console.error('Workflow error:', err);
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Generate';
      }
    }

    async function runKickstarterWorkflow() {
      const url = document.getElementById('workflow-url').value.trim();
      if (!url) return;

      // Add loading placeholders
      workflowResults = Array(7).fill().map((_, i) => ({ loading: true, id: 'loading-' + i }));
      renderWorkflowResults();

      const response = await fetch('/api/kickstarter', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url })
      });
      
      const data = await response.json();
      if (!data.jobId) {
        workflowResults = [];
        renderWorkflowResults();
        return;
      }

      // Poll for status
      const pollInterval = setInterval(async () => {
        try {
          const statusRes = await fetch(`/api/kickstarter/status/${data.jobId}`);
          const status = await statusRes.json();
          
          if (status.generatedImages && status.generatedImages.length > 0) {
            workflowResults = status.generatedImages.map(img => ({
              url: img.thumbnail || img.url || img,
              fullRes: img.fullRes || img.url || img,
              thumbnail: img.thumbnail || img.url || img
            }));
            renderWorkflowResults();
          }

          if (status.status === 'complete' || status.status === 'error') {
            clearInterval(pollInterval);
          }
        } catch (err) {
          console.error('Poll error:', err);
        }
      }, 3000);
    }

    async function runMotionTransferWorkflow() {
      if (workflowFiles.length < 2) {
        alert('Please upload an image and a driving video');
        return;
      }

      const formData = new FormData();
      formData.append('model', 'kling-motion-pro');
      formData.append('type', 'video-to-video');
      
      // First file should be image, second should be video
      workflowFiles.forEach((file, i) => {
        if (file.type.startsWith('image/')) {
          formData.append('image', file);
        } else if (file.type.startsWith('video/')) {
          formData.append('video', file);
        }
      });

      workflowResults = [{ loading: true, id: 'loading-0' }];
      renderWorkflowResults();

      const response = await fetch('/api/runcomfy/generate', {
        method: 'POST',
        body: formData
      });

      const data = await response.json();
      if (data.videoUrl) {
        workflowResults = [{ url: data.videoUrl, isVideo: true }];
      } else if (data.taskId) {
        // Poll for completion
        await pollRunComfyStatus(data.taskId);
      } else {
        workflowResults = [];
      }
      renderWorkflowResults();
    }

    async function runScriptToVideoWorkflow() {
      const script = document.getElementById('workflow-script')?.value?.trim();
      if (!script) {
        alert('Please enter a script');
        return;
      }

      // Add loading placeholders
      workflowResults = Array(5).fill().map((_, i) => ({ loading: true, id: 'loading-' + i }));
      renderWorkflowResults();

      try {
        const response = await fetch('/api/script-explainer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ script })
        });
        
        const data = await response.json();
        if (data.jobId) {
          // Poll for status
          const pollInterval = setInterval(async () => {
            try {
              const statusRes = await fetch(`/api/script-explainer/status/${data.jobId}`);
              const status = await statusRes.json();
              
              if (status.status === 'complete' && status.results) {
                clearInterval(pollInterval);
                workflowResults = status.results.map(r => ({
                  url: r.url || r,
                  thumbnail: r.thumbnail,
                  fullRes: r.fullRes || r.url || r
                }));
                renderWorkflowResults();
              } else if (status.status === 'error') {
                clearInterval(pollInterval);
                workflowResults = [];
                renderWorkflowResults();
              }
            } catch (err) {
              console.error('Poll error:', err);
            }
          }, 3000);
        } else if (data.results) {
          workflowResults = data.results.map(r => ({
            url: r.url || r,
            thumbnail: r.thumbnail,
            fullRes: r.fullRes || r.url || r
          }));
          renderWorkflowResults();
        } else {
          workflowResults = [];
          renderWorkflowResults();
        }
      } catch (err) {
        console.error('Script workflow error:', err);
        workflowResults = [];
        renderWorkflowResults();
      }
    }

    async function pollRunComfyStatus(taskId) {
      // TODO: implement polling for RunComfy tasks
      console.log('Polling for task:', taskId);
    }

    function renderWorkflowResults() {
      const grid = document.getElementById('workflow-results-grid');
      const empty = document.getElementById('workflow-results-empty');
      const count = document.getElementById('workflow-results-count');

      // Save results to workflow-specific cache (skip if only loading states)
      const hasRealResults = workflowResults.some(r => r.url);
      if (hasRealResults && currentWorkflow) {
        workflowResultsCache[currentWorkflow] = [...workflowResults];
      }

      const actualResults = workflowResults.filter(r => r.url);
      count.textContent = actualResults.length;

      if (workflowResults.length === 0) {
        grid.innerHTML = '';
        empty.style.display = 'block';
        return;
      }

      empty.style.display = 'none';
      grid.innerHTML = workflowResults.map((result, i) => {
        if (result.loading) {
          return `
            <div class="workflow-result-item workflow-result-loading">
              <div class="grid-item-spinner"></div>
            </div>
          `;
        }
        
        if (result.isVideo) {
          const downloadUrl = result.downloadUrl || result.url;
          return `
            <div class="workflow-result-item workflow-result-video">
              <video src="${result.url}" controls muted></video>
              <a href="${downloadUrl}" download class="workflow-download-link" target="_blank">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="16" height="16">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                </svg>
                Download Video
              </a>
            </div>
          `;
        }
        
        // Use thumbnail for display, store fullRes for later use
        const displayUrl = result.thumbnail || result.url;
        const fullResUrl = result.fullRes || result.url;
        return `
          <div class="workflow-result-item" onclick="addToMainGrid('${fullResUrl}')" data-full-res="${fullResUrl}">
            <img src="${displayUrl}" alt="Result ${i + 1}" loading="lazy">
          </div>
        `;
      }).join('');
    }

    window.addToMainGrid = function(url) {
      images.unshift({
        url: url,
        prompt: currentWorkflow + ' workflow output',
        ratio: '9:16',
        model: 'workflow',
        createdAt: new Date().toISOString(),
        saved: false
      });
      saveImages();
      renderGrid();
      // Switch to Images tab
      document.querySelector('[data-tab="images"]').click();
    };

    // Legacy shortcut-card handler (for compatibility)
    document.querySelectorAll('.shortcut-card').forEach(card => {
      card.addEventListener('click', () => {
        const workflow = card.dataset.workflow;
        selectWorkflow(workflow);
        document.querySelector('[data-tab="shortcuts"]').click();
      });
    });

    // Legacy showWorkflowModal - now redirects to workflow studio
    function showWorkflowModal(workflow) {
      selectWorkflow(workflow);
      document.querySelector('[data-tab="shortcuts"]').click();
    }

    // ===== CONTEXT PROFILES (disabled in UI) =====
    const contextSelect = document.getElementById('context-profile');
    const newContextBtn = document.getElementById('new-context-btn');

    // Only run if context UI elements exist
    if (contextSelect && newContextBtn) {
      async function loadContextProfiles() {
      try {
        const response = await fetch('/api/context/profiles');
        if (response.ok) {
          const data = await response.json();
          // Clear existing options except "No context"
          contextSelect.innerHTML = '<option value="">No context</option>';
          // Add profiles
          data.profiles.forEach(profile => {
            const option = document.createElement('option');
            option.value = profile.id;
            option.textContent = profile.name || profile.id;
            option.title = profile.tagline || '';
            contextSelect.appendChild(option);
          });
          // Restore selection from localStorage
          const savedContext = localStorage.getItem('aditor_context_profile');
          if (savedContext && data.profiles.find(p => p.id === savedContext)) {
            contextSelect.value = savedContext;
          }
        }
      } catch (err) {
        console.error('Failed to load context profiles:', err);
      }
    }

    // Save selection to localStorage
    contextSelect.addEventListener('change', () => {
      localStorage.setItem('aditor_context_profile', contextSelect.value);
      if (contextSelect.value) {
        console.log(' Context profile active:', contextSelect.value);
      }
    });

    // New context profile modal
    newContextBtn.addEventListener('click', () => {
      showContextModal();
    });

    function showContextModal() {
      const overlay = document.createElement('div');
      overlay.className = 'context-modal-overlay';
      overlay.innerHTML = `
        <div class="context-modal">
          <h2>Create Context Profile</h2>
          <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
            Describe your brand or product. The AI will create a consistent style guide for all generations.
          </p>
          <input type="text" class="context-name-input" placeholder="Profile name (e.g., wellness-brand)" />
          <textarea class="context-vision-input" placeholder="Describe your brand vision, target audience, visual style, product type...

Example: Premium wellness supplement brand targeting health-conscious millennials. Clean, minimal aesthetic with earth tones. Products are organic, science-backed. Think Ritual meets Athletic Greens."></textarea>
          <div class="context-modal-actions">
            <button class="context-cancel-btn">Cancel</button>
            <button class="context-generate-btn">Generate Profile</button>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);

      const nameInput = overlay.querySelector('.context-name-input');
      const visionInput = overlay.querySelector('.context-vision-input');
      const generateBtn = overlay.querySelector('.context-generate-btn');
      const cancelBtn = overlay.querySelector('.context-cancel-btn');

      cancelBtn.addEventListener('click', () => overlay.remove());
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) overlay.remove();
      });

      generateBtn.addEventListener('click', async () => {
        const name = nameInput.value.trim();
        const vision = visionInput.value.trim();
        
        if (!vision) {
          visionInput.style.borderColor = 'red';
          return;
        }

        generateBtn.textContent = 'Generating...';
        generateBtn.disabled = true;

        try {
          const response = await fetch('/api/context/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, vision })
          });

          if (response.ok) {
            const data = await response.json();
            console.log(' Context profile created:', data.profile);
            await loadContextProfiles();
            contextSelect.value = data.profile.id;
            localStorage.setItem('aditor_context_profile', data.profile.id);
            overlay.remove();
          } else {
            const err = await response.json();
            alert('Failed to generate profile: ' + (err.error || 'Unknown error'));
            generateBtn.textContent = 'Generate Profile';
            generateBtn.disabled = false;
          }
        } catch (err) {
          console.error('Context generation error:', err);
          alert('Failed to generate profile');
          generateBtn.textContent = 'Generate Profile';
          generateBtn.disabled = false;
        }
      });

      nameInput.focus();
    }
    } // end if (contextSelect && newContextBtn)

    // ===== INIT =====
    renderGrid();
    // loadContextProfiles(); // disabled - context UI removed
    
    // Initialize workflow (UGC video is default, needs custom layout)
    selectWorkflow('script-to-video');
    
    // Ensure prompt bar is visible on Images tab (default)
    const activeTab = document.querySelector('.nav-tab.active');
    if (activeTab && activeTab.dataset.tab === 'images') {
      const promptContainer = document.querySelector('.prompt-container');
      if (promptContainer) promptContainer.style.display = 'block';
    }

    // ===== RETRY SINGLE BULK VIDEO =====
    async function retrySingleBulkVideo(taskId) {
      const item = bulkItems.find(it => it.taskId === taskId);
      if (!item) return;
      
      item.status = 'generating';
      item.error = null;
      renderBulkJobsInVideoTab();
      
      try {
        const duration = parseInt(document.getElementById('bulk-duration')?.value || '5');
        const res = await fetch('/api/bulk-i2v/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            items: [{ url: item.url, prompt: item.prompt }], 
            duration,
            mode: 'std'
          })
        });
        const data = await res.json();
        
        if (data.batch && data.batch.jobs && data.batch.jobs[0]) {
          item.taskId = data.batch.jobs[0].id;
          item.status = data.batch.jobs[0].status === 'failed' ? 'error' : 'generating';
          
          // Start polling if not already
          if (!bulkPollInterval) {
            bulkBatchId = data.batchId;
            bulkPollInterval = setInterval(pollBulkStatus, 5000);
          }
        }
        
        renderBulkJobsInVideoTab();
        // Button already shows generating state
      } catch (err) {
        console.error('[Bulk I2V] Retry failed:', err);
        item.status = 'error';
        item.error = err.message;
        renderBulkJobsInVideoTab();
        // Error state shown on the item itself
      }
    }

    // ===== DOWNLOAD ALL BULK VIDEOS =====
    async function downloadAllBulkVideos() {
      const doneItems = bulkItems.filter(it => it.status === 'done' && it.videoUrl);
      if (!doneItems.length) return;
      
      const btn = document.getElementById('bulk-download-btn');
      if (btn) {
        btn.disabled = true;
        btn.innerHTML = `<svg class="spin" width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="31.4" stroke-dashoffset="10"/></svg> Zipping...`;
      }
      
      try {
        const urls = doneItems.map(it => it.videoUrl);
        const res = await fetch('/api/proxy/zip-videos', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ urls, batchId: 'all' })
        });
        if (!res.ok) throw new Error('Zip failed');
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `broll-all.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error('Zip download failed:', err);
        // Fallback: open first video
        if (doneItems[0]) window.open(`/api/proxy/video?url=${encodeURIComponent(doneItems[0].videoUrl)}&filename=video.mp4`, '_blank');
      }
      
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = `<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg> Downloaded `;
        setTimeout(() => {
          btn.innerHTML = `<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg> Download All (${doneItems.length})`;
        }, 2000);
      }
    }

    // ===== TOAST NOTIFICATIONS =====
    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = 'toast-notification';
      toast.style.cssText = `
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        background: ${type === 'success' ? '#22c55e' : type === 'error' ? '#ef4444' : '#3b82f6'};
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        z-index: 10000;
        animation: slideUp 0.3s ease;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      `;
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => {
        toast.style.animation = 'fadeOut 0.3s ease forwards';
        setTimeout(() => toast.remove(), 300);
      }, 4000);
    }

    // ===== BULK I2V TERMINAL MODE =====
    let bulkItems = []; // { id, file, url, filename, prompt, displayedPrompt, status, taskId, videoUrl }
    let bulkBatchId = null;
    let bulkPollInterval = null;
    let bulkMode = false;

    // Load bulk jobs from backend on page load
    // Video tab gets ALL historical data, prompt tab only gets actively generating jobs
    (async function loadActiveBulkJobs() {
      try {
        const res = await fetch('/api/bulk-i2v/jobs');
        const data = await res.json();
        if (data.batches && data.batches.length > 0) {
          // Separate: video tab items (all done/failed) vs prompt tab items (only generating)
          let videoTabItems = [];
          let promptTabItems = [];
          let generatingBatchId = null;
          
          for (const batch of data.batches) {
            for (const j of batch.jobs) {
              const item = {
                id: j.id,
                batchId: batch.id,
                url: j.imageUrl || '',
                filename: j.imageUrl ? j.imageUrl.split('/').pop() : '',
                prompt: j.prompt || '',
                displayedPrompt: j.prompt || '',
                status: j.status === 'failed' ? 'error' : j.status === 'done' ? 'done' : 'generating',
                taskId: j.id,
                videoUrl: j.videoUrl || null
              };
              
              // All done/error/generating go to video tab
              if (j.status === 'done' || j.status === 'failed' || j.status === 'generating') {
                videoTabItems.push(item);
              }
              
              // Only generating go to prompt tab (for active progress)
              if (j.status === 'generating') {
                promptTabItems.push(item);
                generatingBatchId = batch.id;
              }
            }
          }
          
          // Populate bulkItems ONLY with generating jobs (prompt tab)
          bulkItems = promptTabItems;
          
          // Store video tab items separately for rendering
          window._bulkVideoTabItems = videoTabItems;
          
          if (videoTabItems.length > 0) {
            console.log(`[Bulk I2V] Loaded ${videoTabItems.length} jobs for video tab, ${promptTabItems.length} generating`);
            renderBulkJobsInVideoTab();
            updateVideoTabBadge();
          }
          
          // Resume polling and show prompt tab only if still generating
          if (promptTabItems.length > 0) {
            bulkBatchId = generatingBatchId;
            bulkMode = true;
            promptBar.classList.add('bulk-mode');
            renderBulkTerminal();
            bulkPollInterval = setInterval(pollBulkStatus, 5000);
          }
        }
      } catch (err) {
        console.log('[Bulk I2V] No active jobs to load');
      }
    })();

    const bulkTerminal = document.getElementById('bulk-terminal');
    const bulkTerminalBody = document.getElementById('bulk-terminal-body');
    const bulkFileInput = document.getElementById('bulk-file-input');
    const bulkCloseBtn = document.getElementById('bulk-close');
    const bulkAnalyzeBtn = document.getElementById('bulk-analyze-btn');
    const bulkGenerateBtn = document.getElementById('bulk-generate-btn');
    const bulkProgressBar = document.getElementById('bulk-progress-bar');

    // Enter bulk mode when multiple images are dropped
    function enterBulkMode() {
      if (bulkMode) return;
      bulkMode = true;
      promptBar.classList.add('bulk-mode');
      console.log('[Bulk I2V] Entered terminal mode');
    }

    // Exit bulk mode
    function exitBulkMode() {
      bulkMode = false;
      promptBar.classList.remove('bulk-mode');
      bulkItems = [];
      bulkBatchId = null;
      if (bulkPollInterval) {
        clearInterval(bulkPollInterval);
        bulkPollInterval = null;
      }
      renderBulkTerminal();
      console.log('[Bulk I2V] Exited terminal mode');
    }

    bulkCloseBtn.addEventListener('click', exitBulkMode);

    // Handle file drops on prompt bar for bulk mode ONLY (single drops handled by earlier listener)
    // NOTE: Removed duplicate single-image handling - the handler at line ~3625 already does this

    // Also allow dropping on the whole main area when in Images tab
    document.querySelector('#images-section')?.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    document.querySelector('#images-section')?.addEventListener('drop', async (e) => {
      e.preventDefault();
      const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
      if (files.length > 1) {
        enterBulkMode();
        await handleBulkFiles(files);
      }
    });

    // Handle bulk file upload
    async function handleBulkFiles(files) {
      if (!files.length) return;
      
      const formData = new FormData();
      for (const f of files) {
        formData.append('images', f);
        // Add placeholder immediately with loading state
        bulkItems.push({
          id: 'temp-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
          file: f,
          url: URL.createObjectURL(f),
          filename: f.name,
          prompt: '',
          displayedPrompt: '',
          status: 'uploading',
          taskId: null,
          videoUrl: null
        });
      }
      renderBulkTerminal();

      try {
        const res = await fetch('/api/bulk-i2v/upload', { method: 'POST', body: formData });
        const data = await res.json();
        if (data.error) throw new Error(data.error);

        // Update items with server URLs
        for (const img of data.images) {
          const item = bulkItems.find(it => it.filename === img.filename);
          if (item) {
            item.url = img.url;
            item.status = 'uploaded';
          }
        }
        renderBulkTerminal();
        updateBulkStats();
        console.log(`[Bulk I2V] Uploaded ${data.images.length} images`);
        
        // Auto-start analysis immediately after upload
        bulkAnalyzeBtn.click();
      } catch (err) {
        console.error('[Bulk I2V] Upload failed:', err);
        bulkItems.forEach(it => {
          if (it.status === 'uploading') it.status = 'error';
        });
        renderBulkTerminal();
      }
    }

    // Analyze with Gemini
    bulkAnalyzeBtn.addEventListener('click', async () => {
      const toAnalyze = bulkItems.filter(it => !it.prompt && it.status !== 'analyzing');
      if (!toAnalyze.length) return;

      bulkAnalyzeBtn.disabled = true;
      bulkAnalyzeBtn.innerHTML = '<svg class="spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" width="14" height="14"><circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="31.4" stroke-dashoffset="10"/></svg> Analyzing...';
      
      toAnalyze.forEach(it => it.status = 'analyzing');
      renderBulkTerminal();

      try {
        const res = await fetch('/api/bulk-i2v/analyze', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ images: toAnalyze.map(it => ({ url: it.url, filename: it.filename })) })
        });
        const data = await res.json();

        // Start typewriter effect for each result
        for (const result of data.results) {
          const item = bulkItems.find(it => it.filename === result.filename);
          if (item && result.prompt) {
            item.prompt = result.prompt;
            item.status = 'ready';
            // Start typewriter animation
            typewriterPrompt(item);
          } else if (item) {
            item.status = 'error';
          }
        }
        
        renderBulkTerminal();
        updateBulkStats();
      } catch (err) {
        console.error('[Bulk I2V] Analysis failed:', err);
        toAnalyze.forEach(it => it.status = 'error');
        renderBulkTerminal();
      }

      bulkAnalyzeBtn.disabled = false;
      bulkAnalyzeBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg> Analyze';
    });

    // Typewriter effect for prompts
    function typewriterPrompt(item) {
      const fullPrompt = item.prompt;
      let charIndex = 0;
      item.displayedPrompt = '';
      item.isTyping = true;
      
      const typeInterval = setInterval(() => {
        if (charIndex < fullPrompt.length) {
          item.displayedPrompt += fullPrompt[charIndex];
          charIndex++;
          renderBulkTerminal();
        } else {
          item.isTyping = false;
          clearInterval(typeInterval);
          renderBulkTerminal();
        }
      }, 15); // 15ms per character for smooth typing
    }

    // Generate all videos
    bulkGenerateBtn.addEventListener('click', async () => {
      bulkGenerateBtn.disabled = true;
      bulkGenerateBtn.innerHTML = '<svg class="spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" width="14" height="14"><circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="31.4" stroke-dashoffset="10"/></svg> Processing...';

      // Auto-analyze any items that haven't been analyzed yet
      const unanalyzed = bulkItems.filter(it => !it.prompt && (it.status === 'uploaded' || it.status === 'uploading'));
      if (unanalyzed.length > 0) {
        // Wait for any still-uploading items
        let retries = 0;
        while (bulkItems.some(it => it.status === 'uploading') && retries < 30) {
          await new Promise(r => setTimeout(r, 500));
          retries++;
        }

        const toAnalyze = bulkItems.filter(it => !it.prompt && it.status === 'uploaded');
        toAnalyze.forEach(it => it.status = 'analyzing');
        renderBulkTerminal();

        try {
          const analyzeRes = await fetch('/api/bulk-i2v/analyze', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ imageUrls: toAnalyze.map(it => it.url) })
          });
          const analyzeData = await analyzeRes.json();
          if (analyzeData.results) {
            for (let i = 0; i < analyzeData.results.length; i++) {
              const item = toAnalyze[i];
              if (item && analyzeData.results[i]) {
                item.prompt = analyzeData.results[i].prompt;
                item.displayedPrompt = analyzeData.results[i].prompt;
                item.status = 'ready';
              }
            }
          }
          renderBulkTerminal();
        } catch (err) {
          console.error('[Bulk I2V] Auto-analyze failed:', err);
          toAnalyze.forEach(it => it.status = 'error');
          renderBulkTerminal();
          bulkGenerateBtn.disabled = false;
          bulkGenerateBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg> Generate All';
          return;
        }
      }

      const readyItems = bulkItems.filter(it => it.prompt && it.status === 'ready');
      if (!readyItems.length) {
        bulkGenerateBtn.disabled = false;
        bulkGenerateBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg> Generate All';
        return;
      }

      bulkGenerateBtn.innerHTML = '<svg class="spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" width="14" height="14"><circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="31.4" stroke-dashoffset="10"/></svg> Generating...';

      readyItems.forEach(it => it.status = 'generating');
      renderBulkTerminal();
      updateBulkProgress();

      try {
        const duration = parseInt(document.getElementById('bulk-duration').value);
        const res = await fetch('/api/bulk-i2v/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            items: readyItems.map(it => ({ url: it.url, prompt: it.prompt })), 
            duration,
            mode: 'std'
          })
        });
        const data = await res.json();
        bulkBatchId = data.batchId;

        // Map job IDs back
        if (data.batch && data.batch.jobs) {
          data.batch.jobs.forEach((job, idx) => {
            const item = readyItems[idx];
            if (item) {
              item.taskId = job.id;
              item.status = job.status === 'failed' ? 'error' : 'generating';
              item.error = job.error;
            }
          });
        }
        
        renderBulkTerminal();

        // Start polling in background
        if (bulkPollInterval) clearInterval(bulkPollInterval);
        bulkPollInterval = setInterval(pollBulkStatus, 5000);
        
        // Close terminal, clear references, switch to Videos tab
        setTimeout(() => {
          exitBulkMode();
          // Clear reference images from prompt field
          references = [];
          renderReferences();
          // Switch to Videos tab
          document.querySelector('.nav-tab[data-tab="videos"]')?.click();
          // Badge on Videos tab shows generating count
        }, 500);
      } catch (err) {
        console.error('[Bulk I2V] Generation failed:', err);
        readyItems.forEach(it => it.status = 'error');
        renderBulkTerminal();
        bulkGenerateBtn.disabled = false;
        bulkGenerateBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg> Generate All';
        return;
      }

      bulkGenerateBtn.disabled = false;
      bulkGenerateBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg> Generate All';
    });

    // Poll for generation status (handles multiple batches)
    async function pollBulkStatus() {
      try {
      // Get unique batch IDs that have generating items
      const generatingBatchIds = [...new Set(bulkItems.filter(it => it.status === 'generating' && it.batchId).map(it => it.batchId))];
      if (generatingBatchIds.length === 0 && !bulkBatchId) return;
      
      // Also include the current bulkBatchId if set
      const batchIds = bulkBatchId ? [...new Set([...generatingBatchIds, bulkBatchId])] : generatingBatchIds;
      
      let changed = false;
      for (const batchId of batchIds) {
        try {
          const res = await fetch(`/api/bulk-i2v/status/${batchId}`);
          const data = await res.json();
          
          if (data.batch && data.batch.jobs) {
            data.batch.jobs.forEach(job => {
              // Update bulkItems (prompt tab)
              const item = bulkItems.find(it => it.taskId === job.id);
              if (item) {
                if (job.status === 'done' && job.videoUrl && item.status !== 'done') {
                  item.status = 'done';
                  item.videoUrl = job.videoUrl;
                  changed = true;
                } else if (job.status === 'failed' && item.status !== 'error') {
                  item.status = 'error';
                  item.error = job.error;
                  changed = true;
                }
              }
              // Also update _bulkVideoTabItems (video tab history)
              if (window._bulkVideoTabItems) {
                const historyItem = window._bulkVideoTabItems.find(it => it.taskId === job.id);
                if (historyItem) {
                  if (job.status === 'done' && job.videoUrl) {
                    historyItem.status = 'done';
                    historyItem.videoUrl = job.videoUrl;
                    changed = true;
                  } else if (job.status === 'failed') {
                    historyItem.status = 'error';
                    historyItem.error = job.error;
                    changed = true;
                  }
                }
              }
            });
          }
        } catch (err) {
          console.log(`[Bulk I2V] Failed to poll batch ${batchId}`);
        }
      }
      
      // Only re-render when status actually changed
      if (changed) {
        renderBulkTerminal();
        updateBulkStats();
        updateBulkProgress();
        renderBulkJobsInVideoTab();
        updateVideoTabBadge();
      }

      // Check if all items are done
      const stillGenerating = bulkItems.some(it => it.status === 'generating');
      if (!stillGenerating) {
        clearInterval(bulkPollInterval);
        bulkPollInterval = null;
        const doneCount = bulkItems.filter(it => it.status === 'done').length;
        const failCount = bulkItems.filter(it => it.status === 'error').length;
        console.log(`[Bulk I2V] All complete: ${doneCount} done, ${failCount} failed`);
        
        // Auto-clear prompt tab UI after completion (videos are in Video tab now)
        if (doneCount > 0 && failCount === 0) {
          // All succeeded - clear prompt tab after brief delay
          setTimeout(() => {
            console.log('[Bulk I2V] Auto-clearing prompt tab (all done)');
            exitBulkMode();
          }, 2000);
        } else if (failCount > 0) {
          // Some failed - keep UI visible for retry buttons
          console.log('[Bulk I2V] Keeping prompt tab open for retries');
        }
      }
      } catch (err) {
        console.error('[Bulk I2V] Poll error:', err);
      }
    }

    // Update stats display
    function updateBulkStats() {
      document.getElementById('bulk-count-total').textContent = bulkItems.length;
      document.getElementById('bulk-count-ready').textContent = bulkItems.filter(it => it.status === 'ready').length;
      document.getElementById('bulk-count-done').textContent = bulkItems.filter(it => it.status === 'done').length;
      
      // Enable generate button as soon as we have any items (processing happens in background)
      bulkGenerateBtn.disabled = bulkItems.length === 0;
    }

    // Update progress bar
    function updateBulkProgress() {
      const generating = bulkItems.filter(it => it.status === 'generating' || it.status === 'done');
      const done = bulkItems.filter(it => it.status === 'done');
      
      if (generating.length === 0) {
        bulkProgressBar.style.width = '0%';
      } else {
        const progress = (done.length / generating.length) * 100;
        bulkProgressBar.style.width = `${progress}%`;
      }
    }

    // Render terminal lines
    function renderBulkTerminal() {
      bulkTerminalBody.innerHTML = bulkItems.map((item, i) => {
        const statusBadge = getStatusBadge(item.status);
        const promptClass = item.isTyping ? 'typing' : (item.status === 'analyzing' ? 'analyzing' : (item.status === 'error' ? 'error' : ''));
        const promptText = item.displayedPrompt || item.prompt || (item.status === 'analyzing' ? 'Analyzing with Gemini...' : (item.status === 'uploading' ? 'Uploading...' : ''));
        
        return `
          <div class="bulk-line" data-index="${i}">
            <div class="bulk-line-thumb">
              ${item.status === 'done' && item.videoUrl 
                ? `<video src="${item.videoUrl}" muted loop playsinline></video>`
                : `<img src="${item.url}" alt="${item.filename}">`
              }
            </div>
            <div class="bulk-line-content">
              <div class="bulk-line-filename">
                <span>${item.filename}</span>
                <span class="bulk-line-arrow"></span>
              </div>
              <div class="bulk-line-prompt ${promptClass}">${promptText || '...'}</div>
            </div>
            <div class="bulk-line-status">
              <span class="bulk-line-badge ${item.status}">${statusBadge}</span>
              ${item.status === 'done' && item.videoUrl ? `
                <button class="bulk-line-action play" onclick="playBulkVideo(${i})" title="Play">
                  <svg fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                </button>
                <button class="bulk-line-action" onclick="downloadBulkVideo(${i})" title="Download">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
                </button>
              ` : ''}
              <button class="bulk-line-action" onclick="removeBulkItem(${i})" title="Remove">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
              </button>
            </div>
          </div>
        `;
      }).join('');

      // Auto-play videos on hover
      bulkTerminalBody.querySelectorAll('.bulk-line-thumb video').forEach(video => {
        video.closest('.bulk-line').addEventListener('mouseenter', () => video.play());
        video.closest('.bulk-line').addEventListener('mouseleave', () => video.pause());
      });

      updateBulkStats();
    }

    function getStatusBadge(status) {
      const badges = {
        'uploading': ' UPLOAD',
        'uploaded': ' READY',
        'analyzing': ' ANALYZING',
        'ready': ' READY',
        'generating': ' GENERATING',
        'done': ' DONE',
        'error': ' ERROR'
      };
      return badges[status] || status;
    }

    // Play video in modal
    window.playBulkVideo = function(index) {
      const item = bulkItems[index];
      if (!item?.videoUrl) return;

      const modal = document.createElement('div');
      modal.className = 'bulk-video-modal';
      modal.innerHTML = `
        <button class="bulk-video-modal-close" onclick="this.closest('.bulk-video-modal').remove()"></button>
        <video src="${item.videoUrl}" controls autoplay></video>
        <a class="bulk-video-modal-download" href="${item.videoUrl}" download="${item.filename.replace(/\.[^.]+$/, '')}.mp4">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="18" height="18"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
          Download Video
        </a>
      `;
      document.body.appendChild(modal);
      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });
    };

    // Download video
    window.downloadBulkVideo = function(index) {
      const item = bulkItems[index];
      if (!item?.videoUrl) return;
      
      const a = document.createElement('a');
      a.href = item.videoUrl;
      a.download = item.filename.replace(/\.[^.]+$/, '') + '.mp4';
      a.click();
    };

    // Remove item from bulk list
    window.removeBulkItem = function(index) {
      bulkItems.splice(index, 1);
      renderBulkTerminal();
      
      if (bulkItems.length === 0) {
        exitBulkMode();
      }
    };

    // Add spin animation for loading states
    const spinStyle = document.createElement('style');
    spinStyle.textContent = `
      @keyframes spin { to { transform: rotate(360deg); } }
      .spin { animation: spin 1s linear infinite; }
    `;
    document.head.appendChild(spinStyle);

    // ===== LAZY LOADING FOR VIDEOS =====
    // Intersection Observer to load videos only when visible
    const videoObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const video = entry.target;
          if (video.dataset.src && !video.src) {
            video.src = video.dataset.src;
            video.load();
          }
          videoObserver.unobserve(video);
        }
      });
    }, { rootMargin: '100px' }); // Start loading 100px before visible

    // Watch for new lazy videos (after renders)
    const lazyVideoMutationObserver = new MutationObserver((mutations) => {
      document.querySelectorAll('video.lazy-video:not([src])').forEach(video => {
        videoObserver.observe(video);
        // Add hover-to-play behavior
        video.addEventListener('mouseenter', () => {
          if (video.src) video.play();
        });
        video.addEventListener('mouseleave', () => {
          video.pause();
          video.currentTime = 0;
        });
      });
    });
    lazyVideoMutationObserver.observe(document.body, { childList: true, subtree: true });

    // Initial scan for lazy videos
    document.querySelectorAll('video.lazy-video').forEach(video => {
      videoObserver.observe(video);
      video.addEventListener('mouseenter', () => {
        if (video.src) video.play();
      });
      video.addEventListener('mouseleave', () => {
        video.pause();
        video.currentTime = 0;
      });
    });
  </script>

  <!-- Product Easy Wins Modal -->
  <div id="product-easy-wins-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4 hidden">
    <div class="bg-gray-800 rounded-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto">
      <div class="p-6">
        <div class="flex justify-between items-center mb-6">
          <div>
            <h2 class="text-2xl font-bold text-white">Product Easy Wins</h2>
            <p class="text-sm text-gray-400">Generate 9 lifestyle shots from one product image</p>
          </div>
          <button onclick="closeProductEasyWinsModal()" class="text-gray-400 hover:text-white">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
          </button>
        </div>
        <div id="product-easy-wins-content">
          <!-- Content populated by product-easy-wins.js -->
        </div>
      </div>
    </div>
  </div>

  <script src="product-easy-wins.js"></script>

  <!-- @ Mention Autocomplete Dropdown -->
  <div id="mention-dropdown" class="mention-dropdown">
    <div class="mention-header">Your Brands & Products</div>
    <div id="mention-list"></div>
  </div>

  <!-- Avatar Picker Modal -->
  <div id="avatar-picker-overlay" class="avatar-picker-overlay" onclick="if(event.target===this)closeAvatarPicker()">
    <div class="avatar-picker-modal">
      <div class="avatar-picker-title">Choose Your Avatar</div>
      <div class="avatar-grid" id="avatar-grid"></div>
      <button class="avatar-picker-close" onclick="closeAvatarPicker()">Cancel</button>
    </div>
  </div>

  <!-- Auth check + tenant display + Avatar & Brand Mentions -->
  <script>
    // ===== GLOBAL STATE =====
    let currentUser = null;
    let userProfile = null;
    let userBrands = [];
    let availableAvatars = [];
    let selectedProduct = null;

    // ===== INITIALIZATION =====
    (async function initAuth() {
      try {
        const res = await fetch('/api/auth/me', { credentials: 'include' });
        if (res.ok) {
          const data = await res.json();
          currentUser = data.user;

          // Show tenant name in nav
          document.getElementById('tenant-name').textContent = currentUser.tenant || '';
          document.getElementById('user-name').textContent = currentUser.name || currentUser.email.split('@')[0];
          document.getElementById('user-email').textContent = currentUser.email;

          // Load profile (avatar) and brands in parallel
          await Promise.all([
            loadUserProfile(),
            loadUserBrands()
          ]);

          // Load available avatars
          loadAvailableAvatars();
        }
      } catch (e) {
        // Not logged in or auth disabled  just continue
        console.log('[Auth] Not authenticated or auth disabled');
      }
    })();

    // ===== PROFILE & AVATAR =====
    async function loadUserProfile() {
      try {
        const res = await fetch('/api/profile', { credentials: 'include' });
        if (res.ok) {
          userProfile = await res.json();
          updateAvatarDisplay();
        }
      } catch (e) {
        console.error('[Profile] Failed to load:', e);
      }
    }

    function updateAvatarDisplay() {
      const avatarImg = document.getElementById('user-pic');
      const avatarContainer = document.getElementById('user-avatar');

      if (userProfile?.avatar) {
        const baseUrl = '/r2/avatars'; // Use R2 proxy
        avatarImg.src = `${baseUrl}/${userProfile.avatar}`;
        avatarContainer.style.display = 'block';
      } else if (currentUser?.picture) {
        avatarImg.src = currentUser.picture;
        avatarContainer.style.display = 'block';
      }
    }

    async function loadAvailableAvatars() {
      try {
        const res = await fetch('/api/profile/avatars');
        if (res.ok) {
          const data = await res.json();
          availableAvatars = data.avatars || [];
        }
      } catch (e) {
        console.error('[Avatars] Failed to load:', e);
        // Fallback avatars
        availableAvatars = [
          { id: 'avatar-pim', filename: 'avatar-pim.png', url: '/r2/avatars/avatar-pim.png' },
          { id: 'avatar-charlie', filename: 'avatar-charlie.png', url: '/r2/avatars/avatar-charlie.png' },
          { id: 'avatar-glep', filename: 'avatar-glep.png', url: '/r2/avatars/avatar-glep.png' },
          { id: 'avatar-allan', filename: 'avatar-allan.png', url: '/r2/avatars/avatar-allan.png' },
          { id: 'avatar-boss', filename: 'avatar-boss.png', url: '/r2/avatars/avatar-boss.png' },
          { id: 'avatar-frog', filename: 'avatar-frog.png', url: '/r2/avatars/avatar-frog.png' }
        ];
      }
    }

    function toggleUserMenu() {
      const menu = document.getElementById('user-menu');
      menu.classList.toggle('show');
    }

    function openAvatarPicker() {
      toggleUserMenu(); // Close the user menu
      const overlay = document.getElementById('avatar-picker-overlay');
      const grid = document.getElementById('avatar-grid');

      // Render avatar grid
      grid.innerHTML = availableAvatars.map(avatar => `
        <div class="avatar-option ${userProfile?.avatar === avatar.filename ? 'selected' : ''}"
             onclick="selectAvatar('${avatar.filename}')">
          <img src="${avatar.url}" alt="${avatar.id}">
        </div>
      `).join('');

      overlay.classList.add('show');
    }

    function closeAvatarPicker() {
      document.getElementById('avatar-picker-overlay').classList.remove('show');
    }

    async function selectAvatar(filename) {
      try {
        const res = await fetch('/api/profile/avatar', {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ avatar: filename })
        });

        if (res.ok) {
          userProfile = await res.json().then(r => r.profile);
          updateAvatarDisplay();
          closeAvatarPicker();
        }
      } catch (e) {
        console.error('[Avatar] Failed to update:', e);
        alert('Failed to update avatar');
      }
    }

    function openBrandsPage() {
      toggleUserMenu();
      // For now, alert - in future this could open a modal or navigate
      alert('My Brands - Coming soon! This will show your Brand DNA profiles.');
    }

    async function signOut() {
      await fetch('/api/auth/logout', { method: 'POST', credentials: 'include' });
      localStorage.removeItem('gen-token');
      localStorage.removeItem('gen-user');
      window.location.href = '/login.html';
    }

    // Close user menu when clicking outside
    document.addEventListener('click', (e) => {
      const menu = document.getElementById('user-menu');
      const avatar = document.getElementById('user-avatar');
      if (menu && !menu.contains(e.target) && !avatar?.contains(e.target)) {
        menu.classList.remove('show');
      }
    });

    // ===== BRAND MENTIONS (@product) =====
    async function loadUserBrands() {
      try {
        const res = await fetch('/api/brands', { credentials: 'include' });
        if (res.ok) {
          const data = await res.json();
          userBrands = data.brands || [];
        }
      } catch (e) {
        console.error('[Brands] Failed to load:', e);
      }
    }

    // Setup @ mention autocomplete
    (function setupMentionAutocomplete() {
      const promptInput = document.getElementById('prompt-input');
      const dropdown = document.getElementById('mention-dropdown');
      const mentionList = document.getElementById('mention-list');

      if (!promptInput) return;

      let mentionQuery = '';
      let mentionStart = -1;
      let selectedIndex = 0;

      promptInput.addEventListener('input', (e) => {
        const value = e.target.value;
        const cursorPos = e.target.selectionStart;

        // Check if we're in a mention
        const textBeforeCursor = value.substring(0, cursorPos);
        const lastAtIndex = textBeforeCursor.lastIndexOf('@');

        if (lastAtIndex !== -1) {
          const textAfterAt = textBeforeCursor.substring(lastAtIndex + 1);
          // Only trigger if no space after @ and at least 0 characters (show all on @)
          if (!textAfterAt.includes(' ')) {
            mentionQuery = textAfterAt.toLowerCase();
            mentionStart = lastAtIndex;
            showMentionDropdown(mentionQuery);
            return;
          }
        }

        hideMentionDropdown();
      });

      promptInput.addEventListener('keydown', (e) => {
        if (!dropdown.classList.contains('show')) return;

        const items = mentionList.querySelectorAll('.mention-item');

        switch(e.key) {
          case 'ArrowDown':
            e.preventDefault();
            selectedIndex = (selectedIndex + 1) % items.length;
            updateSelection(items);
            break;
          case 'ArrowUp':
            e.preventDefault();
            selectedIndex = (selectedIndex - 1 + items.length) % items.length;
            updateSelection(items);
            break;
          case 'Enter':
          case 'Tab':
            e.preventDefault();
            if (items[selectedIndex]) {
              items[selectedIndex].click();
            }
            break;
          case 'Escape':
            hideMentionDropdown();
            break;
        }
      });

      function updateSelection(items) {
        items.forEach((item, i) => {
          item.classList.toggle('active', i === selectedIndex);
        });
      }

      function showMentionDropdown(query) {
        // Get products from brands
        const products = [];
        userBrands.forEach(brand => {
          // Add the brand itself as a mention option
          products.push({
            type: 'brand',
            id: brand.slug,
            name: brand.name,
            brand: brand.name,
            color: brand.preview?.primaryColor,
            image: brand.preview?.logo || brand.dna?.logo
          });

          // Add individual products if available
          if (brand.dna?.productImages) {
            brand.dna.productImages.forEach((img, i) => {
              products.push({
                type: 'product',
                id: `${brand.slug}-product-${i}`,
                name: `${brand.name} Product ${i + 1}`,
                brand: brand.name,
                color: brand.preview?.primaryColor,
                image: img,
                brandDna: brand.dna
              });
            });
          }
        });

        // Filter by query
        const filtered = query
          ? products.filter(p => p.name.toLowerCase().includes(query) || p.brand.toLowerCase().includes(query))
          : products;

        if (filtered.length === 0) {
          hideMentionDropdown();
          return;
        }

        // Render dropdown
        mentionList.innerHTML = filtered.map((p, i) => `
          <div class="mention-item ${i === 0 ? 'active' : ''}" data-index="${i}" data-id="${p.id}">
            <img src="${p.image || '/r2/avatars/avatar-charlie.png'}" alt="">
            <div class="mention-info">
              <div class="mention-name">${p.name}</div>
              <div class="mention-brand">${p.brand}</div>
            </div>
            ${p.color ? `<div class="mention-color" style="background:${p.color}"></div>` : ''}
          </div>
        `).join('');

        // Add click handlers
        mentionList.querySelectorAll('.mention-item').forEach(item => {
          item.addEventListener('click', () => {
            const product = filtered[item.dataset.index];
            selectMention(product);
          });
        });

        // Position dropdown below input
        const rect = promptInput.getBoundingClientRect();
        dropdown.style.left = rect.left + 'px';
        dropdown.style.top = (rect.bottom + 8) + 'px';
        dropdown.style.width = rect.width + 'px';
        dropdown.classList.add('show');
        selectedIndex = 0;
      }

      function hideMentionDropdown() {
        dropdown.classList.remove('show');
        mentionQuery = '';
        mentionStart = -1;
      }

      function selectMention(product) {
        const value = promptInput.value;
        const beforeMention = value.substring(0, mentionStart);
        const afterCursor = value.substring(promptInput.selectionStart);

        // Insert the mention text
        promptInput.value = beforeMention + '@' + product.name.replace(/\s+/g, '') + ' ' + afterCursor;

        // Store the selected product for generation
        selectedProduct = product;

        // Add visual chip
        addProductChip(product);

        hideMentionDropdown();
        promptInput.focus();
      }

      function addProductChip(product) {
        const refsContainer = document.getElementById('prompt-references');
        if (!refsContainer) return;

        const chip = document.createElement('div');
        chip.className = 'product-chip';
        chip.innerHTML = `
          <span>${product.name}</span>
          <span class="remove" onclick="removeProductChip(this)"></span>
        `;
        chip.dataset.productId = product.id;

        refsContainer.appendChild(chip);
      }

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!dropdown.contains(e.target) && e.target !== promptInput) {
          hideMentionDropdown();
        }
      });
    })();

    // Global function for removing product chip
    window.removeProductChip = function(el) {
      const chip = el.closest('.product-chip');
      if (chip) {
        chip.remove();
        selectedProduct = null;
      }
    };

    // ===== GENERATION ENHANCEMENT =====
    // Hook into the existing generate function to include product context
    const originalGenerate = window.generateImage || function(){};

    // Enhance generate to include product/brand DNA context
    window.getGenerationContext = function() {
      const context = {
        product: selectedProduct,
        brandDna: selectedProduct?.brandDna
      };

      if (selectedProduct?.brandDna) {
        const dna = selectedProduct.brandDna;
        context.enhancedPrompt = `in the style of ${dna.brand || 'the brand'}, ` +
          `using brand colors ${dna.colors?.primary || ''} and ${dna.colors?.secondary || ''}, ` +
          `${dna.mood?.join(', ') || ''} aesthetic, ` +
          `targeting ${dna.targetDemographic || 'general audience'}`;
      }

      return context;
    };
  </script>

</body>
</html>
