<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üéÆ Player HQ</title>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Nunito', sans-serif; overflow: hidden; height: 100vh; background: #1a3a5a; }

#top-bar {
  height: 44px; display: flex; align-items: center; justify-content: space-between;
  padding: 0 16px; background: linear-gradient(135deg, #2d5016, #3d6b1f);
  border-bottom: 3px solid #4a8a2a; z-index: 200; position: relative;
}
.title { font-weight: 800; font-size: 16px; color: #d4f0a0; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
.metrics { display: flex; gap: 6px; }
.metric {
  font-size: 11px; font-weight: 700; padding: 3px 10px; border-radius: 12px;
  background: rgba(255,255,255,0.15); color: #fff; border: 1px solid rgba(255,255,255,0.2);
}
.metric.gold { background: rgba(255,215,0,0.2); border-color: rgba(255,215,0,0.4); color: #ffd700; }
.metric.danger { background: rgba(255,60,60,0.2); border-color: rgba(255,60,60,0.4); color: #ff6b6b; }

#game-viewport {
  position: absolute; top: 44px; left: 0; right: 0; bottom: 0;
  overflow: hidden; background: #2a6090; cursor: grab;
}
#game-viewport.dragging { cursor: grabbing; }
#game-canvas { display: block; }

#controls {
  position: absolute; bottom: 20px; left: 20px; z-index: 100;
  display: flex; gap: 8px;
}
#controls button {
  width: 40px; height: 40px; border-radius: 12px; border: 2px solid rgba(255,255,255,0.3);
  background: rgba(0,0,0,0.4); color: #fff; font-size: 18px; cursor: pointer;
  backdrop-filter: blur(8px); transition: all 0.15s;
}
#controls button:hover { background: rgba(0,0,0,0.6); border-color: rgba(255,255,255,0.5); }

#minimap {
  position: absolute; bottom: 20px; right: 20px; width: 140px; height: 100px;
  background: rgba(0,0,0,0.4); border: 2px solid rgba(255,255,255,0.3);
  border-radius: 12px; z-index: 100; backdrop-filter: blur(8px);
}

#sidebar {
  position: absolute; top: 44px; right: 0; width: 240px; height: calc(100% - 44px);
  background: rgba(20,40,20,0.95); border-left: 2px solid #4a8a2a;
  overflow-y: auto; font-size: 11px; z-index: 150; color: #c8e8a0;
  backdrop-filter: blur(12px);
}
.sb-section { padding: 8px 10px; border-bottom: 1px solid rgba(74,138,42,0.3); }
.sb-section h3 {
  font-size: 9px; color: #8ab84a; text-transform: uppercase; letter-spacing: 1.5px;
  margin-bottom: 6px;
}
.crop-card {
  display: inline-block; width: 52px; padding: 4px 2px; margin: 2px; border-radius: 6px;
  text-align: center; border: 1px solid rgba(74,138,42,0.4); background: rgba(74,138,42,0.15);
  font-size: 8px; cursor: pointer; transition: all 0.15s;
}
.crop-card:hover { background: rgba(74,138,42,0.3); }
.crop-card.wilting { border-color: rgba(216,200,120,0.5); background: rgba(216,200,120,0.15); }
.crop-card.dying { border-color: rgba(216,88,88,0.5); background: rgba(216,88,88,0.15); }
.task-item {
  padding: 4px 6px; border-radius: 6px; margin-bottom: 3px;
  border-left: 3px solid #4a8a2a; background: rgba(74,138,42,0.1); font-size: 9px;
}
.task-item.active { border-left-color: #d8a848; background: rgba(216,168,72,0.1); }
.backend-row { padding: 3px 0; display: flex; align-items: center; gap: 6px; font-size: 9px; }
.dot { width: 7px; height: 7px; border-radius: 50%; display: inline-block; }
.dot.on { background: #4a4; box-shadow: 0 0 6px #4a4; }
.dot.off { background: #a44; box-shadow: 0 0 6px #a44; }

#tooltip {
  display: none; position: fixed; z-index: 300;
  background: rgba(20,40,20,0.95); border-radius: 10px; padding: 10px 14px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4); border: 2px solid #4a8a2a;
  max-width: 220px; pointer-events: none; font-size: 11px; color: #c8e8a0;
  backdrop-filter: blur(12px);
}
#tooltip h4 { color: #d4f0a0; margin-bottom: 4px; }

#toast {
  position: fixed; top: 56px; left: 50%; transform: translateX(-50%);
  background: linear-gradient(135deg, #ffd700, #ffa500); color: #000; font-weight: 800;
  padding: 8px 20px; border-radius: 12px; z-index: 500; display: none; font-size: 14px;
  box-shadow: 0 4px 20px rgba(255,165,0,0.4);
}
#toast.show { display: block; animation: toastIn 0.3s ease; }
@keyframes toastIn { from { opacity:0; transform: translateX(-50%) translateY(-10px); } to { opacity:1; transform: translateX(-50%) translateY(0); } }
</style>
</head>
<body>

<div id="top-bar">
  <div class="title">üèùÔ∏è Player HQ</div>
  <div class="metrics">
    <span class="metric gold" id="m-mrr">üí∞ $0</span>
    <span class="metric" id="m-clients">üåæ 0 clients</span>
    <span class="metric" id="m-tasks">‚ö° 0 tasks</span>
    <span class="metric" id="m-tier">üèùÔ∏è Dirt Patch</span>
  </div>
</div>

<div id="game-viewport">
  <canvas id="game-canvas"></canvas>
  <div id="controls">
    <button onclick="zoomIn()">+</button>
    <button onclick="zoomOut()">‚àí</button>
    <button onclick="centerView()">‚åÇ</button>
  </div>
  <canvas id="minimap"></canvas>
</div>

<div id="sidebar">
  <div class="sb-section"><h3>‚ö° Active Task</h3><div id="active-task"></div></div>
  <div class="sb-section"><h3>üåæ Client Farm</h3><div id="crop-grid"></div></div>
  <div class="sb-section"><h3>üèóÔ∏è Systems</h3><div id="backends-list"></div></div>
  <div class="sb-section"><h3>üìã Task Queue</h3><div id="task-queue"></div></div>
</div>

<div id="tooltip"><h4 id="tt-title"></h4><div id="tt-body"></div></div>
<div id="toast"></div>

<script>
// ============================================================
// CONFIG
// ============================================================
const TW = 64, TH = 32;
const ASSET_BASE = 'assets/hq/';
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const miniCanvas = document.getElementById('minimap');
const miniCtx = miniCanvas.getContext('2d');

// 24x24 island shape ‚Äî big enough for 30 farm plots + buildings
const MAP = [
  [0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
  [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
  [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
  [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
  [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
  [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
  [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
  [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
  [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
  [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0],
];
const ROWS = MAP.length, COLS = MAP[0].length;

// ============================================================
// BUILDINGS ‚Äî large single sprites
// ============================================================
const BUILDINGS = {
  farmhouse: { r: 5, c: 8,  asset: 'buildings/building-farmhouse.png', label: 'üåæ Farm',     scale: 2.8 },
  treasury:  { r: 8, c: 16, asset: 'buildings/building-treasury.png',  label: 'üí∞ Treasury', scale: 2.5 },
  barracks:  { r: 14, c: 7, asset: 'buildings/building-barracks.png',  label: '‚öîÔ∏è Barracks',  scale: 2.5 },
  dock:      { r: 18, c: 12, asset: 'buildings/building-dock.png',     label: '‚öì Dock',      scale: 2.8 },
};

// ============================================================
// FARM GRID ‚Äî 30 potential client slots (6 rows x 5 cols)
// Positioned near the farmhouse
// ============================================================
const FARM_ORIGIN = { r: 6, c: 10 };
const FARM_ROWS = 6, FARM_COLS = 5;
const FARM_SLOTS = [];
for (let fr = 0; fr < FARM_ROWS; fr++) {
  for (let fc = 0; fc < FARM_COLS; fc++) {
    FARM_SLOTS.push({
      r: FARM_ORIGIN.r + fr,
      c: FARM_ORIGIN.c + fc,
      slotIndex: fr * FARM_COLS + fc,
      client: null,
      health: 0,
      plantAsset: null,
    });
  }
}

// Client-to-plant mapping ‚Äî each client gets a unique custom plant
const CLIENT_PLANTS = {
  // Custom sprites
  'Veda Naturals': 'plants/plant-veda-naturals.png',
  'Veda':          'plants/plant-veda-naturals.png',
  'Get A Drip':    'plants/plant-get-a-drip.png',
  'Clubwell':      'plants/plant-clubwell.png',
  'Gracen':        'plants/plant-gracen.png',
  // Use seedling for others (will add custom sprites later)
  'Bawldy':        'plants/plant-seedling.png',
  'Buchmann':      'plants/plant-seedling.png',
  'Cuppings':      'plants/plant-seedling.png',
  'Dr Franks':     'plants/plant-seedling.png',
  'EcomPro':       'plants/plant-seedling.png',
  'Glow25':        'plants/plant-seedling.png',
  'K&O':           'plants/plant-seedling.png',
  'Levide':        'plants/plant-seedling.png',
  'Lift':          'plants/plant-seedling.png',
  'Lior':          'plants/plant-seedling.png',
  'LOTUS':         'plants/plant-seedling.png',
  'mammaly':       'plants/plant-seedling.png',
  'Olivia':        'plants/plant-seedling.png',
  'Proof Brother': 'plants/plant-seedling.png',
};

// ============================================================
// DECORATIONS ‚Äî individual sprites scattered around
// ============================================================
const DECORATIONS = [
  { r: 4,  c: 6,  asset: 'decorations/deco-signpost.png', scale: 1.2 },
  { r: 10, c: 4,  asset: 'decorations/deco-trees.png',    scale: 2.0 },
  { r: 7,  c: 18, asset: 'decorations/deco-trees.png',    scale: 2.0 },
  { r: 15, c: 16, asset: 'decorations/deco-trees.png',    scale: 1.8 },
  { r: 13, c: 11, asset: 'decorations/deco-fence.png',    scale: 1.5 },
  { r: 16, c: 14, asset: 'decorations/deco-signpost.png', scale: 1.0 },
];

// ============================================================
// SPRITES LOADER
// ============================================================
const sprites = {};
const allAssetPaths = new Set();

// Collect all asset paths
Object.values(BUILDINGS).forEach(b => allAssetPaths.add(b.asset));
DECORATIONS.forEach(d => allAssetPaths.add(d.asset));
Object.values(CLIENT_PLANTS).forEach(p => allAssetPaths.add(p));
[
  'tiles/grass-solid.png', 'tiles/soil-plot.png',
  'plants/plant-dead.png', 'plants/plant-seedling.png',
  'decorations/deco-shiba.png', 'character/player-character.png',
].forEach(p => allAssetPaths.add(p));

let loadedCount = 0;
const totalAssets = allAssetPaths.size;

function loadAllSprites(cb) {
  allAssetPaths.forEach(path => {
    const img = new Image();
    img.onload = () => { sprites[path] = img; if (++loadedCount >= totalAssets) cb(); };
    img.onerror = () => { console.warn('Failed to load:', path); if (++loadedCount >= totalAssets) cb(); };
    img.src = ASSET_BASE + path;
  });
}

// ============================================================
// CAMERA
// ============================================================
let camX = 0, camY = 0, zoom = 1.0;
let isDragging = false, dragStart = {x:0,y:0}, camStart = {x:0,y:0};

function toScreen(r, c) {
  return {
    x: (c - r) * (TW / 2) * zoom + camX,
    y: (c + r) * (TH / 2) * zoom + camY
  };
}

function resize() {
  const vp = document.getElementById('game-viewport');
  canvas.width = vp.clientWidth; canvas.height = vp.clientHeight;
  miniCanvas.width = 140; miniCanvas.height = 100;
  centerView();
}
function centerView() {
  camX = canvas.width / 2;
  camY = canvas.height / 4;
}
function zoomIn() { zoom = Math.min(2.5, zoom * 1.2); }
function zoomOut() { zoom = Math.max(0.4, zoom / 1.2); }

// Mouse/touch controls
const vp = document.getElementById('game-viewport');
vp.addEventListener('mousedown', e => {
  isDragging = true; dragStart = {x:e.clientX, y:e.clientY}; camStart = {x:camX, y:camY};
  vp.classList.add('dragging');
});
vp.addEventListener('mousemove', e => {
  if (isDragging) { camX = camStart.x + (e.clientX - dragStart.x); camY = camStart.y + (e.clientY - dragStart.y); }
  checkHover(e);
});
vp.addEventListener('mouseup', () => { isDragging = false; vp.classList.remove('dragging'); });
vp.addEventListener('mouseleave', () => { isDragging = false; vp.classList.remove('dragging'); });
vp.addEventListener('wheel', e => {
  e.preventDefault();
  zoom = Math.max(0.4, Math.min(2.5, zoom * (e.deltaY > 0 ? 0.9 : 1.1)));
}, { passive: false });
vp.addEventListener('click', e => { if (!isDragging && hoverBuilding) onBuildingClick(hoverBuilding); });

// ============================================================
// GAME STATE
// ============================================================
let time = 0;
let robotPos = { r: 11, c: 12 };
let hoverBuilding = null;
const GS = {
  mrr: 0, crops: [], tasks: [], backends: { gen: true, mixer: true, hooks: true },
  warzone: { burnLevel: 0 }, treasury: {},
};

// ============================================================
// HOVER
// ============================================================
function checkHover(e) {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  hoverBuilding = null;
  Object.entries(BUILDINGS).forEach(([k, b]) => {
    const {x, y} = toScreen(b.r, b.c);
    const w = TW * zoom * b.scale, h = w * 1.3;
    if (mx > x - w/2 && mx < x + w/2 && my > y - h && my < y + TH*zoom) hoverBuilding = k;
  });
  canvas.style.cursor = hoverBuilding && !isDragging ? 'pointer' : (isDragging ? 'grabbing' : 'grab');
  updateTooltip(e.clientX, e.clientY);
}

function updateTooltip(mx, my) {
  const tt = document.getElementById('tooltip');
  if (hoverBuilding) {
    const b = BUILDINGS[hoverBuilding];
    document.getElementById('tt-title').textContent = b.label;
    let body = '';
    if (hoverBuilding === 'farmhouse') body = GS.crops.map(c => `<div>${c.health > 60 ? 'üåø' : c.health > 30 ? 'ü•Ä' : 'üíÄ'} ${c.name}: ${c.health}%</div>`).join('');
    else if (hoverBuilding === 'treasury') body = `<div>MRR: $${Math.round(GS.mrr)}</div>`;
    else if (hoverBuilding === 'barracks') body = `<div>üî• Burn Level: ${GS.warzone.burnLevel}%</div>`;
    else if (hoverBuilding === 'dock') body = `<div>üì¶ Deliverables shipping</div>`;
    document.getElementById('tt-body').innerHTML = body;
    tt.style.display = 'block';
    tt.style.left = (mx + 15) + 'px'; tt.style.top = (my + 15) + 'px';
  } else tt.style.display = 'none';
}

// ============================================================
// RENDER
// ============================================================
function render() {
  time = Date.now();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Ocean background with gradient
  const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grad.addColorStop(0, '#1a5080');
  grad.addColorStop(0.4, '#2a6090');
  grad.addColorStop(1, '#1a3a5a');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Water shimmer
  ctx.fillStyle = 'rgba(100,180,255,0.06)';
  for (let i = 0; i < 12; i++) {
    const rx = ((time / 25 + i * 180) % (canvas.width + 400)) - 200;
    const ry = canvas.height * 0.5 + Math.sin(i * 0.7 + time / 600) * 40;
    ctx.beginPath();
    ctx.ellipse(rx, ry, 80, 2, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Collect all drawables sorted by depth
  const drawList = [];

  // Ground tiles
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (MAP[r][c]) drawList.push({ type: 'tile', r, c, depth: r + c });
    }
  }

  // Farm plot tiles (empty dirt for unfilled slots)
  FARM_SLOTS.forEach(slot => {
    drawList.push({ type: 'farmplot', ...slot, depth: slot.r + slot.c + 0.05 });
  });

  // Buildings
  Object.entries(BUILDINGS).forEach(([k, b]) => {
    drawList.push({ type: 'building', key: k, ...b, depth: b.r + b.c + 0.1 });
  });

  // Client plants
  FARM_SLOTS.filter(s => s.client).forEach(slot => {
    drawList.push({ type: 'plant', ...slot, depth: slot.r + slot.c + 0.15 });
  });

  // Decorations
  DECORATIONS.forEach((d, i) => {
    drawList.push({ type: 'deco', ...d, idx: i, depth: d.r + d.c + 0.12 });
  });

  // Player character
  drawList.push({ type: 'player', r: robotPos.r, c: robotPos.c, depth: robotPos.r + robotPos.c + 0.3 });

  // Shiba companion
  drawList.push({ type: 'shiba', r: robotPos.r, c: robotPos.c + 0.5, depth: robotPos.r + robotPos.c + 0.35 });

  // Sort by depth
  drawList.sort((a, b) => a.depth - b.depth);

  // Draw
  drawList.forEach(item => {
    switch (item.type) {
      case 'tile': drawTile(item.r, item.c); break;
      case 'farmplot': drawFarmPlot(item); break;
      case 'building': drawBuilding(item.key, item); break;
      case 'plant': drawClientPlant(item); break;
      case 'deco': drawDecoration(item); break;
      case 'player': drawPlayer(); break;
      case 'shiba': drawShiba(); break;
    }
  });

  // Fire overlay
  if (GS.warzone.burnLevel > 25) drawFire();

  drawMinimap();
  requestAnimationFrame(render);
}

// ============================================================
// DRAW FUNCTIONS
// ============================================================

function drawTile(r, c) {
  const {x, y} = toScreen(r, c);
  const tw = TW * zoom, th = TH * zoom;

  // Check if this is an edge tile
  const hasN = MAP[r-1]?.[c], hasS = MAP[r+1]?.[c];
  const hasE = MAP[r]?.[c+1], hasW = MAP[r]?.[c-1];
  const isEdge = !hasN || !hasS || !hasE || !hasW;

  // Always draw solid colored diamond first (no transparency issues)
  const colors = ['#5a9a4a', '#4e8e42', '#52924a', '#4a8a3a'];
  ctx.fillStyle = colors[(r + c) % 4];
  ctx.beginPath();
  ctx.moveTo(x, y); ctx.lineTo(x + tw/2, y + th/2);
  ctx.lineTo(x, y + th); ctx.lineTo(x - tw/2, y + th/2);
  ctx.closePath(); ctx.fill();

  // Add subtle texture variation
  if ((r + c) % 3 === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fill();
  }

  // Edge highlight for coastline
  if (isEdge) {
    ctx.strokeStyle = 'rgba(100,180,255,0.4)';
    ctx.lineWidth = 2 * zoom;
    ctx.stroke();
    // Beach sand edge
    ctx.fillStyle = 'rgba(210,180,140,0.3)';
    ctx.fill();
  }
}

function drawFarmPlot(slot) {
  const {x, y} = toScreen(slot.r, slot.c);
  const tw = TW * zoom * 0.85, th = TH * zoom * 0.85;

  // Draw soil diamond for empty plots
  if (!slot.client) {
    // Tilled soil - brown dirt
    ctx.fillStyle = '#6b4423';
    ctx.beginPath();
    ctx.moveTo(x, y); ctx.lineTo(x + tw/2, y + th/2);
    ctx.lineTo(x, y + th); ctx.lineTo(x - tw/2, y + th/2);
    ctx.closePath(); ctx.fill();

    // Furrow lines
    ctx.strokeStyle = 'rgba(90,60,30,0.5)';
    ctx.lineWidth = 1 * zoom;
    for (let i = -2; i <= 2; i++) {
      ctx.beginPath();
      ctx.moveTo(x - tw/3 + i*4*zoom, y + th/3);
      ctx.lineTo(x + tw/3 + i*4*zoom, y + th*2/3);
      ctx.stroke();
    }
  } else {
    // Has client - draw soil under plant
    ctx.fillStyle = '#5a3a1a';
    ctx.beginPath();
    ctx.moveTo(x, y + th*0.3); ctx.lineTo(x + tw/2, y + th*0.65);
    ctx.lineTo(x, y + th); ctx.lineTo(x - tw/2, y + th*0.65);
    ctx.closePath(); ctx.fill();
  }
}

function drawBuilding(key, bld) {
  const spr = sprites[bld.asset];
  const {x, y} = toScreen(bld.r, bld.c);
  const w = TW * zoom * bld.scale;

  // Soft shadow on ground
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(x, y + TH * zoom * 0.6, w * 0.4, TH * zoom * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();

  if (spr) {
    const h = (spr.height / spr.width) * w;
    const bob = Math.sin(time / 2000 + bld.r) * 2 * zoom;

    // Shake for burning barracks
    let shake = 0;
    if (key === 'barracks' && GS.warzone.burnLevel > 50) {
      shake = Math.sin(time / 40) * 3 * zoom;
    }

    // Draw sprite (PNG transparency should work)
    ctx.drawImage(spr, x - w/2 + shake, y - h + TH * zoom * 0.7 - bob, w, h);
  } else {
    // Fallback emoji if sprite missing
    ctx.font = `${40 * zoom}px serif`;
    ctx.textAlign = 'center';
    const emoji = key === 'farmhouse' ? 'üè†' : key === 'treasury' ? 'üèõÔ∏è' : key === 'barracks' ? '‚öîÔ∏è' : '‚öì';
    ctx.fillText(emoji, x, y);
  }

  // Label below building
  ctx.font = `bold ${Math.max(10, 11 * zoom)}px Nunito`;
  ctx.textAlign = 'center';
  ctx.fillStyle = '#fff';
  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
  ctx.lineWidth = 3 * zoom;
  ctx.strokeText(bld.label, x, y + TH * zoom * 1.2);
  ctx.fillText(bld.label, x, y + TH * zoom * 1.2);

  // Hover ring
  if (hoverBuilding === key) {
    ctx.strokeStyle = 'rgba(255,215,0,0.6)';
    ctx.lineWidth = 2 * zoom;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.ellipse(x, y + TH * zoom * 0.3, w * 0.45, TH * zoom * 0.4, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
  }
}

function drawClientPlant(slot) {
  if (!slot.plantAsset) return;
  const spr = sprites[slot.plantAsset];
  if (!spr) return;
  const {x, y} = toScreen(slot.r, slot.c);

  // Sway animation unique per plant
  const sway = Math.sin(time / 500 + slot.slotIndex * 1.3) * 3 * zoom;
  const w = TW * zoom * 0.85;
  const h = (spr.height / spr.width) * w;

  // Dim dying plants
  ctx.save();
  if (slot.health < 40) ctx.globalAlpha = 0.3 + slot.health / 100;
  else if (slot.health < 60) ctx.globalAlpha = 0.7;

  ctx.drawImage(spr, x - w/2 + sway, y - h + TH * zoom * 0.5, w, h);

  // Health indicator
  if (slot.health > 0 && slot.health < 100) {
    const barW = 24 * zoom, barH = 3 * zoom;
    const barX = x - barW/2, barY = y - h + TH * zoom * 0.3;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(barX, barY, barW, barH);
    ctx.fillStyle = slot.health > 60 ? '#4a4' : slot.health > 30 ? '#da4' : '#a44';
    ctx.fillRect(barX, barY, barW * (slot.health / 100), barH);
  }

  // Client name
  ctx.font = `bold ${Math.max(7, 8 * zoom)}px Nunito`;
  ctx.textAlign = 'center';
  ctx.fillStyle = '#fff';
  ctx.strokeStyle = 'rgba(0,0,0,0.5)';
  ctx.lineWidth = 2 * zoom;
  ctx.strokeText(slot.client, x, y + TH * zoom * 0.3);
  ctx.fillText(slot.client, x, y + TH * zoom * 0.3);

  ctx.restore();
}

function drawDecoration(deco) {
  const spr = sprites[deco.asset];
  if (!spr) return;
  const {x, y} = toScreen(deco.r, deco.c);
  const w = TW * zoom * deco.scale;
  const h = (spr.height / spr.width) * w;
  ctx.drawImage(spr, x - w/2, y - h + TH * zoom * 0.5, w, h);
}

function drawPlayer() {
  const spr = sprites['character/player-character.png'];
  const {x, y} = toScreen(robotPos.r, robotPos.c);
  const bob = Math.sin(time / 300) * 3 * zoom;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(x, y + TH * zoom * 0.3, 12 * zoom, 5 * zoom, 0, 0, Math.PI * 2);
  ctx.fill();

  if (spr) {
    const w = 40 * zoom;
    const h = (spr.height / spr.width) * w;
    ctx.drawImage(spr, x - w/2, y - h + TH * zoom * 0.3 + bob, w, h);
  } else {
    // Fallback character
    ctx.font = `${24 * zoom}px serif`;
    ctx.textAlign = 'center';
    ctx.fillText('üßë‚Äçüíª', x, y + bob);
  }
}

function drawShiba() {
  const spr = sprites['decorations/deco-shiba.png'];
  const {x, y} = toScreen(robotPos.r + 0.3, robotPos.c + 0.6);
  const bob = Math.sin(time / 250 + 1) * 2 * zoom;

  if (spr) {
    const w = 28 * zoom;
    const h = (spr.height / spr.width) * w;
    // Wag rotation
    ctx.save();
    ctx.translate(x, y + bob);
    ctx.rotate(Math.sin(time / 150) * 0.05);
    ctx.drawImage(spr, -w/2, -h + TH * zoom * 0.2, w, h);
    ctx.restore();
  }
}

function drawFire() {
  const bld = BUILDINGS.barracks;
  const {x, y} = toScreen(bld.r, bld.c);
  const count = Math.ceil(GS.warzone.burnLevel / 10);
  for (let i = 0; i < count; i++) {
    const phase = (time / 200 + i * 1.2) % 3;
    if (phase > 2) continue;
    const fx = x + Math.sin(i * 2.5 + time / 300) * 40 * zoom;
    const fy = y - 50 * zoom - phase * 40 * zoom;
    ctx.globalAlpha = Math.max(0, 1 - phase / 2);
    ctx.font = `${(16 + i * 3) * zoom}px serif`;
    ctx.textAlign = 'center';
    ctx.fillText('üî•', fx, fy);
  }
  ctx.globalAlpha = 1;
}

function drawMinimap() {
  miniCtx.fillStyle = '#1a3a5a';
  miniCtx.fillRect(0, 0, 140, 100);
  const scale = 4;
  const ox = 70 - COLS * scale / 2, oy = 50 - ROWS * scale / 2;

  // Island
  miniCtx.fillStyle = '#4a8a3a';
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (MAP[r][c]) miniCtx.fillRect(ox + c * scale, oy + r * scale, scale - 1, scale - 1);

  // Farm area
  miniCtx.fillStyle = 'rgba(139,90,43,0.5)';
  FARM_SLOTS.forEach(s => miniCtx.fillRect(ox + s.c * scale, oy + s.r * scale, scale - 1, scale - 1));

  // Buildings
  miniCtx.fillStyle = '#d4a84a';
  Object.values(BUILDINGS).forEach(b => miniCtx.fillRect(ox + b.c * scale - 1, oy + b.r * scale - 1, scale + 2, scale + 2));

  // Player
  miniCtx.fillStyle = '#4af';
  miniCtx.beginPath();
  miniCtx.arc(ox + robotPos.c * scale, oy + robotPos.r * scale, 3, 0, Math.PI * 2);
  miniCtx.fill();

  // Plants
  miniCtx.fillStyle = '#4a4';
  FARM_SLOTS.filter(s => s.client).forEach(s => {
    miniCtx.beginPath();
    miniCtx.arc(ox + s.c * scale + scale/2, oy + s.r * scale + scale/2, 2, 0, Math.PI * 2);
    miniCtx.fill();
  });
}

// ============================================================
// BUILDING INTERACTIONS
// ============================================================
function onBuildingClick(key) {
  const bld = BUILDINGS[key];
  animateTo(bld.r + 1, bld.c);
  showToast(bld.label + ' selected');
}

function animateTo(r, c) {
  const sr = robotPos.r, sc = robotPos.c, start = Date.now();
  function step() {
    const t = Math.min(1, (Date.now() - start) / 800);
    const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
    robotPos.r = sr + (r - sr) * ease;
    robotPos.c = sc + (c - sc) * ease;
    if (t < 1) requestAnimationFrame(step);
  }
  step();
}

function showToast(t) {
  const el = document.getElementById('toast');
  el.textContent = t; el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 2000);
}

// ============================================================
// DATA FETCHING
// ============================================================
async function fetchData() {
  try {
    const [state, metrics, ads, backends] = await Promise.all([
      fetch('/api/hq/state').then(r => r.json()).catch(() => ({})),
      fetch('/api/hq/metrics').then(r => r.json()).catch(() => ({})),
      fetch('/api/hq/ads').then(r => r.json()).catch(() => ({})),
      fetch('/api/hq/backends').then(r => r.json()).catch(() => ({})),
    ]);
    
    // Update backend status
    if (backends) {
      GS.backends = {
        gen: backends.gen?.status || false,
        mixer: backends.mixer?.status || false,
        hooks: backends.hooks?.status || false,
      };
    }

    GS.mrr = metrics.mrr || 0;
    GS.treasury = metrics;
    GS.warzone.burnLevel = ads.burnLevel || 0;
    GS.tasks = state.taskQueue || [];
    GS.crops = (state.rooms?.greenhouse?.plants || []).map(p => ({
      name: p.client, health: p.health, stage: p.stage
    }));

    // Map crops to farm slots
    GS.crops.forEach((crop, i) => {
      if (i < FARM_SLOTS.length) {
        FARM_SLOTS[i].client = crop.name;
        FARM_SLOTS[i].health = crop.health;
        FARM_SLOTS[i].plantAsset = CLIENT_PLANTS[crop.name] || 'plants/plant-seedling.png';
        if (crop.health < 20) FARM_SLOTS[i].plantAsset = 'plants/plant-dead.png';
      }
    });

    // Island tier
    const clientCount = GS.crops.length;
    let tier = 'üèùÔ∏è Dirt Patch';
    if (clientCount >= 10) tier = 'üè∞ Kingdom';
    else if (clientCount >= 6) tier = 'üèòÔ∏è Village';
    else if (clientCount >= 3) tier = 'üè† Homestead';
    else if (clientCount >= 1) tier = 'üõñ Hut';

    updateSidebar(tier, clientCount);
  } catch (e) { console.error('Data fetch failed:', e); }
}

function updateSidebar(tier, clientCount) {
  document.getElementById('m-mrr').textContent = 'üí∞ $' + Math.round(GS.mrr);
  document.getElementById('m-clients').textContent = 'üåæ ' + (clientCount || GS.crops.length) + ' clients';
  document.getElementById('m-tasks').textContent = '‚ö° ' + GS.tasks.filter(t => t.status === 'queued').length;
  document.getElementById('m-tier').textContent = tier || 'üèùÔ∏è Dirt Patch';

  const active = GS.tasks.find(t => t.status === 'active');
  document.getElementById('active-task').innerHTML = active
    ? `<div class="task-item active"><b>${active.prompt}</b><div style="font-size:8px;color:#8ab84a">üìç ${active.room}</div></div>`
    : '<div style="color:#6a8a4a;font-size:9px">üí§ Idle ‚Äî all quiet</div>';

  document.getElementById('crop-grid').innerHTML = GS.crops.map(c => {
    const cls = c.health > 60 ? '' : c.health > 30 ? 'wilting' : 'dying';
    const icon = c.health > 60 ? 'üåø' : c.health > 30 ? 'ü•Ä' : 'üíÄ';
    return `<div class="crop-card ${cls}">${icon}<br>${c.name.split(' ')[0]}<br>${c.health}%</div>`;
  }).join('') || '<div style="color:#6a8a4a;font-size:9px">No clients yet</div>';

  document.getElementById('task-queue').innerHTML = GS.tasks.filter(t => t.status === 'queued')
    .map(t => `<div class="task-item">${t.prompt}</div>`).join('') || '<div style="color:#6a8a4a;font-size:9px">Queue empty</div>';

  document.getElementById('backends-list').innerHTML = ['gen', 'mixer', 'hooks'].map(k =>
    `<div class="backend-row"><span class="dot ${GS.backends[k] ? 'on' : 'off'}"></span>${k}.aditor.ai</div>`
  ).join('');
}

// ============================================================
// INIT
// ============================================================
window.addEventListener('resize', resize);
resize();

// Loading screen
ctx.fillStyle = '#1a3a5a';
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.font = '16px Nunito';
ctx.fillStyle = '#c8e8a0';
ctx.textAlign = 'center';
ctx.fillText('üèùÔ∏è Loading Player HQ...', canvas.width / 2, canvas.height / 2);

loadAllSprites(() => {
  console.log(`Loaded ${Object.keys(sprites).length}/${totalAssets} sprites`);
  render();
  // Sync from Trello on load, then fetch data
  fetch('/api/hq/sync', { method: 'POST' })
    .then(() => console.log('Synced from Trello'))
    .catch(() => console.log('Sync skipped'))
    .finally(() => {
      fetchData();
      setInterval(fetchData, 30000);
    });
});
</script>
</body>
</html>
