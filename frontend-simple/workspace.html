<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aditor Studio</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #08080c;
      --bg-secondary: #0f0f14;
      --bg-tertiary: #16161d;
      --bg-hover: #1c1c26;
      --border: #232330;
      --text-primary: #ffffff;
      --text-secondary: #8b8b9e;
      --text-tertiary: #5c5c6f;
      --accent: #f97316;
      --accent-hover: #ea580c;
      --accent-glow: rgba(249, 115, 22, 0.15);
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* ===== TOP NAV ===== */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      padding: 16px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(8, 8, 12, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border);
    }

    .nav-logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      font-size: 18px;
    }

    .nav-logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--accent) 0%, #c2410c 100%);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 16px;
    }

    .nav-logo-img {
      height: 28px;
      width: auto;
    }

    .nav-tabs {
      display: flex;
      gap: 4px;
      background: var(--bg-tertiary);
      padding: 4px;
      border-radius: 12px;
    }

    .nav-tab {
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .nav-tab:hover {
      color: var(--text-primary);
      background: var(--bg-hover);
    }

    .nav-tab.active {
      color: var(--text-primary);
      background: var(--bg-primary);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .nav-profile {
      width: 36px;
      height: 36px;
      background: var(--bg-tertiary);
      border-radius: 50%;
      border: 2px solid var(--border);
      cursor: pointer;
      transition: border-color 0.2s ease;
    }

    .nav-profile:hover {
      border-color: var(--accent);
    }

    /* ===== MAIN CONTENT ===== */
    .main {
      padding-top: 80px;
      padding-bottom: 140px;
      min-height: 100vh;
    }

    /* ===== IMAGE GRID ===== */
    .grid-container {
      padding: 24px;
    }

    .grid-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    .grid-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .grid-count {
      font-size: 13px;
      color: var(--text-tertiary);
    }

    .masonry-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 12px;
    }

    @media (max-width: 1600px) {
      .masonry-grid { grid-template-columns: repeat(5, 1fr); }
    }
    @media (max-width: 1400px) {
      .masonry-grid { grid-template-columns: repeat(4, 1fr); }
    }
    @media (max-width: 1100px) {
      .masonry-grid { grid-template-columns: repeat(3, 1fr); }
    }
    @media (max-width: 800px) {
      .masonry-grid { grid-template-columns: repeat(2, 1fr); }
    }

    .grid-item {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      cursor: pointer;
      background: var(--bg-secondary);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      aspect-ratio: 9 / 16;
    }

    .grid-item:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
    }

    .grid-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      -webkit-user-drag: none;
      user-select: none;
    }

    .grid-item-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 50%);
      opacity: 0;
      transition: opacity 0.2s ease;
      display: flex;
      align-items: flex-end;
      padding: 12px;
    }

    .grid-item:hover .grid-item-overlay {
      opacity: 1;
    }

    .grid-item-actions {
      display: flex;
      gap: 8px;
      width: 100%;
    }

    .grid-item-btn {
      flex: 1;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .grid-item-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .grid-item-btn.primary {
      background: var(--accent);
    }

    .grid-item-btn.primary:hover {
      background: var(--accent-hover);
    }

    /* Drag indicator */
    .grid-item.dragging {
      opacity: 0.5;
    }

    .grid-item-drag-hint {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border-radius: 6px;
      font-size: 11px;
      color: var(--text-secondary);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .grid-item:hover .grid-item-drag-hint {
      opacity: 1;
    }

    /* Save to video button */
    .grid-item-save {
      position: absolute;
      bottom: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border: none;
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.2s ease;
    }

    .grid-item:hover .grid-item-save {
      opacity: 1;
    }

    .grid-item-save:hover {
      background: var(--accent);
      color: white;
      transform: scale(1.1);
    }

    .grid-item-save.saved {
      opacity: 1;
      background: var(--accent);
      color: white;
    }

    /* Delete button */
    .grid-item-delete {
      position: absolute;
      bottom: 8px;
      left: 8px;
      width: 32px;
      height: 32px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border: none;
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.2s ease;
    }

    .grid-item:hover .grid-item-delete {
      opacity: 1;
    }

    .grid-item-delete:hover {
      background: #dc2626;
      color: white;
      transform: scale(1.1);
    }

    .grid-item-delete svg {
      width: 16px;
      height: 16px;
    }

    /* Loading placeholder */
    .grid-item-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-tertiary);
      border: 2px dashed var(--border);
    }

    .grid-item-loading-inner {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 16px;
    }

    .grid-item-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .grid-item-loading-text {
      font-size: 12px;
      color: var(--text-secondary);
      text-align: center;
      max-width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .grid-item-save svg {
      width: 16px;
      height: 16px;
    }

    /* ===== PROMPT BAR ===== */
    .prompt-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 16px 24px 24px;
      background: linear-gradient(to top, var(--bg-primary) 70%, transparent);
      pointer-events: none;
    }

    .prompt-bar {
      max-width: 800px;
      margin: 0 auto;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 12px;
      pointer-events: auto;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .prompt-bar:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px var(--accent-glow);
    }

    .prompt-bar.drag-over {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px var(--accent-glow);
      background: var(--bg-tertiary);
    }

    .prompt-references {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      min-height: 0;
    }

    .prompt-references:empty {
      display: none;
    }

    .prompt-ref {
      position: relative;
      width: 48px;
      height: 48px;
      border-radius: 8px;
      overflow: hidden;
      background: var(--bg-tertiary);
    }

    .prompt-ref img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .prompt-ref-remove {
      position: absolute;
      top: -4px;
      right: -4px;
      width: 18px;
      height: 18px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 50%;
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
    }

    .prompt-ref-remove:hover {
      background: #dc2626;
      color: white;
      border-color: #dc2626;
    }

    .prompt-input-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .prompt-input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      font-size: 15px;
      color: var(--text-primary);
      padding: 8px 12px;
    }

    .prompt-input::placeholder {
      color: var(--text-tertiary);
    }

    .prompt-btn {
      width: 44px;
      height: 44px;
      background: var(--accent);
      border: none;
      border-radius: 12px;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease, transform 0.1s ease;
    }

    .prompt-btn:hover {
      background: var(--accent-hover);
    }

    .prompt-btn:active {
      transform: scale(0.95);
    }

    .prompt-btn svg {
      width: 20px;
      height: 20px;
    }

    .prompt-options {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
      align-items: center;
    }

    .prompt-option {
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s ease;
    }

    .prompt-option:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .prompt-option.active {
      background: var(--accent-glow);
      border-color: var(--accent);
      color: var(--accent);
    }

    .prompt-option svg {
      width: 14px;
      height: 14px;
    }

    .prompt-select {
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%238b8b9e' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      padding-right: 28px;
      transition: all 0.2s ease;
    }

    .prompt-select:hover {
      background-color: var(--bg-hover);
      color: var(--text-primary);
    }

    .prompt-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .prompt-spacer {
      flex: 1;
    }

    /* ===== FULLSCREEN MODAL ===== */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(20px);
      z-index: 200;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 40px;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-content {
      max-width: 90vw;
      max-height: 90vh;
      position: relative;
    }

    .modal-image {
      max-width: 100%;
      max-height: 80vh;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 20px;
    }

    .modal-btn {
      padding: 12px 24px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s ease;
    }

    .modal-btn:hover {
      background: var(--bg-hover);
    }

    .modal-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
    }

    .modal-btn.primary:hover {
      background: var(--accent-hover);
    }

    .modal-close {
      position: fixed;
      top: 80px;
      right: 40px;
      width: 44px;
      height: 44px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 50%;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.2s ease;
      z-index: 1001;
    }

    .modal-close:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .modal-meta {
      margin-top: 16px;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border-radius: 12px;
      font-size: 13px;
      color: var(--text-secondary);
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .modal-meta:empty {
      display: none;
    }

    .modal-meta-prompt {
      margin-bottom: 8px;
      color: var(--text-primary);
      line-height: 1.5;
    }

    .modal-meta-settings {
      display: flex;
      gap: 16px;
      font-size: 12px;
    }

    .modal-meta-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .modal-meta-label {
      color: var(--text-tertiary);
    }

    .modal-meta-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .modal-meta-btn {
      padding: 6px 12px;
      background: var(--bg-hover);
      border: none;
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .modal-meta-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    /* ===== EMPTY STATE ===== */
    .empty-state {
      text-align: center;
      padding: 80px 20px;
    }

    .empty-icon {
      width: 80px;
      height: 80px;
      background: var(--bg-secondary);
      border-radius: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 24px;
    }

    .empty-icon svg {
      width: 40px;
      height: 40px;
      color: var(--text-tertiary);
    }

    .empty-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .empty-desc {
      color: var(--text-secondary);
      font-size: 14px;
      max-width: 400px;
      margin: 0 auto;
    }

    /* ===== LOADING ===== */
    .generating {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px 32px;
      display: none;
      align-items: center;
      gap: 16px;
      z-index: 150;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .generating.active {
      display: flex;
    }

    .generating-spinner {
      width: 24px;
      height: 24px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .generating-text {
      font-size: 14px;
      font-weight: 500;
    }

    /* ===== DRAG GHOST ===== */
    .drag-ghost {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      width: 80px;
      height: 120px;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      opacity: 0.9;
    }

    .drag-ghost img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* ===== WORKFLOW STUDIO (Shortcuts Tab) ===== */
    .workflow-studio {
      display: grid;
      grid-template-columns: 220px 1fr 320px;
      height: calc(100vh - 65px);
      gap: 0;
    }

    /* Left sidebar - workflow list */
    .workflow-sidebar {
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      padding: 16px 0;
      overflow-y: auto;
    }

    .workflow-sidebar-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-tertiary);
      padding: 0 16px;
      margin-bottom: 12px;
    }

    .workflow-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      cursor: pointer;
      transition: all 0.15s ease;
      border-left: 3px solid transparent;
    }

    .workflow-item:hover {
      background: var(--bg-hover);
    }

    .workflow-item.active {
      background: var(--accent-glow);
      border-left-color: var(--accent);
    }

    .workflow-item-icon {
      width: 36px;
      height: 36px;
      background: var(--bg-tertiary);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .workflow-item.active .workflow-item-icon {
      background: var(--accent);
    }

    .workflow-item-icon svg {
      width: 18px;
      height: 18px;
      color: var(--text-secondary);
    }

    .workflow-item.active .workflow-item-icon svg {
      color: white;
    }

    .workflow-item-text {
      flex: 1;
      min-width: 0;
    }

    .workflow-item-name {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .workflow-item.coming-soon {
      opacity: 0.45;
      cursor: default;
      pointer-events: none;
    }

    .workflow-item.coming-soon:hover {
      background: transparent;
    }

    .workflow-item.coming-soon .workflow-item-name {
      color: var(--text-secondary);
    }

    .workflow-divider {
      padding: 16px 16px 8px;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-tertiary);
      text-transform: uppercase;
      letter-spacing: 0.8px;
      border-top: 1px solid var(--border);
      margin-top: 8px;
    }

    .workflow-item-desc {
      font-size: 11px;
      color: var(--text-tertiary);
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Center - workflow input area */
    .workflow-main {
      padding: 32px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .workflow-header {
      margin-bottom: 24px;
    }

    .workflow-header h2 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .workflow-header p {
      font-size: 14px;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    /* ===== UGC VIDEO WORKFLOW LAYOUT ===== */
    .ugc-video-layout {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 24px;
      height: 100%;
    }

    .ugc-avatar-section {
      display: flex;
      flex-direction: column;
    }

    .ugc-avatar-upload {
      flex: 1;
      border: 2px dashed var(--border);
      border-radius: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 300px;
      position: relative;
      overflow: hidden;
    }

    .ugc-avatar-upload:hover,
    .ugc-avatar-upload.has-image:hover {
      border-color: var(--accent);
      background: var(--accent-glow);
    }

    .ugc-avatar-upload.has-image {
      border-style: solid;
      padding: 0;
    }

    .ugc-avatar-upload .avatar-preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
    }

    .ugc-avatar-upload .avatar-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      color: var(--text-secondary);
    }

    .ugc-avatar-upload.has-image .avatar-placeholder {
      display: none;
    }

    .ugc-avatar-upload .avatar-placeholder svg {
      width: 48px;
      height: 48px;
    }

    .ugc-script-section {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .ugc-script-textarea {
      flex: 1;
      min-height: 240px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 14px;
      line-height: 1.6;
      resize: none;
    }

    .ugc-script-textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .ugc-script-textarea::placeholder {
      color: var(--text-tertiary);
    }

    .ugc-voice-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .ugc-voice-row label {
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .ugc-voice-select {
      flex: 1;
      max-width: 300px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
    }

    .ugc-voice-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .ugc-generate-btn {
      padding: 12px 32px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .ugc-generate-btn:hover {
      background: var(--accent-hover);
    }

    .ugc-generate-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .workflow-upload-zone {
      border: 2px dashed var(--border);
      border-radius: 16px;
      padding: 48px 32px;
      text-align: center;
      transition: all 0.2s ease;
      cursor: pointer;
      margin-bottom: 24px;
    }

    .workflow-upload-zone:hover,
    .workflow-upload-zone.dragover {
      border-color: var(--accent);
      background: var(--accent-glow);
    }

    .workflow-upload-icon {
      width: 64px;
      height: 64px;
      background: var(--bg-tertiary);
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px;
    }

    .workflow-upload-icon svg {
      width: 32px;
      height: 32px;
      color: var(--text-secondary);
    }

    .workflow-upload-zone:hover .workflow-upload-icon,
    .workflow-upload-zone.dragover .workflow-upload-icon {
      background: var(--accent);
    }

    .workflow-upload-zone:hover .workflow-upload-icon svg,
    .workflow-upload-zone.dragover .workflow-upload-icon svg {
      color: white;
    }

    .workflow-upload-text {
      font-size: 15px;
      color: var(--text-primary);
      margin-bottom: 8px;
    }

    .workflow-upload-hint {
      font-size: 13px;
      color: var(--text-tertiary);
    }

    .workflow-upload-preview {
      display: none;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 16px;
    }

    .workflow-upload-preview.has-files {
      display: flex;
    }

    .workflow-preview-item {
      position: relative;
      width: 80px;
      height: 80px;
      border-radius: 8px;
      overflow: hidden;
      background: var(--bg-tertiary);
    }

    .workflow-preview-item img,
    .workflow-preview-item video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .workflow-preview-remove {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 20px;
      height: 20px;
      background: rgba(0,0,0,0.7);
      border: none;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .workflow-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
      flex: 1;
    }

    .workflow-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .workflow-field label {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .workflow-field input,
    .workflow-field textarea {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 14px;
      font-size: 14px;
      color: var(--text-primary);
      transition: border-color 0.2s ease;
    }

    .workflow-field input:focus,
    .workflow-field textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .workflow-field textarea {
      resize: vertical;
      min-height: 100px;
    }

    .workflow-submit-btn {
      background: var(--accent);
      border: none;
      border-radius: 12px;
      padding: 14px 24px;
      font-size: 15px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: background 0.2s ease;
      margin-top: auto;
    }

    .workflow-submit-btn:hover {
      background: var(--accent-hover);
    }

    .workflow-submit-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Right - results panel */
    .workflow-results {
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      padding: 16px;
      overflow-y: auto;
    }

    .workflow-results-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .workflow-results-count {
      background: var(--bg-tertiary);
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 12px;
    }

    .workflow-results-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    .workflow-result-item {
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      aspect-ratio: 9 / 16;
      background: var(--bg-tertiary);
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .workflow-result-item:hover {
      transform: scale(1.02);
    }

    .workflow-result-item img,
    .workflow-result-item video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .workflow-result-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .workflow-result-loading .grid-item-spinner {
      width: 24px;
      height: 24px;
    }

    .workflow-result-video {
      aspect-ratio: 9 / 16;
      display: flex;
      flex-direction: column;
    }

    .workflow-result-video video {
      flex: 1;
      min-height: 0;
    }

    .workflow-download-link {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px;
      background: var(--accent);
      color: white;
      text-decoration: none;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.2s ease;
    }

    .workflow-download-link:hover {
      background: var(--accent-hover);
    }

    .workflow-results-empty {
      text-align: center;
      padding: 40px 16px;
      color: var(--text-tertiary);
      font-size: 13px;
    }

    .workflow-results-empty svg {
      width: 48px;
      height: 48px;
      color: var(--border);
      margin-bottom: 12px;
    }

    /* Legacy shortcut styles (hidden, kept for compatibility) */
    .shortcuts-grid {
      display: none;
    }

    .shortcut-card {
      display: none;
    }

    .shortcut-icon {
      width: 48px;
      height: 48px;
      background: var(--accent-glow);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
    }

    .shortcut-icon svg {
      width: 24px;
      height: 24px;
      color: var(--accent);
    }

    .shortcut-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .shortcut-desc {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    /* ===== VIDEO QUEUE ===== */
    .video-queue-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 12px;
    }

    @media (max-width: 1600px) {
      .video-queue-grid { grid-template-columns: repeat(5, 1fr); }
    }
    @media (max-width: 1400px) {
      .video-queue-grid { grid-template-columns: repeat(4, 1fr); }
    }
    @media (max-width: 1100px) {
      .video-queue-grid { grid-template-columns: repeat(3, 1fr); }
    }
    @media (max-width: 800px) {
      .video-queue-grid { grid-template-columns: repeat(2, 1fr); }
    }

    .video-queue-item {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      transition: all 0.2s ease;
    }

    .video-queue-item.generating {
      border-color: var(--accent);
    }

    .video-queue-item:hover {
      border-color: var(--accent);
    }

    .video-queue-preview {
      position: relative;
      aspect-ratio: 9 / 16;
    }

    .video-queue-thumb {
      width: 100%;
      aspect-ratio: 9 / 16;
      border-radius: 8px;
      object-fit: cover;
    }

    .video-queue-thumb.generating-blur {
      filter: blur(8px);
      opacity: 0.6;
    }

    .video-generating-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      color: white;
      font-size: 14px;
      font-weight: 500;
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .video-queue-preview {
      position: relative;
    }

    .video-queue-meta {
      padding: 12px;
      border-top: 1px solid var(--border);
    }

    .video-queue-status-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .video-queue-remove {
      margin-left: auto;
      background: none;
      border: none;
      color: var(--text-tertiary);
      font-size: 18px;
      cursor: pointer;
      padding: 0 4px;
    }

    .video-queue-remove:hover {
      color: #dc2626;
    }

    .video-queue-info {
      flex: 1;
      min-width: 0;
    }

    .video-queue-prompt {
      font-size: 13px;
      color: var(--text-primary);
      line-height: 1.5;
      margin-bottom: 8px;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .video-queue-prompt-input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 13px;
      color: var(--text-primary);
      resize: none;
      font-family: inherit;
    }

    .video-queue-prompt-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .video-queue-status {
      font-size: 12px;
      color: var(--text-tertiary);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .video-queue-status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-tertiary);
    }

    .video-queue-status-dot.pending { background: #f59e0b; }
    .video-queue-status-dot.generating { background: var(--accent); animation: pulse 1s infinite; }
    .video-queue-status-dot.complete { background: #22c55e; }
    .video-queue-status-dot.error { background: #ef4444; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .video-queue-actions {
      display: flex;
      gap: 8px;
      padding: 12px;
      border-top: 1px solid var(--border);
    }

    .video-queue-btn {
      flex: 1;
      padding: 10px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .video-queue-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .video-queue-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .video-queue-btn.primary:hover {
      background: var(--accent-hover);
    }

    .video-queue-btn svg {
      width: 14px;
      height: 14px;
    }

    /* ===== SECTIONS ===== */
    .section {
      display: none;
    }

    .section.active {
      display: block;
    }

    /* ===== VIDEO PROMPT POPUP ===== */
    .video-prompt-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(4px);
    }

    .video-prompt-popup {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 440px;
    }

    .video-prompt-popup h3 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .video-prompt-hint {
      color: var(--text-secondary);
      font-size: 14px;
      margin-bottom: 16px;
    }

    .video-prompt-input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      color: var(--text-primary);
      font-size: 14px;
      margin-bottom: 16px;
    }

    .video-prompt-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .video-prompt-input::placeholder {
      color: var(--text-tertiary);
    }

    .video-prompt-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .video-prompt-cancel {
      padding: 10px 20px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .video-prompt-cancel:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .video-prompt-confirm {
      padding: 10px 20px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .video-prompt-confirm:hover {
      background: var(--accent-hover);
    }

    /* ===== CONTEXT PROFILE MODAL ===== */
    .context-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
    }

    .context-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 500px;
    }

    .context-modal h2 {
      margin: 0 0 8px 0;
      font-size: 20px;
    }

    .context-name-input {
      width: 100%;
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: white;
      font-size: 14px;
      margin-bottom: 12px;
    }

    .context-vision-input {
      width: 100%;
      height: 160px;
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: white;
      font-size: 14px;
      resize: vertical;
      font-family: inherit;
    }

    .context-vision-input::placeholder {
      color: var(--text-tertiary);
    }

    .context-modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    .context-cancel-btn {
      padding: 10px 20px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .context-cancel-btn:hover {
      background: var(--bg-tertiary);
    }

    .context-generate-btn {
      padding: 10px 20px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-weight: 500;
    }

    .context-generate-btn:hover {
      background: var(--accent-hover);
    }

    .context-generate-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* ===== WORKFLOW MODALS ===== */
    .workflow-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
    }

    .workflow-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 28px;
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
    }

    .workflow-modal-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
    }

    .workflow-modal h2 {
      margin: 0 0 8px 0;
      font-size: 22px;
    }

    .workflow-desc {
      color: var(--text-secondary);
      font-size: 14px;
      margin-bottom: 20px;
    }

    .workflow-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .workflow-input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .workflow-input-group label {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .workflow-input-group input,
    .workflow-input-group textarea {
      padding: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: white;
      font-size: 14px;
    }

    .workflow-input-group textarea {
      min-height: 120px;
      resize: vertical;
      font-family: inherit;
    }

    .workflow-input-group input[type="file"] {
      padding: 10px;
    }

    .workflow-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 8px;
    }

    .workflow-cancel {
      padding: 10px 20px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .workflow-submit {
      padding: 10px 24px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-weight: 500;
    }

    .workflow-submit:hover {
      background: var(--accent-hover);
    }

    .workflow-status {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      color: var(--text-secondary);
    }

    .workflow-results {
      margin-top: 16px;
    }

    .workflow-output-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
    }
  </style>
</head>
<body>

  <!-- Navigation -->
  <nav class="nav">
    <div class="nav-logo">
      <img src="/aditor-logo.png" alt="Aditor" class="nav-logo-img">
      <span>Aditor Studio</span>
    </div>
    
    <div class="nav-tabs">
      <button class="nav-tab active" data-tab="images">Images</button>
      <button class="nav-tab" data-tab="videos">Videos</button>
      <button class="nav-tab" data-tab="shortcuts">Shortcuts</button>
    </div>
    
    <div class="nav-profile"></div>
  </nav>

  <!-- Main Content -->
  <main class="main">
    
    <!-- Images Section -->
    <section id="images-section" class="section active">
      <div class="grid-container">
        <div class="grid-header">
          <span class="grid-title">Your Images</span>
          <span class="grid-count" id="image-count">0 images</span>
        </div>
        
        <div class="masonry-grid" id="image-grid">
          <!-- Images will be loaded here -->
        </div>

        <div class="empty-state" id="empty-state">
          <div class="empty-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
            </svg>
          </div>
          <h3 class="empty-title">No images yet</h3>
          <p class="empty-desc">Start creating! Describe what you want in the prompt bar below, or drag reference images to guide the generation.</p>
          <button onclick="recoverFromServer()" style="margin-top: 16px; padding: 10px 20px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-secondary); cursor: pointer;">Recover images from server</button>
        </div>
      </div>
    </section>

    <!-- Videos Section -->
    <section id="videos-section" class="section">
      <div class="grid-container">
        <div class="grid-header">
          <span class="grid-title">Video Queue</span>
          <span class="grid-count" id="video-count">0 videos</span>
        </div>
        
        <div id="video-queue-container">
          <!-- Video queue items will be rendered here -->
        </div>

        <div class="empty-state" id="video-empty-state">
          <div class="empty-icon">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
            </svg>
          </div>
          <h3 class="empty-title">No videos queued</h3>
          <p class="empty-desc">Click the ⭐ on any image to add it to the video queue. We'll auto-generate a motion prompt and start rendering with Kling 3.</p>
        </div>
      </div>
    </section>

    <!-- Workflow Studio (Shortcuts Section) -->
    <section id="shortcuts-section" class="section">
      <div class="workflow-studio">
        <!-- Left Sidebar - Workflow List -->
        <div class="workflow-sidebar">
          <div class="workflow-sidebar-title">Workflows</div>
          
          <div class="workflow-item active" data-workflow="script-to-video">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Script → UGC Video</div>
              <div class="workflow-item-desc">Script + avatar → full video</div>
            </div>
          </div>

          <div class="workflow-divider">Coming Soon</div>

          <div class="workflow-item coming-soon" data-workflow="kickstarter">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Kickstarter</div>
              <div class="workflow-item-desc">URL → B-roll images</div>
            </div>
          </div>

          <div class="workflow-item coming-soon" data-workflow="image-ads">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Image Ads</div>
              <div class="workflow-item-desc">Product + inspo → ads</div>
            </div>
          </div>

          <div class="workflow-item coming-soon" data-workflow="screenshot-broll">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Screenshot → B-roll</div>
              <div class="workflow-item-desc">Recreate creator frames</div>
            </div>
          </div>

          <div class="workflow-item coming-soon" data-workflow="motion-transfer">
            <div class="workflow-item-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
              </svg>
            </div>
            <div class="workflow-item-text">
              <div class="workflow-item-name">Motion Transfer</div>
              <div class="workflow-item-desc">Image + video → animate</div>
            </div>
          </div>
        </div>

        <!-- Center - Active Workflow Input -->
        <div class="workflow-main" id="workflow-main">
          <div class="workflow-header">
            <h2 id="workflow-title">Script → UGC Video</h2>
            <p id="workflow-description">Upload avatar, paste script, select voice → get UGC video</p>
          </div>

          <!-- UGC Video Layout (default for script-to-video) -->
          <div class="ugc-video-layout" id="ugc-video-layout">
            <div class="ugc-avatar-section">
              <div class="ugc-avatar-upload" id="ugc-avatar-upload">
                <div class="avatar-placeholder">
                  <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                  </svg>
                  <span>Drop avatar image</span>
                </div>
                <input type="file" id="ugc-avatar-input" accept="image/*" hidden>
              </div>
            </div>
            
            <div class="ugc-script-section">
              <textarea class="ugc-script-textarea" id="ugc-script" placeholder="Paste your script here..."></textarea>
              
              <div class="ugc-voice-row">
                <label>Voice</label>
                <select class="ugc-voice-select" id="ugc-voice">
                  <option value="alloy">Alloy (neutral)</option>
                  <option value="echo">Echo (male)</option>
                  <option value="fable">Fable (storyteller)</option>
                  <option value="onyx">Onyx (deep male)</option>
                  <option value="nova">Nova (female)</option>
                  <option value="shimmer">Shimmer (soft female)</option>
                </select>
                <button type="button" class="ugc-generate-btn" id="ugc-generate-btn">Generate</button>
              </div>
            </div>
          </div>

          <!-- Generic workflow upload zone (for other workflows) -->
          <div class="workflow-upload-zone" id="workflow-upload-zone" style="display: none;">
            <div class="workflow-upload-icon">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
              </svg>
            </div>
            <div class="workflow-upload-text">Drop files here or click to upload</div>
            <div class="workflow-upload-hint" id="workflow-upload-hint">Accepts images and videos</div>
            <input type="file" id="workflow-file-input" multiple hidden>
            <div class="workflow-upload-preview" id="workflow-upload-preview"></div>
          </div>

          <!-- Generic workflow form (for other workflows) -->
          <form class="workflow-form" id="workflow-form" style="display: none;">
            <div class="workflow-field" id="url-field" style="display: none;">
              <label for="workflow-url">Product URL</label>
              <input type="url" id="workflow-url" placeholder="https://example.com/product">
            </div>

            <div class="workflow-field" id="script-field" style="display: none;">
              <label for="workflow-script">Script</label>
              <textarea id="workflow-script" placeholder="Paste your script here..."></textarea>
            </div>

            <button type="submit" class="workflow-submit-btn" id="workflow-submit">Generate</button>
          </form>
        </div>

        <!-- Right - Results Panel -->
        <div class="workflow-results">
          <div class="workflow-results-title">
            Results
            <span class="workflow-results-count" id="workflow-results-count">0</span>
          </div>
          
          <div class="workflow-results-empty" id="workflow-results-empty">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
            </svg>
            <div>Results will appear here</div>
          </div>

          <div class="workflow-results-grid" id="workflow-results-grid"></div>
        </div>
      </div>
    </section>

  </main>

  <!-- Prompt Bar -->
  <div class="prompt-container">
    <div class="prompt-bar" id="prompt-bar">
      <div class="prompt-references" id="prompt-references">
        <!-- Reference images appear here -->
      </div>
      
      <div class="prompt-input-row">
        <input type="text" class="prompt-input" id="prompt-input" placeholder="Describe your image... or drop references here">
        <button class="prompt-btn" id="generate-btn">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3l14 9-14 9V3z"/>
          </svg>
        </button>
      </div>
      
      <div class="prompt-options">
        <button class="prompt-option active" id="gen-mode-btn" title="Click to switch mode">🎬 B-roll</button>
        <select class="prompt-select" id="aspect-ratio">
          <option value="9:16" selected>9:16 vertical</option>
          <option value="1:1">1:1 square</option>
          <option value="16:9">16:9 horizontal</option>
          <option value="4:5">4:5 portrait</option>
        </select>
        <select class="prompt-select" id="model-select">
          <option value="nano-banana-pro" selected>Nano Banana Pro</option>
          <option value="z-image">Z Image</option>
        </select>
        <select class="prompt-select" id="gen-count" title="Number of images to generate">
          <option value="1">×1</option>
          <option value="2" selected>×2</option>
          <option value="3">×3</option>
          <option value="4">×4</option>
          <option value="6">×6</option>
          <option value="8">×8</option>
        </select>
        <span style="color: var(--text-tertiary); font-size: 12px; margin-left: 8px;">→</span>
        <select class="prompt-select" id="video-model-select" title="Default video model for starred images">
          <option value="kling3" selected>Kling 3</option>
          <option value="seedance2">Seedance 2</option>
        </select>
      </div>
    </div>
  </div>

  <!-- Fullscreen Modal -->
  <div class="modal-overlay" id="modal">
    <div class="modal-content">
      <button class="modal-close" id="modal-close">×</button>
      <img class="modal-image" id="modal-image" src="">
      <div class="modal-actions">
        <button class="modal-btn" id="modal-variations">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM14 5a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1V5zM4 15a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1v-4zM14 15a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/>
          </svg>
          4 Variations
        </button>
        <button class="modal-btn" id="modal-reference">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"/>
          </svg>
          Reference
        </button>
        <button class="modal-btn" id="modal-reuse">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
          </svg>
          Reuse Prompt
        </button>
        <button class="modal-btn" id="modal-video">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
          </svg>
          → Video
        </button>
        <button class="modal-btn primary" id="modal-download">
          <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
          </svg>
          Download
        </button>
      </div>
      <div class="modal-meta" id="modal-meta">
        <!-- Prompt and settings will appear here -->
      </div>
    </div>
  </div>

  <!-- Generating indicator -->
  <div class="generating" id="generating">
    <div class="generating-spinner"></div>
    <span class="generating-text">Generating...</span>
  </div>

  <script>
    // ===== STATE =====
    let images = [];
    let references = [];
    let currentImage = null;
    let selectedRatio = '9:16';
    let selectedModel = 'nano-banana-pro';
    let genMode = 'broll'; // 'broll' | 'talking' | 'raw'
    let videoQueue = []; // {id, image, prompt, status: 'pending'|'generating'|'complete'|'error', videoUrl}

    // ===== PERSISTENCE =====
    const STORAGE_KEY = 'aditor_studio_images';
    
    function loadSavedImages() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          images = JSON.parse(saved);
          console.log(`Loaded ${images.length} images from storage`);
        }
      } catch (e) {
        console.error('Failed to load images:', e);
      }
      
      // If no images in localStorage, try to load from server
      if (images.length === 0) {
        loadRecentFromServer();
      }
    }
    
    async function loadRecentFromServer() {
      try {
        const response = await fetch('/api/outputs/recent');
        if (response.ok) {
          const data = await response.json();
          if (data.images && data.images.length > 0) {
            images = data.images;
            saveImages();
            renderGrid();
            console.log(`Loaded ${images.length} recent images from server`);
          }
        }
      } catch (e) {
        console.log('No recent images from server');
      }
    }
    
    function saveImages() {
      try {
        // Keep last 100 images max
        const toSave = images.slice(0, 100);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
      } catch (e) {
        console.error('Failed to save images:', e);
      }
    }

    // Recovery function - loads all images from server
    window.recoverFromServer = async function() {
      try {
        const response = await fetch('/api/outputs/recent?limit=100');
        if (response.ok) {
          const data = await response.json();
          if (data.images && data.images.length > 0) {
            images = data.images;
            saveImages();
            renderGrid();
            console.log(`✅ Recovered ${images.length} images from server`);
            alert(`Recovered ${images.length} images!`);
          } else {
            alert('No images found on server');
          }
        }
      } catch (e) {
        console.error('Recovery failed:', e);
        alert('Failed to recover images: ' + e.message);
      }
    };
    
    // Load on startup
    loadSavedImages();

    // ===== DOM =====
    const imageGrid = document.getElementById('image-grid');
    const imageCount = document.getElementById('image-count');
    const emptyState = document.getElementById('empty-state');
    const promptBar = document.getElementById('prompt-bar');
    const promptInput = document.getElementById('prompt-input');
    const promptReferences = document.getElementById('prompt-references');
    const generateBtn = document.getElementById('generate-btn');
    const modal = document.getElementById('modal');
    const modalImage = document.getElementById('modal-image');
    const generating = document.getElementById('generating');

    // ===== TAB SWITCHING =====
    document.querySelectorAll('.nav-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tab.dataset.tab}-section`).classList.add('active');
        
        // Handle prompt bar visibility based on tab and workflow
        const promptBar = document.querySelector('.prompt-container');
        if (promptBar) {
          if (tab.dataset.tab === 'shortcuts') {
            // Check if current workflow uses custom layout (hide prompt bar)
            const config = workflowConfigs[currentWorkflow];
            promptBar.style.display = config?.customLayout ? 'none' : 'block';
          } else {
            // Images/Videos tabs always show prompt bar
            promptBar.style.display = 'block';
          }
        }
      });
    });

    // ===== PROMPT OPTIONS =====
    const aspectRatioSelect = document.getElementById('aspect-ratio');
    const modelSelect = document.getElementById('model-select');
    
    aspectRatioSelect.addEventListener('change', (e) => {
      selectedRatio = e.target.value;
    });
    
    modelSelect.addEventListener('change', (e) => {
      selectedModel = e.target.value;
    });

    // Generation mode toggle (click to cycle)
    const genModeBtn = document.getElementById('gen-mode-btn');
    const genModes = ['broll', 'talking', 'raw'];
    const genModeLabels = {
      'broll': '🎬 B-roll',
      'talking': '🗣️ Talking Head', 
      'raw': '📝 Raw'
    };
    
    genModeBtn.addEventListener('click', () => {
      const currentIndex = genModes.indexOf(genMode);
      const nextIndex = (currentIndex + 1) % genModes.length;
      genMode = genModes[nextIndex];
      genModeBtn.textContent = genModeLabels[genMode];
      genModeBtn.classList.toggle('active', genMode !== 'raw');
    });

    // Default video model for starred images
    const videoModelSelect = document.getElementById('video-model-select');
    let defaultVideoModel = 'kling3';
    videoModelSelect.addEventListener('change', (e) => {
      defaultVideoModel = e.target.value;
    });

    // ===== UGC PROMPT ENHANCER =====
    // Automatically makes prompts more realistic/authentic for UGC-style content
    
    const UGC_ENHANCEMENTS = {
      // Add these for realism
      add: [
        'shot on iPhone',
        'natural lighting',
        'candid moment',
        'authentic',
        'unposed',
        'real environment',
        'slight motion blur',
        'natural skin texture',
        'casual setting'
      ],
      // Avoid these (make it look AI-generated)
      avoid: [
        'hyper realistic', 'ultra realistic', '8k', 'octane render', 
        'unreal engine', 'studio lighting', 'perfect', 'flawless',
        'symmetrical', 'centered composition', 'professional photo',
        'stock photo', 'advertising', 'commercial'
      ],
      // Replace these terms
      replace: {
        'beautiful': 'natural-looking',
        'perfect skin': 'real skin texture',
        'studio': 'home',
        'professional': 'casual',
        'model': 'person',
        'posing': 'candid'
      },
      // Negative prompt additions (if model supports)
      negative: [
        'artificial', 'plastic skin', 'airbrushed', 'oversaturated',
        'HDR', 'oversharpened', 'stock photo', 'advertisement',
        'symmetrical face', 'perfect teeth', 'glamour lighting'
      ]
    };

    // ===== B-ROLL MODE EXPANSION =====
    // Camera roll realism - like actual photos from someone's phone
    function expandBrollPrompt(prompt) {
      if (!prompt) return prompt;
      
      // Candid photo moments (NO screenshot/UI references)
      const cameraRollVibes = [
        'accidental burst photo, slightly between poses',
        'candid moment caught naturally',
        'photo taken mid-laugh, candid moment',
        'blurry background person walking through',
        'taken while walking, slight motion',
        'quick snap, casual timing',
        'spontaneous photo, unplanned moment',
        'casual photo shared between friends'
      ];
      
      // Lo-fi imperfections
      const lofiElements = [
        'slight grain, not sharp, compressed jpeg quality',
        'soft focus, not everything crisp',
        'small lens flare from window',
        'slight overexposure from bright window',
        'shadow falling across part of frame',
        'warm color cast from indoor lighting',
        'slightly tilted horizon, not perfectly level',
        'harsh flash illuminating foreground only'
      ];
      
      // Framing mistakes real people make
      const framingQuirks = [
        'subject slightly off-center, too much headroom',
        'something random cut off at edge of frame',
        'thumb slightly visible in corner',
        'awkward crop, didnt frame it properly',
        'too close, face fills frame',
        'too far, lots of empty space around subject',
        'reflection visible in glass or mirror behind'
      ];
      
      // Real messy environments (NO branded packaging)
      const realMess = [
        'water bottle and charger on nightstand',
        'pile of clothes on chair in background',
        'shoes kicked off by door visible',
        'cardboard box in corner of room',
        'half-eaten snack on desk',
        'tangled earbuds somewhere in frame',
        'random hand cream or chapstick visible',
        'phone charger cable dangling'
      ];
      
      // Time of day feeling
      const timeVibes = [
        'lazy sunday morning light',
        'late night scrolling lighting, just lamp on',
        'harsh midday light through window',
        'getting ready to go out lighting',
        'just got home energy',
        'waiting for food to arrive vibes'
      ];
      
      const vibe = cameraRollVibes[Math.floor(Math.random() * cameraRollVibes.length)];
      const lofi = lofiElements[Math.floor(Math.random() * lofiElements.length)];
      const framing = framingQuirks[Math.floor(Math.random() * framingQuirks.length)];
      const mess = realMess[Math.floor(Math.random() * realMess.length)];
      const time = timeVibes[Math.floor(Math.random() * timeVibes.length)];
      
      return `${vibe} of ${prompt}, ${lofi}, ${framing}, ${mess}, ${time}, shot on iphone, vertical 9:16 portrait, raw photo file, not aesthetic not curated, casual authentic photograph, candid snapshot, fullscreen image with no UI no timestamps no dates no text overlays`;
    }
    
    // ===== TALKING HEAD MODE EXPANSION =====
    // For creating stills that will be animated to talk
    function expandTalkingHeadPrompt(prompt) {
      if (!prompt) return prompt;
      
      // Camera setups (NO phone visible ever)
      const cameraSetups = [
        'selfie camera at natural arms length, slightly below eye level',
        'phone propped on window ledge, soft natural light',
        'tripod setup at desk height, eye-level framing',
        'camera resting against books on shelf, casual angle',
        'ring light setup visible in catch lights, phone mounted'
      ];
      
      // Mid-sentence expressions (for lip sync)
      const expressions = [
        'mouth slightly open mid-word, engaged expression',
        'about to say something, slight eyebrow raise',
        'paused mid-thought, relaxed face',
        'casual talking expression, not too animated',
        'natural speaking moment, eyes engaged with camera'
      ];
      
      // Backgrounds (sharp focus, not blurred)
      const backgrounds = [
        'living room bookshelf and couch in sharp focus behind',
        'bedroom with bed and nightstand visible, everything in focus',
        'home office with monitor and plants visible',
        'kitchen with cabinets and fridge magnets in background',
        'plain wall with one piece of art, simple background'
      ];
      
      // Lighting (flat, not cinematic)
      const lighting = [
        'flat even indoor lighting, soft and natural',
        'soft daylight from window, no harsh shadows',
        'ring light creating even illumination',
        'overhead room light plus window, balanced',
        'natural afternoon light, not golden hour'
      ];
      
      // Clothing (not generic)
      const clothingNotes = [
        'wearing lived-in comfortable clothes',
        'casual hoodie or sweater',
        'simple t-shirt, slightly wrinkled naturally',
        'cozy cardigan or flannel'
      ];
      
      const setup = cameraSetups[Math.floor(Math.random() * cameraSetups.length)];
      const expression = expressions[Math.floor(Math.random() * expressions.length)];
      const bg = backgrounds[Math.floor(Math.random() * backgrounds.length)];
      const light = lighting[Math.floor(Math.random() * lighting.length)];
      const clothes = clothingNotes[Math.floor(Math.random() * clothingNotes.length)];
      
      return `Vertical 9:16 iPhone video frame of ${prompt}, ${expression}, ${setup}, ${light}, ${bg}, ${clothes}, NO phone visible in frame, no text no UI no overlays no REC indicator no timestamps no dates, casual home video feel, authentic not performative, relaxed genuine expression`;
    }

    function enhancePromptForUGC(prompt) {
      if (!prompt) return prompt;
      
      let enhanced = prompt.toLowerCase();
      
      // Remove terms that make images look AI-generated
      UGC_ENHANCEMENTS.avoid.forEach(term => {
        enhanced = enhanced.replace(new RegExp(term, 'gi'), '');
      });
      
      // Replace problematic terms
      Object.entries(UGC_ENHANCEMENTS.replace).forEach(([from, to]) => {
        enhanced = enhanced.replace(new RegExp(from, 'gi'), to);
      });
      
      // Clean up extra spaces
      enhanced = enhanced.replace(/\s+/g, ' ').trim();
      
      // Add UGC modifiers (pick 3-4 relevant ones)
      const addons = [];
      
      // Always add these core ones
      addons.push('shot on iPhone 15 Pro');
      addons.push('natural lighting');
      
      // Add context-specific ones
      if (enhanced.includes('person') || enhanced.includes('woman') || enhanced.includes('man') || enhanced.includes('creator')) {
        addons.push('candid moment');
        addons.push('authentic expression');
        addons.push('natural skin texture with pores');
      }
      
      if (enhanced.includes('product') || enhanced.includes('holding')) {
        addons.push('casual home environment');
        addons.push('slightly messy background');
      }
      
      // Combine
      const finalPrompt = `${enhanced}, ${addons.join(', ')}`;
      
      return finalPrompt;
    }

    function getUGCNegativePrompt() {
      return UGC_ENHANCEMENTS.negative.join(', ');
    }

    // ===== LLM PROMPT EXPANSION =====
    // Converts simple prompts to detailed JSON for Nano Banana Pro
    
    const PROMPT_EXPANSION_TEMPLATE = `You are a prompt engineer for Nano Banana Pro image generation. Convert the user's simple request into a detailed JSON prompt optimized for ultra-realistic UGC (user-generated content) style images.

The output must be authentic-looking content suitable for social media ads - NOT polished studio shots.

USER REQUEST: {{INPUT}}

Output a JSON object with these exact keys:
{
  "label": "short-kebab-case-name",
  "tags": ["3-5 style tags"],
  "Style": ["documentary-candid-style", "social-media-native"],
  "Subject": ["detailed subject description", "physical traits if person", "expression"],
  "MadeOutOf": ["materials", "textures", "fabric types"],
  "Arrangement": "pose and placement description",
  "Background": "realistic home/casual environment",
  "ColorRestriction": ["natural tones only", "no oversaturation"],
  "Lighting": "describe natural/phone lighting",
  "Camera": {
    "type": "iPhone 15 Pro or similar phone",
    "lens": "24-35mm equivalent",
    "aperture": "f/1.8",
    "style": "selfie or handheld"
  },
  "OutputStyle": "authentic social media photo",
  "Mood": "casual, relatable, real"
}

CRITICAL RULES FOR UGC REALISM:
- ALWAYS use phone camera specs (iPhone 15 Pro, Pixel 8)
- NEVER use studio lighting terms
- ALWAYS include "natural skin texture with pores" for people
- ALWAYS use messy/real backgrounds (bathroom counter, bedroom, kitchen)
- Include slight imperfections (motion blur ok, not perfectly centered)
- Expression should be natural, not posed/model-like

Return ONLY the JSON, no explanation.`;

    async function expandPromptWithLLM(simplePrompt) {
      try {
        // Get selected context profile
        const contextSelect = document.getElementById('context-profile');
        const contextId = contextSelect?.value || null;
        
        const response = await fetch('/api/prompt/expand', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: simplePrompt,
            mode: 'ugc',
            contextId: contextId
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('LLM expanded JSON:', data.json);
          if (contextId) console.log('Using context profile:', contextId);
          return data.json;
        }
      } catch (err) {
        console.error('LLM expansion failed:', err);
      }
      
      // Fallback: return null (will use simple enhancement)
      return null;
    }

    function jsonPromptToString(jsonPrompt) {
      // Convert JSON prompt to string format for Nano Banana Pro
      if (!jsonPrompt) return null;
      
      const parts = [];
      
      if (jsonPrompt.Style) parts.push(`Style: ${jsonPrompt.Style.join(', ')}`);
      if (jsonPrompt.Subject) parts.push(`Subject: ${jsonPrompt.Subject.join(', ')}`);
      if (jsonPrompt.MadeOutOf) parts.push(`Materials: ${jsonPrompt.MadeOutOf.join(', ')}`);
      if (jsonPrompt.Arrangement) parts.push(`Pose: ${jsonPrompt.Arrangement}`);
      if (jsonPrompt.Background) parts.push(`Background: ${jsonPrompt.Background}`);
      if (jsonPrompt.Lighting) parts.push(`Lighting: ${jsonPrompt.Lighting}`);
      if (jsonPrompt.Camera) {
        parts.push(`Camera: ${jsonPrompt.Camera.type}, ${jsonPrompt.Camera.lens}, ${jsonPrompt.Camera.aperture}, ${jsonPrompt.Camera.style}`);
      }
      if (jsonPrompt.OutputStyle) parts.push(`Output: ${jsonPrompt.OutputStyle}`);
      if (jsonPrompt.Mood) parts.push(`Mood: ${jsonPrompt.Mood}`);
      if (jsonPrompt.ColorRestriction) parts.push(`Colors: ${jsonPrompt.ColorRestriction.join(', ')}`);
      
      return parts.join('. ');
    }

    // ===== DRAG & DROP =====
    
    // Grid items are draggable - direct attachment
    function makeGridItemDraggable(item, imgSrc) {
      item.setAttribute('draggable', 'true');
      item.dataset.src = imgSrc;
      
      item.ondragstart = function(e) {
        e.dataTransfer.setData('text/plain', imgSrc);
        e.dataTransfer.effectAllowed = 'copy';
        item.classList.add('dragging');
        console.log('[Drag] Started:', imgSrc);
      };
      
      item.ondragend = function() {
        item.classList.remove('dragging');
      };
    }

    // Prompt bar accepts drops
    promptBar.addEventListener('dragover', (e) => {
      e.preventDefault();
      promptBar.classList.add('drag-over');
    });

    promptBar.addEventListener('dragleave', () => {
      promptBar.classList.remove('drag-over');
    });

    promptBar.addEventListener('drop', (e) => {
      e.preventDefault();
      promptBar.classList.remove('drag-over');
      
      // Handle image from grid (http URLs or local /outputs/ paths)
      const imgSrc = e.dataTransfer.getData('text/plain');
      console.log('[Drop] Received:', imgSrc);
      
      if (imgSrc && imgSrc.length > 0) {
        addReference(imgSrc);
        return;
      }
      
      // Handle file drop
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        Array.from(files).forEach(file => {
          if (file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (e) => addReference(e.target.result);
            reader.readAsDataURL(file);
          }
        });
      }
    });

    // ===== REFERENCES =====
    function addReference(src) {
      if (references.length >= 4) return; // Max 4 references
      references.push(src);
      renderReferences();
    }

    function removeReference(index) {
      references.splice(index, 1);
      renderReferences();
    }

    function renderReferences() {
      promptReferences.innerHTML = references.map((src, i) => `
        <div class="prompt-ref">
          <img src="${src}" alt="Reference ${i + 1}">
          <button class="prompt-ref-remove" onclick="removeReference(${i})">×</button>
        </div>
      `).join('');
    }

    // ===== IMAGE GRID =====
    function renderGrid() {
      if (images.length === 0) {
        imageGrid.innerHTML = '';
        emptyState.style.display = 'block';
        imageCount.textContent = '0 images';
        return;
      }

      emptyState.style.display = 'none';
      imageCount.textContent = `${images.length} image${images.length === 1 ? '' : 's'}`;
      
      imageGrid.innerHTML = images.map((img, i) => {
        // Loading placeholder
        if (img.loading) {
          return `
            <div class="grid-item grid-item-loading" data-index="${i}">
              <div class="grid-item-loading-inner">
                <div class="grid-item-spinner"></div>
                <span class="grid-item-loading-text">${img.prompt ? img.prompt.slice(0, 30) + '...' : 'Generating...'}</span>
              </div>
            </div>
          `;
        }
        
        const isQueued = videoQueue.some(v => v.image.url === img.url);
        return `
          <div class="grid-item" data-index="${i}">
            <img src="${img.url}" alt="${img.prompt || 'Generated image'}">
            <span class="grid-item-drag-hint">Drag to reference</span>
            <button class="grid-item-delete" onclick="event.stopPropagation(); deleteImage(${i})" title="Delete image">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
              </svg>
            </button>
            <button class="grid-item-save ${isQueued ? 'saved' : ''}" onclick="event.stopPropagation(); toggleVideoQueue(${i})" title="${isQueued ? 'Remove from video queue' : 'Add to video queue'}">
              <svg fill="${isQueued ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"/>
              </svg>
            </button>
          </div>
        `;
      }).join('');

      // Make items draggable
      document.querySelectorAll('.grid-item').forEach((item, i) => {
        makeGridItemDraggable(item, images[i].url);
        item.addEventListener('click', (e) => {
          if (e.target.tagName !== 'BUTTON' && !e.target.closest('.grid-item-save')) {
            openModal(i);
          }
        });
      });
    }

    // ===== MODAL =====
    const modalMeta = document.getElementById('modal-meta');

    function openModal(index) {
      currentImage = images[index];
      modalImage.src = currentImage.url;
      
      // Show metadata
      if (currentImage.prompt) {
        modalMeta.innerHTML = `
          <div class="modal-meta-prompt">"${currentImage.prompt}"</div>
          <div class="modal-meta-settings">
            <div class="modal-meta-item">
              <span class="modal-meta-label">Ratio:</span>
              <span>${currentImage.ratio || '9:16'}</span>
            </div>
            <div class="modal-meta-item">
              <span class="modal-meta-label">Model:</span>
              <span>${currentImage.model || 'Flux'}</span>
            </div>
          </div>
          <div class="modal-meta-actions">
            <button class="modal-meta-btn" onclick="copyPrompt()">Copy prompt</button>
            <button class="modal-meta-btn" onclick="rerunPrompt()">Re-run</button>
          </div>
        `;
      } else {
        modalMeta.innerHTML = '';
      }
      
      modal.classList.add('active');
    }

    function closeModal() {
      modal.classList.remove('active');
      currentImage = null;
    }

    function copyPrompt() {
      if (currentImage?.prompt) {
        navigator.clipboard.writeText(currentImage.prompt);
      }
    }

    function rerunPrompt() {
      if (currentImage?.prompt) {
        promptInput.value = currentImage.prompt;
        if (currentImage.ratio) {
          aspectRatioSelect.value = currentImage.ratio;
          selectedRatio = currentImage.ratio;
        }
        closeModal();
        promptInput.focus();
      }
    }

    document.getElementById('modal-close').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });

    document.getElementById('modal-reference').addEventListener('click', () => {
      if (currentImage) {
        addReference(currentImage.url);
        closeModal();
      }
    });

    document.getElementById('modal-variations').addEventListener('click', () => {
      if (currentImage) {
        // Generate 4 variations
        generateVariations(currentImage);
        closeModal();
      }
    });

    document.getElementById('modal-download').addEventListener('click', () => {
      if (currentImage) {
        const a = document.createElement('a');
        a.href = currentImage.url;
        a.download = `aditor-${Date.now()}.png`;
        a.click();
      }
    });

    document.getElementById('modal-video').addEventListener('click', () => {
      if (currentImage) {
        addToVideoQueue(images.indexOf(currentImage));
        closeModal();
      }
    });

    document.getElementById('modal-reuse').addEventListener('click', () => {
      if (currentImage && currentImage.prompt) {
        promptInput.value = currentImage.prompt;
        closeModal();
        promptInput.focus();
      }
    });

    async function generateVariations(img) {
      generating.classList.add('active');
      document.querySelector('.generating-text').textContent = 'Generating 4 variations...';
      
      try {
        // TODO: Replace with actual API call
        const response = await fetch('/api/variations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sourceImage: img.url,
            prompt: img.prompt,
            count: 4
          })
        });

        if (response.ok) {
          const data = await response.json();
          data.images.forEach(url => {
            images.unshift({
              url,
              prompt: img.prompt + ' (variation)',
              ratio: img.ratio,
              model: img.model,
              createdAt: new Date().toISOString()
            });
          });
          renderGrid();
        }
      } catch (err) {
        // Demo mode: add placeholder variations
        for (let i = 0; i < 4; i++) {
          images.unshift({
            url: `https://picsum.photos/seed/${Date.now() + i}/400/700`,
            prompt: img.prompt + ' (variation)',
            ratio: img.ratio,
            model: img.model,
            createdAt: new Date().toISOString()
          });
        }
        renderGrid();
      } finally {
        generating.classList.remove('active');
        document.querySelector('.generating-text').textContent = 'Generating...';
      }
    }

    // ===== VIDEO QUEUE =====
    const videoQueueContainer = document.getElementById('video-queue-container');
    const videoEmptyState = document.getElementById('video-empty-state');
    const videoCount = document.getElementById('video-count');

    function deleteImage(index) {
      const img = images[index];
      // Remove from video queue if present
      const queueIndex = videoQueue.findIndex(v => v.image.url === img.url);
      if (queueIndex >= 0) {
        videoQueue.splice(queueIndex, 1);
      }
      // Remove from images array
      images.splice(index, 1);
      saveImages();
      renderGrid();
      renderVideoQueue();
      updateVideoTabBadge();
    }

    function toggleVideoQueue(index) {
      const img = images[index];
      const existingIndex = videoQueue.findIndex(v => v.image.url === img.url);
      
      if (existingIndex >= 0) {
        // Remove from queue
        videoQueue.splice(existingIndex, 1);
        renderGrid();
        renderVideoQueue();
        updateVideoTabBadge();
      } else {
        // Show popup for video prompt
        showVideoPromptPopup(img);
      }
    }
    
    function showVideoPromptPopup(img) {
      // Create popup overlay
      const overlay = document.createElement('div');
      overlay.className = 'video-prompt-overlay';
      overlay.innerHTML = `
        <div class="video-prompt-popup">
          <h3>Add to Video Queue</h3>
          <p class="video-prompt-hint">Optional: describe the motion you want</p>
          <input type="text" class="video-prompt-input" placeholder="e.g., slow zoom in, she looks up and smiles..." autofocus>
          <div class="video-prompt-actions">
            <button class="video-prompt-cancel">Cancel</button>
            <button class="video-prompt-confirm">Add to Queue</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      const input = overlay.querySelector('.video-prompt-input');
      const cancelBtn = overlay.querySelector('.video-prompt-cancel');
      const confirmBtn = overlay.querySelector('.video-prompt-confirm');
      
      function addToQueue() {
        const customPrompt = input.value.trim();
        const videoPrompt = customPrompt || generateVideoPrompt(img.prompt);
        
        const newItem = {
          id: Date.now(),
          image: img,
          prompt: videoPrompt,
          status: 'generating',
          model: defaultVideoModel,
          videoUrl: null
        };
        
        videoQueue.push(newItem);
        
        renderGrid();
        renderVideoQueue();
        updateVideoTabBadge();
        overlay.remove();
        
        // Auto-start video generation
        generateVideo(newItem.id);
      }
      
      function cancel() {
        overlay.remove();
      }
      
      // Event listeners
      confirmBtn.addEventListener('click', addToQueue);
      cancelBtn.addEventListener('click', cancel);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) cancel();
      });
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          addToQueue();
        }
        if (e.key === 'Escape') cancel();
      });
      
      // Focus input
      setTimeout(() => input.focus(), 100);
    }

    function generateVideoPrompt(imagePrompt) {
      // Research-backed video prompt enhancement for Kling/AI video gen
      // Based on: fal.ai Kling 2.6 Pro guide, Leonardo.ai Kling prompts, VEED guide
      
      if (!imagePrompt) {
        return 'Gentle camera movement, natural subtle motion, cinematic lighting, shallow depth of field, high quality UGC style';
      }
      
      // Motion types that work well with different subjects
      const motionPatterns = {
        person: [
          'subtle natural breathing motion, gentle hair movement from soft breeze',
          'slight head turn with natural eye movement, relaxed posture shift',
          'natural micro-movements, subtle facial expression change',
          'gentle body sway, authentic candid movement'
        ],
        product: [
          'slow 15-degree rotation, subtle floating motion',
          'gentle camera orbit around subject, soft highlight shifts',
          'smooth push-in revealing product details',
          'elegant slow-motion presentation'
        ],
        scene: [
          'slow cinematic pan across the scene',
          'gentle parallax movement, atmospheric elements drift naturally',
          'smooth tracking shot through environment',
          'subtle depth reveal with rack focus'
        ]
      };
      
      // Camera movements (Kling-optimized)
      const cameraMovements = [
        'camera slowly tracks right while maintaining focus',
        'gentle push-in toward subject',
        'subtle dolly movement with shallow depth of field',
        'smooth handheld-style micro-movements',
        'slow cinematic pan',
        'gentle floating camera movement'
      ];
      
      // Style additions for UGC/social media
      const ugcStyle = [
        'natural lighting, authentic social media aesthetic',
        'high-quality UGC style, minimal polish, genuine feel',
        'iPhone-captured quality, natural color grading',
        'candid documentary feel, organic movement'
      ];
      
      // Detect subject type from prompt
      const promptLower = imagePrompt.toLowerCase();
      let subjectType = 'scene';
      if (promptLower.includes('person') || promptLower.includes('woman') || promptLower.includes('man') || 
          promptLower.includes('girl') || promptLower.includes('guy') || promptLower.includes('influencer') ||
          promptLower.includes('holding') || promptLower.includes('sitting') || promptLower.includes('standing')) {
        subjectType = 'person';
      } else if (promptLower.includes('product') || promptLower.includes('bottle') || promptLower.includes('box') ||
                 promptLower.includes('phone') || promptLower.includes('device') || promptLower.includes('package')) {
        subjectType = 'product';
      }
      
      // Build enhanced prompt
      const motion = motionPatterns[subjectType][Math.floor(Math.random() * motionPatterns[subjectType].length)];
      const camera = cameraMovements[Math.floor(Math.random() * cameraMovements.length)];
      const style = ugcStyle[Math.floor(Math.random() * ugcStyle.length)];
      
      return `${motion}, ${camera}, ${style}`;
    }

    function updateVideoTabBadge() {
      const tab = document.querySelector('.nav-tab[data-tab="videos"]');
      const pendingCount = videoQueue.filter(v => v.status === 'pending').length;
      
      if (pendingCount > 0) {
        tab.innerHTML = `Videos <span style="background: var(--accent); color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px; margin-left: 6px;">${pendingCount}</span>`;
      } else {
        tab.textContent = 'Videos';
      }
    }

    function renderVideoQueue() {
      if (videoQueue.length === 0) {
        videoQueueContainer.innerHTML = '';
        videoEmptyState.style.display = 'block';
        videoCount.textContent = '0 videos';
        return;
      }

      videoEmptyState.style.display = 'none';
      videoCount.textContent = `${videoQueue.length} video${videoQueue.length === 1 ? '' : 's'}`;
      
      videoQueueContainer.innerHTML = `
        <div class="video-queue-grid">
          ${videoQueue.map((item, i) => `
            <div class="video-queue-item ${item.status}" data-id="${item.id}">
              <div class="video-queue-preview">
                ${item.status === 'complete' && item.videoUrl ? `
                  <video class="video-queue-thumb" src="${item.videoUrl}" autoplay loop muted playsinline></video>
                ` : `
                  <img class="video-queue-thumb ${item.status === 'generating' ? 'generating-blur' : ''}" src="${item.image.url}" alt="">
                  ${item.status === 'generating' ? '<div class="video-generating-overlay"><div class="spinner"></div><span>Generating...</span></div>' : ''}
                `}
              </div>
              <div class="video-queue-meta">
                <div class="video-queue-prompt">${item.prompt.substring(0, 60)}${item.prompt.length > 60 ? '...' : ''}</div>
                <div class="video-queue-status-row">
                  <span class="video-queue-status-dot ${item.status}"></span>
                  <span>${item.status === 'generating' ? 'Generating...' : item.status === 'complete' ? 'Ready' : item.status === 'error' ? 'Error' : 'Pending'}</span>
                  <button class="video-queue-remove" onclick="removeFromQueue(${item.id})" title="Remove">×</button>
                </div>
              </div>
            </div>
          `).join('')}
        </div>
        ${videoQueue.filter(v => v.status === 'pending').length > 1 ? `
          <div style="margin-top: 20px; text-align: center;">
            <button class="video-queue-btn primary" onclick="generateAllVideos()" style="width: auto; padding: 12px 32px;">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 16px; height: 16px;">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
              </svg>
              Generate All (${videoQueue.filter(v => v.status === 'pending').length} videos)
            </button>
          </div>
        ` : ''}
      `;
    }

    function updateVideoPrompt(id, newPrompt) {
      const item = videoQueue.find(v => v.id === id);
      if (item) item.prompt = newPrompt;
    }

    function updateVideoModel(id, model) {
      const item = videoQueue.find(v => v.id === id);
      if (item) item.model = model;
    }

    function removeFromQueue(id) {
      videoQueue = videoQueue.filter(v => v.id !== id);
      renderGrid();
      renderVideoQueue();
      updateVideoTabBadge();
    }

    async function generateVideo(id) {
      const item = videoQueue.find(v => v.id === id);
      if (!item) return;
      
      item.status = 'generating';
      renderVideoQueue();
      
      try {
        // Use Kling API (via PiAPI Host-Your-Account)
        const response = await fetch('/api/kling/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            imageUrl: item.image.url,
            prompt: item.prompt,
            duration: 5,
            aspectRatio: item.image.ratio || '9:16',
            model: item.model || 'kling3'
          })
        });

        if (response.ok) {
          const data = await response.json();
          item.taskId = data.taskId;
          
          // Poll for completion
          item.videoUrl = await pollVideoStatus(data.taskId);
          item.status = item.videoUrl ? 'complete' : 'error';
        } else {
          item.status = 'error';
        }
      } catch (err) {
        console.error('Video generation failed:', err);
        item.status = 'error';
      }
      
      renderVideoQueue();
      updateVideoTabBadge();
    }

    async function generateAllVideos() {
      const pending = videoQueue.filter(v => v.status === 'pending');
      for (const item of pending) {
        await generateVideo(item.id);
      }
    }

    function downloadVideo(id) {
      const item = videoQueue.find(v => v.id === id);
      if (item?.videoUrl) {
        const a = document.createElement('a');
        a.href = item.videoUrl;
        a.download = `aditor-video-${item.id}.mp4`;
        a.click();
      }
    }

    // Poll for video generation completion
    async function pollVideoStatus(taskId, maxAttempts = 60) {
      for (let i = 0; i < maxAttempts; i++) {
        await new Promise(r => setTimeout(r, 5000)); // Wait 5 seconds between polls
        
        try {
          const response = await fetch(`/api/kling/status/${taskId}`);
          if (response.ok) {
            const data = await response.json();
            console.log(`[Kling] Poll ${i + 1}: ${data.status}`);
            
            if (data.status === 'complete' && data.videoUrl) {
              return data.videoUrl;
            } else if (data.status === 'error') {
              console.error('[Kling] Generation failed');
              return null;
            }
          }
        } catch (err) {
          console.error('[Kling] Poll error:', err);
        }
      }
      
      console.error('[Kling] Timeout after', maxAttempts, 'attempts');
      return null;
    }

    // Legacy function for modal
    function addToVideoQueue(index) {
      toggleVideoQueue(index);
    }

    // ===== GENERATE =====
    generateBtn.addEventListener('click', generate);
    promptInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        generate();
      }
    });

    // Track active generations for concurrent requests
    let activeGenerations = 0;
    
    async function generate() {
      const rawPrompt = promptInput.value.trim();
      if (!rawPrompt && references.length === 0) return;

      const genCount = parseInt(document.getElementById('gen-count').value) || 1;

      let basePrompt = rawPrompt;
      let negativePrompt = '';
      let useLLMExpansion = (genMode === 'broll' || genMode === 'talking');
      
      // For B-roll and Talking Head modes, we'll use LLM expansion via backend
      // Raw mode: use prompt as-is
      if (genMode !== 'raw') {
        negativePrompt = 'phone frame, device bezel, iOS interface, Android UI, status bar, home bar, camera app, viewfinder, REC indicator, screenshot frame, notification bar, app interface, UI elements, UI overlay, professional studio lighting, bokeh, blurred background, centered composition, posed, perfect, polished, stock photo, watermark, text, timestamp, date, timecode, yellow tint, thumb in frame';
      }

      // Save values before clearing UI
      const savedPrompt = rawPrompt;
      const savedReferences = [...references];
      const savedRatio = selectedRatio;
      const savedModel = selectedModel;
      
      // Clear input immediately so user can prep next prompt
      promptInput.value = '';
      references = [];
      renderReferences();

      // Add loading placeholders to grid immediately
      const placeholderIds = [];
      for (let i = 0; i < genCount; i++) {
        const placeholderId = 'loading-' + Date.now() + '-' + i;
        placeholderIds.push(placeholderId);
        images.unshift({
          id: placeholderId,
          url: null,
          prompt: savedPrompt,
          ratio: savedRatio,
          model: savedModel,
          createdAt: new Date().toISOString(),
          loading: true,
          saved: false
        });
      }
      renderGrid();

      // Show generating indicator if first batch
      activeGenerations += genCount;
      generating.classList.add('active');
      updateGeneratingText();

      // Generate all images concurrently
      const generateOne = async (placeholderId, index) => {
        try {
          let finalPrompt = basePrompt;
          
          // Use LLM expansion for B-roll and Talking Head modes
          if (useLLMExpansion && savedPrompt) {
            console.log(`🤖 LLM expanding: "${savedPrompt.slice(0, 50)}..."`);
            const modeHint = genMode === 'talking' 
              ? 'This is for a talking head video still - person should be mid-sentence, looking at camera, in a home setting.'
              : 'This is UGC b-roll content - candid, casual, real-looking phone photo.';
            
            const expandRes = await fetch('/api/prompt/expand', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ 
                prompt: `${savedPrompt}. ${modeHint}`,
                mode: genMode
              })
            });
            
            if (expandRes.ok) {
              const expandData = await expandRes.json();
              if (expandData.expanded) {
                finalPrompt = expandData.expanded;
                console.log(`📝 Expanded to: "${finalPrompt.slice(0, 100)}..."`);
              }
            }
          }
          
          const response = await fetch('/api/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: finalPrompt,
              negativePrompt,
              references: savedReferences,
              ratio: savedRatio,
              model: savedModel
            })
          });

          const data = await response.json();
          console.log(`Image ${index + 1} response:`, data);

          // Find and update placeholder
          const placeholderIndex = images.findIndex(img => img.id === placeholderId);
          if (placeholderIndex >= 0) {
            if (response.ok && data.url) {
              images[placeholderIndex] = {
                url: data.url,
                prompt: savedPrompt,
                ratio: savedRatio,
                model: savedModel,
                createdAt: new Date().toISOString(),
                saved: false
              };
            } else {
              // Remove failed placeholder
              images.splice(placeholderIndex, 1);
              console.error('API error:', data);
            }
            saveImages();
            renderGrid();
          }
        } catch (err) {
          console.error(`Generation ${index + 1} failed:`, err);
          // Remove failed placeholder
          const placeholderIndex = images.findIndex(img => img.id === placeholderId);
          if (placeholderIndex >= 0) {
            images.splice(placeholderIndex, 1);
            renderGrid();
          }
        } finally {
          activeGenerations--;
          updateGeneratingText();
          if (activeGenerations === 0) {
            generating.classList.remove('active');
          }
        }
      };

      // Fire all requests concurrently
      placeholderIds.forEach((id, i) => generateOne(id, i));
    }
    
    function updateGeneratingText() {
      const text = activeGenerations > 0 ? `Generating ${activeGenerations}...` : 'Generating...';
      document.querySelector('.generating-text').textContent = text;
    }

    // ===== KEYBOARD SHORTCUTS =====
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeModal();
      }
    });

    // ===== PASTE IMAGES =====
    document.addEventListener('paste', (e) => {
      const items = e.clipboardData?.items;
      if (!items) return;

      for (const item of items) {
        if (item.type.startsWith('image/')) {
          const file = item.getAsFile();
          const reader = new FileReader();
          reader.onload = (e) => addReference(e.target.result);
          reader.readAsDataURL(file);
        }
      }
    });

    // ===== WORKFLOW STUDIO =====
    const workflowConfigs = {
      'script-to-video': {
        title: 'Script → UGC Video',
        desc: 'Upload avatar, paste script, select voice → get UGC video',
        customLayout: 'ugc-video',
        showUrl: false,
        showUpload: false,
        showScript: false,
        uploadHint: '',
        endpoint: '/api/ugc-video'
      },
      'kickstarter': {
        title: 'Kickstarter',
        desc: 'Paste a product page URL to generate 9:16 b-roll images and offer badges for VSLs.',
        showUrl: true,
        showUpload: false,
        showScript: false,
        uploadHint: '',
        endpoint: '/api/kickstarter'
      },
      'image-ads': {
        title: 'Image Ads',
        desc: 'Upload your product image and up to 8 inspiration ads to generate matching ad creatives.',
        showUrl: false,
        showUpload: true,
        showScript: false,
        uploadHint: 'Upload product image + inspiration ads',
        endpoint: '/api/image-ads'
      },
      'script-explainer': {
        title: 'Script → Explainer',
        desc: 'Paste your script and we\'ll generate consistent visual frames for an explainer video.',
        showUrl: false,
        showUpload: false,
        showScript: true,
        uploadHint: '',
        endpoint: '/api/script-explainer'
      },
      'screenshot-broll': {
        title: 'Screenshot → B-roll',
        desc: 'Upload a product image and a creator screenshot to recreate the frame with your product.',
        showUrl: false,
        showUpload: true,
        showScript: false,
        uploadHint: 'Upload product + creator screenshot',
        endpoint: '/api/screenshot-broll'
      },
      'motion-transfer': {
        title: 'Motion Transfer',
        desc: 'Upload an image and a driving video to transfer motion from the video to your image.',
        showUrl: false,
        showUpload: true,
        showScript: false,
        uploadHint: 'Upload image + driving video',
        endpoint: '/api/runcomfy/generate',
        model: 'kling-motion-pro'
      }
    };

    let currentWorkflow = 'script-to-video';
    let workflowFiles = [];
    let workflowResults = [];

    // Workflow sidebar click handler
    document.querySelectorAll('.workflow-item').forEach(item => {
      item.addEventListener('click', () => {
        const workflow = item.dataset.workflow;
        selectWorkflow(workflow);
      });
    });

    function selectWorkflow(workflow) {
      currentWorkflow = workflow;
      const config = workflowConfigs[workflow];
      if (!config) return;

      // Update sidebar active state
      document.querySelectorAll('.workflow-item').forEach(item => {
        item.classList.toggle('active', item.dataset.workflow === workflow);
      });

      // Update header
      document.getElementById('workflow-title').textContent = config.title;
      document.getElementById('workflow-description').textContent = config.desc;

      // Handle custom layouts
      const ugcLayout = document.getElementById('ugc-video-layout');
      const genericForm = document.getElementById('workflow-form');
      const uploadZone = document.getElementById('workflow-upload-zone');
      const promptBar = document.querySelector('.prompt-container');

      if (config.customLayout === 'ugc-video') {
        // Show UGC layout, hide generic form and prompt bar
        ugcLayout.style.display = 'grid';
        genericForm.style.display = 'none';
        uploadZone.style.display = 'none';
        if (promptBar) promptBar.style.display = 'none';
      } else {
        // Show generic form, hide UGC layout
        ugcLayout.style.display = 'none';
        genericForm.style.display = 'block';
        if (promptBar) promptBar.style.display = 'block';
        
        // Show/hide form fields
        document.getElementById('url-field').style.display = config.showUrl ? 'flex' : 'none';
        document.getElementById('script-field').style.display = config.showScript ? 'flex' : 'none';
        uploadZone.style.display = config.showUpload ? 'block' : 'none';
        document.getElementById('workflow-upload-hint').textContent = config.uploadHint;
      }

      // Clear form
      document.getElementById('workflow-url').value = '';
      document.getElementById('workflow-script').value = '';
      workflowFiles = [];
      renderWorkflowPreviews();

      // Clear results
      workflowResults = [];
      renderWorkflowResults();
    }

    // File upload handling
    const workflowUploadZone = document.getElementById('workflow-upload-zone');
    const workflowFileInput = document.getElementById('workflow-file-input');

    workflowUploadZone.addEventListener('click', (e) => {
      if (e.target.closest('.workflow-preview-remove')) return;
      workflowFileInput.click();
    });

    workflowUploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      workflowUploadZone.classList.add('dragover');
    });

    workflowUploadZone.addEventListener('dragleave', () => {
      workflowUploadZone.classList.remove('dragover');
    });

    workflowUploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      workflowUploadZone.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files);
      workflowFiles.push(...files);
      renderWorkflowPreviews();
    });

    workflowFileInput.addEventListener('change', () => {
      const files = Array.from(workflowFileInput.files);
      workflowFiles.push(...files);
      renderWorkflowPreviews();
      workflowFileInput.value = '';
    });

    function renderWorkflowPreviews() {
      const container = document.getElementById('workflow-upload-preview');
      container.classList.toggle('has-files', workflowFiles.length > 0);
      
      container.innerHTML = workflowFiles.map((file, i) => {
        const isVideo = file.type.startsWith('video/');
        const url = URL.createObjectURL(file);
        return `
          <div class="workflow-preview-item">
            ${isVideo 
              ? `<video src="${url}" muted></video>`
              : `<img src="${url}" alt="${file.name}">`
            }
            <button class="workflow-preview-remove" onclick="removeWorkflowFile(${i})">×</button>
          </div>
        `;
      }).join('');
    }

    window.removeWorkflowFile = function(index) {
      workflowFiles.splice(index, 1);
      renderWorkflowPreviews();
    };

    // Form submission
    document.getElementById('workflow-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      await runWorkflow();
    });

    // ===== UGC VIDEO WORKFLOW HANDLERS =====
    let ugcAvatarFile = null;

    const ugcAvatarUpload = document.getElementById('ugc-avatar-upload');
    const ugcAvatarInput = document.getElementById('ugc-avatar-input');

    ugcAvatarUpload.addEventListener('click', () => ugcAvatarInput.click());
    
    ugcAvatarUpload.addEventListener('dragover', (e) => {
      e.preventDefault();
      ugcAvatarUpload.classList.add('dragover');
    });
    
    ugcAvatarUpload.addEventListener('dragleave', () => {
      ugcAvatarUpload.classList.remove('dragover');
    });
    
    ugcAvatarUpload.addEventListener('drop', (e) => {
      e.preventDefault();
      ugcAvatarUpload.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        setUgcAvatar(file);
      }
    });
    
    ugcAvatarInput.addEventListener('change', () => {
      const file = ugcAvatarInput.files[0];
      if (file) setUgcAvatar(file);
    });

    function setUgcAvatar(file) {
      ugcAvatarFile = file;
      const url = URL.createObjectURL(file);
      
      // Remove existing preview
      const existingPreview = ugcAvatarUpload.querySelector('.avatar-preview');
      if (existingPreview) existingPreview.remove();
      
      // Add preview image
      const img = document.createElement('img');
      img.src = url;
      img.className = 'avatar-preview';
      ugcAvatarUpload.appendChild(img);
      ugcAvatarUpload.classList.add('has-image');
    }

    // UGC Generate button
    document.getElementById('ugc-generate-btn').addEventListener('click', async () => {
      const script = document.getElementById('ugc-script').value.trim();
      const voice = document.getElementById('ugc-voice').value;
      
      if (!ugcAvatarFile) {
        alert('Please upload an avatar image');
        return;
      }
      if (!script) {
        alert('Please enter a script');
        return;
      }

      const btn = document.getElementById('ugc-generate-btn');
      btn.disabled = true;
      btn.textContent = 'Generating...';

      // Show loading in results
      workflowResults = [{ loading: true, id: 'loading-0', isVideo: true }];
      renderWorkflowResults();

      try {
        const formData = new FormData();
        formData.append('avatar', ugcAvatarFile);
        formData.append('script', script);
        formData.append('voice', voice);

        const response = await fetch('/api/ugc-video', {
          method: 'POST',
          body: formData
        });

        const data = await response.json();
        
        if (data.videoUrl) {
          workflowResults = [{ 
            url: data.videoUrl, 
            isVideo: true,
            downloadUrl: data.downloadUrl || data.videoUrl
          }];
        } else if (data.jobId) {
          // Poll for completion
          await pollUgcVideoStatus(data.jobId);
        } else {
          workflowResults = [];
          console.error('UGC video error:', data);
        }
        renderWorkflowResults();
      } catch (err) {
        console.error('UGC video error:', err);
        workflowResults = [];
        renderWorkflowResults();
      } finally {
        btn.disabled = false;
        btn.textContent = 'Generate';
      }
    });

    async function pollUgcVideoStatus(jobId) {
      return new Promise((resolve) => {
        const pollInterval = setInterval(async () => {
          try {
            const res = await fetch(`/api/ugc-video/status/${jobId}`);
            const status = await res.json();
            
            if (status.status === 'complete' && status.videoUrl) {
              clearInterval(pollInterval);
              workflowResults = [{ 
                url: status.videoUrl, 
                isVideo: true,
                downloadUrl: status.downloadUrl || status.videoUrl
              }];
              renderWorkflowResults();
              resolve();
            } else if (status.status === 'error') {
              clearInterval(pollInterval);
              workflowResults = [];
              renderWorkflowResults();
              resolve();
            }
          } catch (err) {
            console.error('Poll error:', err);
          }
        }, 3000);
      });
    }

    async function runWorkflow() {
      const config = workflowConfigs[currentWorkflow];
      const submitBtn = document.getElementById('workflow-submit');
      submitBtn.disabled = true;
      submitBtn.textContent = 'Generating...';

      try {
        if (currentWorkflow === 'kickstarter') {
          await runKickstarterWorkflow();
        } else if (currentWorkflow === 'motion-transfer') {
          await runMotionTransferWorkflow();
        } else if (currentWorkflow === 'script-to-video' || currentWorkflow === 'script-explainer') {
          await runScriptToVideoWorkflow();
        } else {
          // Generic workflow handler (TODO: implement others)
          console.log('Workflow not yet implemented:', currentWorkflow);
        }
      } catch (err) {
        console.error('Workflow error:', err);
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Generate';
      }
    }

    async function runKickstarterWorkflow() {
      const url = document.getElementById('workflow-url').value.trim();
      if (!url) return;

      // Add loading placeholders
      workflowResults = Array(7).fill().map((_, i) => ({ loading: true, id: 'loading-' + i }));
      renderWorkflowResults();

      const response = await fetch('/api/kickstarter', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url })
      });
      
      const data = await response.json();
      if (!data.jobId) {
        workflowResults = [];
        renderWorkflowResults();
        return;
      }

      // Poll for status
      const pollInterval = setInterval(async () => {
        try {
          const statusRes = await fetch(`/api/kickstarter/status/${data.jobId}`);
          const status = await statusRes.json();
          
          if (status.generatedImages && status.generatedImages.length > 0) {
            workflowResults = status.generatedImages.map(img => ({
              url: img.thumbnail || img.url || img,
              fullRes: img.fullRes || img.url || img,
              thumbnail: img.thumbnail || img.url || img
            }));
            renderWorkflowResults();
          }

          if (status.status === 'complete' || status.status === 'error') {
            clearInterval(pollInterval);
          }
        } catch (err) {
          console.error('Poll error:', err);
        }
      }, 3000);
    }

    async function runMotionTransferWorkflow() {
      if (workflowFiles.length < 2) {
        alert('Please upload an image and a driving video');
        return;
      }

      const formData = new FormData();
      formData.append('model', 'kling-motion-pro');
      formData.append('type', 'video-to-video');
      
      // First file should be image, second should be video
      workflowFiles.forEach((file, i) => {
        if (file.type.startsWith('image/')) {
          formData.append('image', file);
        } else if (file.type.startsWith('video/')) {
          formData.append('video', file);
        }
      });

      workflowResults = [{ loading: true, id: 'loading-0' }];
      renderWorkflowResults();

      const response = await fetch('/api/runcomfy/generate', {
        method: 'POST',
        body: formData
      });

      const data = await response.json();
      if (data.videoUrl) {
        workflowResults = [{ url: data.videoUrl, isVideo: true }];
      } else if (data.taskId) {
        // Poll for completion
        await pollRunComfyStatus(data.taskId);
      } else {
        workflowResults = [];
      }
      renderWorkflowResults();
    }

    async function runScriptToVideoWorkflow() {
      const script = document.getElementById('workflow-script')?.value?.trim();
      if (!script) {
        alert('Please enter a script');
        return;
      }

      // Add loading placeholders
      workflowResults = Array(5).fill().map((_, i) => ({ loading: true, id: 'loading-' + i }));
      renderWorkflowResults();

      try {
        const response = await fetch('/api/script-explainer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ script })
        });
        
        const data = await response.json();
        if (data.jobId) {
          // Poll for status
          const pollInterval = setInterval(async () => {
            try {
              const statusRes = await fetch(`/api/script-explainer/status/${data.jobId}`);
              const status = await statusRes.json();
              
              if (status.status === 'complete' && status.results) {
                clearInterval(pollInterval);
                workflowResults = status.results.map(r => ({
                  url: r.url || r,
                  thumbnail: r.thumbnail,
                  fullRes: r.fullRes || r.url || r
                }));
                renderWorkflowResults();
              } else if (status.status === 'error') {
                clearInterval(pollInterval);
                workflowResults = [];
                renderWorkflowResults();
              }
            } catch (err) {
              console.error('Poll error:', err);
            }
          }, 3000);
        } else if (data.results) {
          workflowResults = data.results.map(r => ({
            url: r.url || r,
            thumbnail: r.thumbnail,
            fullRes: r.fullRes || r.url || r
          }));
          renderWorkflowResults();
        } else {
          workflowResults = [];
          renderWorkflowResults();
        }
      } catch (err) {
        console.error('Script workflow error:', err);
        workflowResults = [];
        renderWorkflowResults();
      }
    }

    async function pollRunComfyStatus(taskId) {
      // TODO: implement polling for RunComfy tasks
      console.log('Polling for task:', taskId);
    }

    function renderWorkflowResults() {
      const grid = document.getElementById('workflow-results-grid');
      const empty = document.getElementById('workflow-results-empty');
      const count = document.getElementById('workflow-results-count');

      const actualResults = workflowResults.filter(r => r.url);
      count.textContent = actualResults.length;

      if (workflowResults.length === 0) {
        grid.innerHTML = '';
        empty.style.display = 'block';
        return;
      }

      empty.style.display = 'none';
      grid.innerHTML = workflowResults.map((result, i) => {
        if (result.loading) {
          return `
            <div class="workflow-result-item workflow-result-loading">
              <div class="grid-item-spinner"></div>
            </div>
          `;
        }
        
        if (result.isVideo) {
          const downloadUrl = result.downloadUrl || result.url;
          return `
            <div class="workflow-result-item workflow-result-video">
              <video src="${result.url}" controls muted></video>
              <a href="${downloadUrl}" download class="workflow-download-link" target="_blank">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="16" height="16">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                </svg>
                Download Video
              </a>
            </div>
          `;
        }
        
        // Use thumbnail for display, store fullRes for later use
        const displayUrl = result.thumbnail || result.url;
        const fullResUrl = result.fullRes || result.url;
        return `
          <div class="workflow-result-item" onclick="addToMainGrid('${fullResUrl}')" data-full-res="${fullResUrl}">
            <img src="${displayUrl}" alt="Result ${i + 1}" loading="lazy">
          </div>
        `;
      }).join('');
    }

    window.addToMainGrid = function(url) {
      images.unshift({
        url: url,
        prompt: currentWorkflow + ' workflow output',
        ratio: '9:16',
        model: 'workflow',
        createdAt: new Date().toISOString(),
        saved: false
      });
      saveImages();
      renderGrid();
      // Switch to Images tab
      document.querySelector('[data-tab="images"]').click();
    };

    // Legacy shortcut-card handler (for compatibility)
    document.querySelectorAll('.shortcut-card').forEach(card => {
      card.addEventListener('click', () => {
        const workflow = card.dataset.workflow;
        selectWorkflow(workflow);
        document.querySelector('[data-tab="shortcuts"]').click();
      });
    });

    // Legacy showWorkflowModal - now redirects to workflow studio
    function showWorkflowModal(workflow) {
      selectWorkflow(workflow);
      document.querySelector('[data-tab="shortcuts"]').click();
    }

    // ===== CONTEXT PROFILES (disabled in UI) =====
    const contextSelect = document.getElementById('context-profile');
    const newContextBtn = document.getElementById('new-context-btn');

    // Only run if context UI elements exist
    if (contextSelect && newContextBtn) {
      async function loadContextProfiles() {
      try {
        const response = await fetch('/api/context/profiles');
        if (response.ok) {
          const data = await response.json();
          // Clear existing options except "No context"
          contextSelect.innerHTML = '<option value="">No context</option>';
          // Add profiles
          data.profiles.forEach(profile => {
            const option = document.createElement('option');
            option.value = profile.id;
            option.textContent = profile.name || profile.id;
            option.title = profile.tagline || '';
            contextSelect.appendChild(option);
          });
          // Restore selection from localStorage
          const savedContext = localStorage.getItem('aditor_context_profile');
          if (savedContext && data.profiles.find(p => p.id === savedContext)) {
            contextSelect.value = savedContext;
          }
        }
      } catch (err) {
        console.error('Failed to load context profiles:', err);
      }
    }

    // Save selection to localStorage
    contextSelect.addEventListener('change', () => {
      localStorage.setItem('aditor_context_profile', contextSelect.value);
      if (contextSelect.value) {
        console.log('🎨 Context profile active:', contextSelect.value);
      }
    });

    // New context profile modal
    newContextBtn.addEventListener('click', () => {
      showContextModal();
    });

    function showContextModal() {
      const overlay = document.createElement('div');
      overlay.className = 'context-modal-overlay';
      overlay.innerHTML = `
        <div class="context-modal">
          <h2>Create Context Profile</h2>
          <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
            Describe your brand or product. The AI will create a consistent style guide for all generations.
          </p>
          <input type="text" class="context-name-input" placeholder="Profile name (e.g., wellness-brand)" />
          <textarea class="context-vision-input" placeholder="Describe your brand vision, target audience, visual style, product type...

Example: Premium wellness supplement brand targeting health-conscious millennials. Clean, minimal aesthetic with earth tones. Products are organic, science-backed. Think Ritual meets Athletic Greens."></textarea>
          <div class="context-modal-actions">
            <button class="context-cancel-btn">Cancel</button>
            <button class="context-generate-btn">Generate Profile</button>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);

      const nameInput = overlay.querySelector('.context-name-input');
      const visionInput = overlay.querySelector('.context-vision-input');
      const generateBtn = overlay.querySelector('.context-generate-btn');
      const cancelBtn = overlay.querySelector('.context-cancel-btn');

      cancelBtn.addEventListener('click', () => overlay.remove());
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) overlay.remove();
      });

      generateBtn.addEventListener('click', async () => {
        const name = nameInput.value.trim();
        const vision = visionInput.value.trim();
        
        if (!vision) {
          visionInput.style.borderColor = 'red';
          return;
        }

        generateBtn.textContent = 'Generating...';
        generateBtn.disabled = true;

        try {
          const response = await fetch('/api/context/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, vision })
          });

          if (response.ok) {
            const data = await response.json();
            console.log('✅ Context profile created:', data.profile);
            await loadContextProfiles();
            contextSelect.value = data.profile.id;
            localStorage.setItem('aditor_context_profile', data.profile.id);
            overlay.remove();
          } else {
            const err = await response.json();
            alert('Failed to generate profile: ' + (err.error || 'Unknown error'));
            generateBtn.textContent = 'Generate Profile';
            generateBtn.disabled = false;
          }
        } catch (err) {
          console.error('Context generation error:', err);
          alert('Failed to generate profile');
          generateBtn.textContent = 'Generate Profile';
          generateBtn.disabled = false;
        }
      });

      nameInput.focus();
    }
    } // end if (contextSelect && newContextBtn)

    // ===== INIT =====
    renderGrid();
    // loadContextProfiles(); // disabled - context UI removed
    
    // Initialize workflow (UGC video is default, needs custom layout)
    selectWorkflow('script-to-video');
  </script>

</body>
</html>
